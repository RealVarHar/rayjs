#include <stdlib.h>
#include "raylib.h"
#include "rlgl.h"
#define GLAD_MALLOC(sz) malloc(sz)
#define GLAD_FREE(sz) free(sz)
//#define GLAD_GL_IMPLEMENTATION
#include "../thirdparty/raylib/src/external/glad.h"

#define LIGHTMAPPER_IMPLEMENTATION
#define LM_DEBUG_INTERPOLATION
#include "lightmapper.h"

// load shader
const char *vp =
	"#version 150 core\n"
	"in vec3 a_position;\n"
	"in vec2 a_texcoord;\n"
	"uniform mat4 u_view;\n"
	"uniform mat4 u_projection;\n"
	"out vec2 v_texcoord;\n"

	"void main()\n"
	"{\n"
	"gl_Position = u_projection * (u_view * vec4(a_position, 1.0));\n"
	"v_texcoord = a_texcoord;\n"
	"}\n";

const char *fp =
	"#version 150 core\n"
	"in vec2 v_texcoord;\n"
	"uniform sampler2D u_lightmap;\n"
	"out vec4 o_color;\n"

	"void main()\n"
	"{\n"
	"o_color = vec4(texture(u_lightmap, v_texcoord).rgb, gl_FrontFacing ? 1.0 : 0.0);\n"
	"}\n";

const char *attribs[] =
{
	"a_position",
	"a_texcoord"
};

int main(void)
{
    // Initialization
    //--------------------------------------------------------------------------------------
    const int screenWidth = 800;
    const int screenHeight = 450;

    InitWindow(screenWidth, screenHeight, "raylib [models] lightmapping");

    

    Model model = LoadModel("thirdparty/lightmapper/example/gazebo.obj");
	Shader shader = LoadShaderFromMemory(vp, fp); 
	Texture texture = LoadTextureFromImage(GenImageColor(1,1,BLACK));
	int u_view = GetShaderLocation(shader, "u_view");
	int u_projection = GetShaderLocation(shader, "u_projection");
	int u_lightmap = GetShaderLocation(shader, "u_lightmap");

	
    Vector3 position = { 0.0f, 0.0f, 0.0f }; 

    //--------------------------------------------------------------------------------------

	lm_context *ctx = lmCreate(
		64,               // hemisphere resolution (power of two, max=512)
		0.001f, 100.0f,   // zNear, zFar of hemisphere cameras
		1.0f, 1.0f, 1.0f, // background color (white for ambient occlusion)
		2, 0.01f,         // lightmap interpolation threshold (small differences are interpolated rather than sampled)
						  // check debug_interpolation.tga for an overview of sampled (red) vs interpolated (green) pixels.
		0.0f);            // modifier for camera-to-surface distance for hemisphere rendering.
		                  // tweak this to trade-off between interpolated normals quality and other artifacts (see declaration).

	if (!ctx) TraceLog(LOG_ERROR, "Lightmapper not initialized");

	int w = 512;
	int h = 512;
	float *data = calloc(w*h*4,sizeof(float));

	lmSetTargetLightmap(ctx, data, w, h, 4);

	Mesh m = model.meshes[0];

	lmSetGeometry(ctx, NULL,                                                                 // no transformation in this example
		LM_FLOAT, m.vertices, 0,
		LM_NONE , NULL, 0,
		LM_FLOAT, m.texcoords, 0,
		m.vertexCount, LM_NONE, 0);

	printf("%p\n", m.texcoords);

	int vp[4];
	Matrix view, projection;
	double lastUpdateTime = 0.0;

	Mesh mesh = model.meshes[0];
	//SetTargetFPS(10000);
	while (lmBegin(ctx, vp, (float*)&view, (float*)&projection))
	{
		glViewport(vp[0], vp[1], vp[2], vp[3]);
		glEnable(GL_DEPTH_TEST);

		glUseProgram(shader.id);
		glUniform1i(u_lightmap, 0);
		glUniformMatrix4fv(u_projection, 1, GL_FALSE, (float *)&projection);
		glUniformMatrix4fv(u_view, 1, GL_FALSE, (float *)&view);

		glBindTexture(GL_TEXTURE_2D, texture.id);

		glBindVertexArray(mesh.vaoId);
		glDrawArrays(GL_TRIANGLES, 0, mesh.vertexCount);

		double time = GetTime();
		if (time - lastUpdateTime > 1.0)
		{
			lastUpdateTime = time;
			printf("\r%6.2f%%", lmProgress(ctx) * 100.0f);
			fflush(stdout);
		}

		lmEnd(ctx);
		if(WindowShouldClose()) break;

	}

	// postprocess texture
	float *temp = calloc(w * h * 4, sizeof(float));
	for (int i = 0; i < 16; i++)
	{
		lmImageDilate(data, temp, w, h, 4);
		lmImageDilate(temp, data, w, h, 4);
	}
	lmImageSmooth(data, temp, w, h, 4);
	lmImageDilate(temp, data, w, h, 4);
	lmImagePower(data, w, h, 4, 1.0f / 2.2f, 0x7); // gamma correct color channels
	free(temp);

	// save result to a file
	if (lmImageSaveTGAf("result.tga", data, w, h, 4, 1.0f))
		printf("Saved result.tga\n");

	rlViewport(0,0, screenWidth, screenHeight);

	
// Define the camera to look into our 3d world
    Camera camera = { 0 };
    camera.position = (Vector3){ 1.0f, 0.5f, 1.0f }; // Camera position
    camera.target = (Vector3){ 0.0f, 0.0f, 0.0f };     // Camera looking at point
    camera.up = (Vector3){ 0.0f, 1.0f, 0.0f };          // Camera up vector (rotation towards target)
    camera.fovy = 45.0f;                                // Camera field-of-view Y
    camera.projection = CAMERA_PERSPECTIVE;                   // Camera mode type

    SetTargetFPS(60);               // Set our game to run at 60 frames-per-second

    // Main game loop
    while (!WindowShouldClose())    // Detect window close button or ESC key
    {
        // Update
        //----------------------------------------------------------------------------------
        //UpdateCamera(&camera, CAMERA_FIRST_PERSON);       

        //----------------------------------------------------------------------------------

        // Draw
        //----------------------------------------------------------------------------------
        BeginDrawing();

            ClearBackground(RAYWHITE);

            BeginMode3D(camera);

                DrawModel(model, position, 1.0f, WHITE);

            EndMode3D();

        EndDrawing();
        //----------------------------------------------------------------------------------
    }

    // De-Initialization
    //--------------------------------------------------------------------------------------
    //UnloadTexture(texture);     // Unload texture
    UnloadModel(model);         // Unload model

    CloseWindow();              // Close window and OpenGL context
    //--------------------------------------------------------------------------------------

    return 0;
}