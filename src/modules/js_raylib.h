#ifndef JS_js_raylib_GUARD
	#define JS_js_raylib_GUARD
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include <rayjs_base.h>
	#include <config.h>
	#include <rayjs_generated.h>
	#include <raylib.h>
	
	static void js_Vector2_finalizer(JSRuntime * rt,JSValue val){
		Vector2 * ptr=(Vector2 *)JS_GetOpaque(val,js_Vector2_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Vector2_get_x(JSContext * ctx,JSValue this_val){
		Vector2 * ptr=(Vector2 *)JS_GetOpaque2(ctx,this_val,js_Vector2_class_id);
		float x=ptr[0].x;
		JSValue ret=JS_NewFloat64(ctx,((double)x));
		return ret;
	}
	
	static JSValue js_Vector2_set_x(JSContext * ctx,JSValue this_val,JSValue v){
		Vector2 * ptr=(Vector2 *)JS_GetOpaque2(ctx,this_val,js_Vector2_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].x=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Vector2_get_y(JSContext * ctx,JSValue this_val){
		Vector2 * ptr=(Vector2 *)JS_GetOpaque2(ctx,this_val,js_Vector2_class_id);
		float y=ptr[0].y;
		JSValue ret=JS_NewFloat64(ctx,((double)y));
		return ret;
	}
	
	static JSValue js_Vector2_set_y(JSContext * ctx,JSValue this_val,JSValue v){
		Vector2 * ptr=(Vector2 *)JS_GetOpaque2(ctx,this_val,js_Vector2_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].y=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Vector2_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Vector2", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("x",js_Vector2_get_x,js_Vector2_set_x),
		JS_CGETSET_DEF("y",js_Vector2_get_y,js_Vector2_set_y)
	};
	
	static int js_declare_Vector2(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Vector2_class_id);
		JSClassDef js_Vector2_def={ .class_name = "Vector2", .finalizer = js_Vector2_finalizer };
		JS_NewClass(rt,js_Vector2_class_id,(const JSClassDef *)&js_Vector2_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Vector2_proto_funcs,(int)countof(js_Vector2_proto_funcs));
		JS_SetClassProto(ctx,js_Vector2_class_id,proto);
		return 0;
	}
	
	static void js_Vector3_finalizer(JSRuntime * rt,JSValue val){
		Vector3 * ptr=(Vector3 *)JS_GetOpaque(val,js_Vector3_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Vector3_get_x(JSContext * ctx,JSValue this_val){
		Vector3 * ptr=(Vector3 *)JS_GetOpaque2(ctx,this_val,js_Vector3_class_id);
		float x=ptr[0].x;
		JSValue ret=JS_NewFloat64(ctx,((double)x));
		return ret;
	}
	
	static JSValue js_Vector3_set_x(JSContext * ctx,JSValue this_val,JSValue v){
		Vector3 * ptr=(Vector3 *)JS_GetOpaque2(ctx,this_val,js_Vector3_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].x=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Vector3_get_y(JSContext * ctx,JSValue this_val){
		Vector3 * ptr=(Vector3 *)JS_GetOpaque2(ctx,this_val,js_Vector3_class_id);
		float y=ptr[0].y;
		JSValue ret=JS_NewFloat64(ctx,((double)y));
		return ret;
	}
	
	static JSValue js_Vector3_set_y(JSContext * ctx,JSValue this_val,JSValue v){
		Vector3 * ptr=(Vector3 *)JS_GetOpaque2(ctx,this_val,js_Vector3_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].y=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Vector3_get_z(JSContext * ctx,JSValue this_val){
		Vector3 * ptr=(Vector3 *)JS_GetOpaque2(ctx,this_val,js_Vector3_class_id);
		float z=ptr[0].z;
		JSValue ret=JS_NewFloat64(ctx,((double)z));
		return ret;
	}
	
	static JSValue js_Vector3_set_z(JSContext * ctx,JSValue this_val,JSValue v){
		Vector3 * ptr=(Vector3 *)JS_GetOpaque2(ctx,this_val,js_Vector3_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].z=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Vector3_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Vector3", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("x",js_Vector3_get_x,js_Vector3_set_x),
		JS_CGETSET_DEF("y",js_Vector3_get_y,js_Vector3_set_y),
		JS_CGETSET_DEF("z",js_Vector3_get_z,js_Vector3_set_z)
	};
	
	static int js_declare_Vector3(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Vector3_class_id);
		JSClassDef js_Vector3_def={ .class_name = "Vector3", .finalizer = js_Vector3_finalizer };
		JS_NewClass(rt,js_Vector3_class_id,(const JSClassDef *)&js_Vector3_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Vector3_proto_funcs,(int)countof(js_Vector3_proto_funcs));
		JS_SetClassProto(ctx,js_Vector3_class_id,proto);
		return 0;
	}
	
	static void js_Vector4_finalizer(JSRuntime * rt,JSValue val){
		Vector4 * ptr=(Vector4 *)JS_GetOpaque(val,js_Vector4_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Vector4_get_x(JSContext * ctx,JSValue this_val){
		Vector4 * ptr=(Vector4 *)JS_GetOpaque2(ctx,this_val,js_Vector4_class_id);
		float x=ptr[0].x;
		JSValue ret=JS_NewFloat64(ctx,((double)x));
		return ret;
	}
	
	static JSValue js_Vector4_set_x(JSContext * ctx,JSValue this_val,JSValue v){
		Vector4 * ptr=(Vector4 *)JS_GetOpaque2(ctx,this_val,js_Vector4_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].x=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Vector4_get_y(JSContext * ctx,JSValue this_val){
		Vector4 * ptr=(Vector4 *)JS_GetOpaque2(ctx,this_val,js_Vector4_class_id);
		float y=ptr[0].y;
		JSValue ret=JS_NewFloat64(ctx,((double)y));
		return ret;
	}
	
	static JSValue js_Vector4_set_y(JSContext * ctx,JSValue this_val,JSValue v){
		Vector4 * ptr=(Vector4 *)JS_GetOpaque2(ctx,this_val,js_Vector4_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].y=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Vector4_get_z(JSContext * ctx,JSValue this_val){
		Vector4 * ptr=(Vector4 *)JS_GetOpaque2(ctx,this_val,js_Vector4_class_id);
		float z=ptr[0].z;
		JSValue ret=JS_NewFloat64(ctx,((double)z));
		return ret;
	}
	
	static JSValue js_Vector4_set_z(JSContext * ctx,JSValue this_val,JSValue v){
		Vector4 * ptr=(Vector4 *)JS_GetOpaque2(ctx,this_val,js_Vector4_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].z=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Vector4_get_w(JSContext * ctx,JSValue this_val){
		Vector4 * ptr=(Vector4 *)JS_GetOpaque2(ctx,this_val,js_Vector4_class_id);
		float w=ptr[0].w;
		JSValue ret=JS_NewFloat64(ctx,((double)w));
		return ret;
	}
	
	static JSValue js_Vector4_set_w(JSContext * ctx,JSValue this_val,JSValue v){
		Vector4 * ptr=(Vector4 *)JS_GetOpaque2(ctx,this_val,js_Vector4_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].w=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Vector4_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Vector4", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("x",js_Vector4_get_x,js_Vector4_set_x),
		JS_CGETSET_DEF("y",js_Vector4_get_y,js_Vector4_set_y),
		JS_CGETSET_DEF("z",js_Vector4_get_z,js_Vector4_set_z),
		JS_CGETSET_DEF("w",js_Vector4_get_w,js_Vector4_set_w)
	};
	
	static int js_declare_Vector4(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Vector4_class_id);
		JSClassDef js_Vector4_def={ .class_name = "Vector4", .finalizer = js_Vector4_finalizer };
		JS_NewClass(rt,js_Vector4_class_id,(const JSClassDef *)&js_Vector4_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Vector4_proto_funcs,(int)countof(js_Vector4_proto_funcs));
		JS_SetClassProto(ctx,js_Vector4_class_id,proto);
		return 0;
	}
	
	static void js_Matrix_finalizer(JSRuntime * rt,JSValue val){
		Matrix * ptr=(Matrix *)JS_GetOpaque(val,js_Matrix_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Matrix_get_m0(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m0=ptr[0].m0;
		JSValue ret=JS_NewFloat64(ctx,((double)m0));
		return ret;
	}
	
	static JSValue js_Matrix_set_m0(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m0=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m4(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m4=ptr[0].m4;
		JSValue ret=JS_NewFloat64(ctx,((double)m4));
		return ret;
	}
	
	static JSValue js_Matrix_set_m4(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m4=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m8(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m8=ptr[0].m8;
		JSValue ret=JS_NewFloat64(ctx,((double)m8));
		return ret;
	}
	
	static JSValue js_Matrix_set_m8(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m8=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m12(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m12=ptr[0].m12;
		JSValue ret=JS_NewFloat64(ctx,((double)m12));
		return ret;
	}
	
	static JSValue js_Matrix_set_m12(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m12=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m1(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m1=ptr[0].m1;
		JSValue ret=JS_NewFloat64(ctx,((double)m1));
		return ret;
	}
	
	static JSValue js_Matrix_set_m1(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m1=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m5(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m5=ptr[0].m5;
		JSValue ret=JS_NewFloat64(ctx,((double)m5));
		return ret;
	}
	
	static JSValue js_Matrix_set_m5(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m5=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m9(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m9=ptr[0].m9;
		JSValue ret=JS_NewFloat64(ctx,((double)m9));
		return ret;
	}
	
	static JSValue js_Matrix_set_m9(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m9=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m13(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m13=ptr[0].m13;
		JSValue ret=JS_NewFloat64(ctx,((double)m13));
		return ret;
	}
	
	static JSValue js_Matrix_set_m13(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m13=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m2(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m2=ptr[0].m2;
		JSValue ret=JS_NewFloat64(ctx,((double)m2));
		return ret;
	}
	
	static JSValue js_Matrix_set_m2(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m2=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m6(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m6=ptr[0].m6;
		JSValue ret=JS_NewFloat64(ctx,((double)m6));
		return ret;
	}
	
	static JSValue js_Matrix_set_m6(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m6=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m10(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m10=ptr[0].m10;
		JSValue ret=JS_NewFloat64(ctx,((double)m10));
		return ret;
	}
	
	static JSValue js_Matrix_set_m10(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m10=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m14(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m14=ptr[0].m14;
		JSValue ret=JS_NewFloat64(ctx,((double)m14));
		return ret;
	}
	
	static JSValue js_Matrix_set_m14(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m14=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m3(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m3=ptr[0].m3;
		JSValue ret=JS_NewFloat64(ctx,((double)m3));
		return ret;
	}
	
	static JSValue js_Matrix_set_m3(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m3=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m7(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m7=ptr[0].m7;
		JSValue ret=JS_NewFloat64(ctx,((double)m7));
		return ret;
	}
	
	static JSValue js_Matrix_set_m7(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m7=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m11(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m11=ptr[0].m11;
		JSValue ret=JS_NewFloat64(ctx,((double)m11));
		return ret;
	}
	
	static JSValue js_Matrix_set_m11(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m11=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Matrix_get_m15(JSContext * ctx,JSValue this_val){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		float m15=ptr[0].m15;
		JSValue ret=JS_NewFloat64(ctx,((double)m15));
		return ret;
	}
	
	static JSValue js_Matrix_set_m15(JSContext * ctx,JSValue this_val,JSValue v){
		Matrix * ptr=(Matrix *)JS_GetOpaque2(ctx,this_val,js_Matrix_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].m15=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Matrix_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Matrix", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("m0",js_Matrix_get_m0,js_Matrix_set_m0),
		JS_CGETSET_DEF("m4",js_Matrix_get_m4,js_Matrix_set_m4),
		JS_CGETSET_DEF("m8",js_Matrix_get_m8,js_Matrix_set_m8),
		JS_CGETSET_DEF("m12",js_Matrix_get_m12,js_Matrix_set_m12),
		JS_CGETSET_DEF("m1",js_Matrix_get_m1,js_Matrix_set_m1),
		JS_CGETSET_DEF("m5",js_Matrix_get_m5,js_Matrix_set_m5),
		JS_CGETSET_DEF("m9",js_Matrix_get_m9,js_Matrix_set_m9),
		JS_CGETSET_DEF("m13",js_Matrix_get_m13,js_Matrix_set_m13),
		JS_CGETSET_DEF("m2",js_Matrix_get_m2,js_Matrix_set_m2),
		JS_CGETSET_DEF("m6",js_Matrix_get_m6,js_Matrix_set_m6),
		JS_CGETSET_DEF("m10",js_Matrix_get_m10,js_Matrix_set_m10),
		JS_CGETSET_DEF("m14",js_Matrix_get_m14,js_Matrix_set_m14),
		JS_CGETSET_DEF("m3",js_Matrix_get_m3,js_Matrix_set_m3),
		JS_CGETSET_DEF("m7",js_Matrix_get_m7,js_Matrix_set_m7),
		JS_CGETSET_DEF("m11",js_Matrix_get_m11,js_Matrix_set_m11),
		JS_CGETSET_DEF("m15",js_Matrix_get_m15,js_Matrix_set_m15)
	};
	
	static int js_declare_Matrix(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Matrix_class_id);
		JSClassDef js_Matrix_def={ .class_name = "Matrix", .finalizer = js_Matrix_finalizer };
		JS_NewClass(rt,js_Matrix_class_id,(const JSClassDef *)&js_Matrix_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Matrix_proto_funcs,(int)countof(js_Matrix_proto_funcs));
		JS_SetClassProto(ctx,js_Matrix_class_id,proto);
		return 0;
	}
	
	static void js_Color_finalizer(JSRuntime * rt,JSValue val){
		Color * ptr=(Color *)JS_GetOpaque(val,js_Color_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Color_get_r(JSContext * ctx,JSValue this_val){
		Color * ptr=(Color *)JS_GetOpaque2(ctx,this_val,js_Color_class_id);
		unsigned char r=ptr[0].r;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)r));
		return ret;
	}
	
	static JSValue js_Color_set_r(JSContext * ctx,JSValue this_val,JSValue v){
		Color * ptr=(Color *)JS_GetOpaque2(ctx,this_val,js_Color_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned char value=((unsigned char)long_value);
		ptr[0].r=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Color_get_g(JSContext * ctx,JSValue this_val){
		Color * ptr=(Color *)JS_GetOpaque2(ctx,this_val,js_Color_class_id);
		unsigned char g=ptr[0].g;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)g));
		return ret;
	}
	
	static JSValue js_Color_set_g(JSContext * ctx,JSValue this_val,JSValue v){
		Color * ptr=(Color *)JS_GetOpaque2(ctx,this_val,js_Color_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned char value=((unsigned char)long_value);
		ptr[0].g=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Color_get_b(JSContext * ctx,JSValue this_val){
		Color * ptr=(Color *)JS_GetOpaque2(ctx,this_val,js_Color_class_id);
		unsigned char b=ptr[0].b;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)b));
		return ret;
	}
	
	static JSValue js_Color_set_b(JSContext * ctx,JSValue this_val,JSValue v){
		Color * ptr=(Color *)JS_GetOpaque2(ctx,this_val,js_Color_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned char value=((unsigned char)long_value);
		ptr[0].b=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Color_get_a(JSContext * ctx,JSValue this_val){
		Color * ptr=(Color *)JS_GetOpaque2(ctx,this_val,js_Color_class_id);
		unsigned char a=ptr[0].a;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)a));
		return ret;
	}
	
	static JSValue js_Color_set_a(JSContext * ctx,JSValue this_val,JSValue v){
		Color * ptr=(Color *)JS_GetOpaque2(ctx,this_val,js_Color_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned char value=((unsigned char)long_value);
		ptr[0].a=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Color_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Color", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("r",js_Color_get_r,js_Color_set_r),
		JS_CGETSET_DEF("g",js_Color_get_g,js_Color_set_g),
		JS_CGETSET_DEF("b",js_Color_get_b,js_Color_set_b),
		JS_CGETSET_DEF("a",js_Color_get_a,js_Color_set_a)
	};
	
	static int js_declare_Color(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Color_class_id);
		JSClassDef js_Color_def={ .class_name = "Color", .finalizer = js_Color_finalizer };
		JS_NewClass(rt,js_Color_class_id,(const JSClassDef *)&js_Color_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Color_proto_funcs,(int)countof(js_Color_proto_funcs));
		JS_SetClassProto(ctx,js_Color_class_id,proto);
		return 0;
	}
	
	static void js_Rectangle_finalizer(JSRuntime * rt,JSValue val){
		Rectangle * ptr=(Rectangle *)JS_GetOpaque(val,js_Rectangle_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Rectangle_get_x(JSContext * ctx,JSValue this_val){
		Rectangle * ptr=(Rectangle *)JS_GetOpaque2(ctx,this_val,js_Rectangle_class_id);
		float x=ptr[0].x;
		JSValue ret=JS_NewFloat64(ctx,((double)x));
		return ret;
	}
	
	static JSValue js_Rectangle_set_x(JSContext * ctx,JSValue this_val,JSValue v){
		Rectangle * ptr=(Rectangle *)JS_GetOpaque2(ctx,this_val,js_Rectangle_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].x=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Rectangle_get_y(JSContext * ctx,JSValue this_val){
		Rectangle * ptr=(Rectangle *)JS_GetOpaque2(ctx,this_val,js_Rectangle_class_id);
		float y=ptr[0].y;
		JSValue ret=JS_NewFloat64(ctx,((double)y));
		return ret;
	}
	
	static JSValue js_Rectangle_set_y(JSContext * ctx,JSValue this_val,JSValue v){
		Rectangle * ptr=(Rectangle *)JS_GetOpaque2(ctx,this_val,js_Rectangle_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].y=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Rectangle_get_width(JSContext * ctx,JSValue this_val){
		Rectangle * ptr=(Rectangle *)JS_GetOpaque2(ctx,this_val,js_Rectangle_class_id);
		float width=ptr[0].width;
		JSValue ret=JS_NewFloat64(ctx,((double)width));
		return ret;
	}
	
	static JSValue js_Rectangle_set_width(JSContext * ctx,JSValue this_val,JSValue v){
		Rectangle * ptr=(Rectangle *)JS_GetOpaque2(ctx,this_val,js_Rectangle_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].width=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Rectangle_get_height(JSContext * ctx,JSValue this_val){
		Rectangle * ptr=(Rectangle *)JS_GetOpaque2(ctx,this_val,js_Rectangle_class_id);
		float height=ptr[0].height;
		JSValue ret=JS_NewFloat64(ctx,((double)height));
		return ret;
	}
	
	static JSValue js_Rectangle_set_height(JSContext * ctx,JSValue this_val,JSValue v){
		Rectangle * ptr=(Rectangle *)JS_GetOpaque2(ctx,this_val,js_Rectangle_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].height=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Rectangle_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Rectangle", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("x",js_Rectangle_get_x,js_Rectangle_set_x),
		JS_CGETSET_DEF("y",js_Rectangle_get_y,js_Rectangle_set_y),
		JS_CGETSET_DEF("width",js_Rectangle_get_width,js_Rectangle_set_width),
		JS_CGETSET_DEF("height",js_Rectangle_get_height,js_Rectangle_set_height)
	};
	
	static int js_declare_Rectangle(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Rectangle_class_id);
		JSClassDef js_Rectangle_def={ .class_name = "Rectangle", .finalizer = js_Rectangle_finalizer };
		JS_NewClass(rt,js_Rectangle_class_id,(const JSClassDef *)&js_Rectangle_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Rectangle_proto_funcs,(int)countof(js_Rectangle_proto_funcs));
		JS_SetClassProto(ctx,js_Rectangle_class_id,proto);
		return 0;
	}
	
	static void js_Image_finalizer(JSRuntime * rt,JSValue val){
		Image * ptr=(Image *)JS_GetOpaque(val,js_Image_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Image_data_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Image * ptr=(Image *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<GetPixelDataSize(ptr[0].width,ptr[0].height,ptr[0].format);i++){
			JSValue js_ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)((unsigned char *)ptr[0].data)[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Image_data_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Image * ptr=(Image *)ptr_u;
		int length=GetPixelDataSize(ptr[0].width,ptr[0].height,ptr[0].format);
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Image_data_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Image * ptr=(Image *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)GetPixelDataSize(ptr[0].width,ptr[0].height,ptr[0].format)));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<GetPixelDataSize(ptr[0].width,ptr[0].height,ptr[0].format)){
				unsigned char * ptrcast=(unsigned char *)ptr[0].data;
				unsigned char src=ptrcast[property];
				JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Image_data_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Image * ptr=(Image *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			uint32_t long_ret;
			int err_ret=JS_ToUint32(ctx,&long_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			unsigned char ret=((unsigned char)long_ret);
			((unsigned char *)ptr[0].data)[property] =ret;
		}
		return true;
	}
	
	static int js_Image_data_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Image * ptr=(Image *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<GetPixelDataSize(ptr[0].width,ptr[0].height,ptr[0].format)){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Image_get_data(JSContext * ctx,JSValue this_val){
		Image * ptr=(Image *)JS_GetOpaque2(ctx,this_val,js_Image_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Image_data_values,.keys = js_Image_data_keys,.get = js_Image_data_get,.set = js_Image_data_set,.has = js_Image_data_has});
		return ret;
	}
	
	static JSValue js_Image_set_data(JSContext * ctx,JSValue this_val,JSValue v){
		Image * ptr=(Image *)JS_GetOpaque2(ctx,this_val,js_Image_class_id);
		void * value;
		int64_t size_value;
		if(JS_IsArrayBuffer(v)==1){
			void * js_value=(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =jsc_malloc(ctx,size_value*sizeof(void *));
			memcpy(value,(const void *)js_value,(size_t)size_value);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"v does not match type void *");
			return JS_EXCEPTION;
		}
		if(ptr[0].data!=NULL){
			jsc_free(ctx,ptr[0].data);
		}
		ptr[0].data =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Image_get_width(JSContext * ctx,JSValue this_val){
		Image * ptr=(Image *)JS_GetOpaque2(ctx,this_val,js_Image_class_id);
		int width=ptr[0].width;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)width));
		return ret;
	}
	
	static JSValue js_Image_set_width(JSContext * ctx,JSValue this_val,JSValue v){
		Image * ptr=(Image *)JS_GetOpaque2(ctx,this_val,js_Image_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].width=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Image_get_height(JSContext * ctx,JSValue this_val){
		Image * ptr=(Image *)JS_GetOpaque2(ctx,this_val,js_Image_class_id);
		int height=ptr[0].height;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)height));
		return ret;
	}
	
	static JSValue js_Image_set_height(JSContext * ctx,JSValue this_val,JSValue v){
		Image * ptr=(Image *)JS_GetOpaque2(ctx,this_val,js_Image_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].height=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Image_get_mipmaps(JSContext * ctx,JSValue this_val){
		Image * ptr=(Image *)JS_GetOpaque2(ctx,this_val,js_Image_class_id);
		int mipmaps=ptr[0].mipmaps;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)mipmaps));
		return ret;
	}
	
	static JSValue js_Image_set_mipmaps(JSContext * ctx,JSValue this_val,JSValue v){
		Image * ptr=(Image *)JS_GetOpaque2(ctx,this_val,js_Image_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].mipmaps=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Image_get_format(JSContext * ctx,JSValue this_val){
		Image * ptr=(Image *)JS_GetOpaque2(ctx,this_val,js_Image_class_id);
		int format=ptr[0].format;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)format));
		return ret;
	}
	
	static JSValue js_Image_set_format(JSContext * ctx,JSValue this_val,JSValue v){
		Image * ptr=(Image *)JS_GetOpaque2(ctx,this_val,js_Image_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].format=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Image_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Image", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("data",js_Image_get_data,js_Image_set_data),
		JS_CGETSET_DEF("width",js_Image_get_width,js_Image_set_width),
		JS_CGETSET_DEF("height",js_Image_get_height,js_Image_set_height),
		JS_CGETSET_DEF("mipmaps",js_Image_get_mipmaps,js_Image_set_mipmaps),
		JS_CGETSET_DEF("format",js_Image_get_format,js_Image_set_format)
	};
	
	static int js_declare_Image(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Image_class_id);
		JSClassDef js_Image_def={ .class_name = "Image", .finalizer = js_Image_finalizer };
		JS_NewClass(rt,js_Image_class_id,(const JSClassDef *)&js_Image_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Image_proto_funcs,(int)countof(js_Image_proto_funcs));
		JS_SetClassProto(ctx,js_Image_class_id,proto);
		return 0;
	}
	
	static void js_Texture_finalizer(JSRuntime * rt,JSValue val){
		Texture * ptr=(Texture *)JS_GetOpaque(val,js_Texture_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Texture_get_id(JSContext * ctx,JSValue this_val){
		Texture * ptr=(Texture *)JS_GetOpaque2(ctx,this_val,js_Texture_class_id);
		unsigned int id=ptr[0].id;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)id));
		return ret;
	}
	
	static JSValue js_Texture_set_id(JSContext * ctx,JSValue this_val,JSValue v){
		Texture * ptr=(Texture *)JS_GetOpaque2(ctx,this_val,js_Texture_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].id=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Texture_get_width(JSContext * ctx,JSValue this_val){
		Texture * ptr=(Texture *)JS_GetOpaque2(ctx,this_val,js_Texture_class_id);
		int width=ptr[0].width;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)width));
		return ret;
	}
	
	static JSValue js_Texture_set_width(JSContext * ctx,JSValue this_val,JSValue v){
		Texture * ptr=(Texture *)JS_GetOpaque2(ctx,this_val,js_Texture_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].width=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Texture_get_height(JSContext * ctx,JSValue this_val){
		Texture * ptr=(Texture *)JS_GetOpaque2(ctx,this_val,js_Texture_class_id);
		int height=ptr[0].height;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)height));
		return ret;
	}
	
	static JSValue js_Texture_set_height(JSContext * ctx,JSValue this_val,JSValue v){
		Texture * ptr=(Texture *)JS_GetOpaque2(ctx,this_val,js_Texture_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].height=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Texture_get_mipmaps(JSContext * ctx,JSValue this_val){
		Texture * ptr=(Texture *)JS_GetOpaque2(ctx,this_val,js_Texture_class_id);
		int mipmaps=ptr[0].mipmaps;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)mipmaps));
		return ret;
	}
	
	static JSValue js_Texture_set_mipmaps(JSContext * ctx,JSValue this_val,JSValue v){
		Texture * ptr=(Texture *)JS_GetOpaque2(ctx,this_val,js_Texture_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].mipmaps=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Texture_get_format(JSContext * ctx,JSValue this_val){
		Texture * ptr=(Texture *)JS_GetOpaque2(ctx,this_val,js_Texture_class_id);
		int format=ptr[0].format;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)format));
		return ret;
	}
	
	static JSValue js_Texture_set_format(JSContext * ctx,JSValue this_val,JSValue v){
		Texture * ptr=(Texture *)JS_GetOpaque2(ctx,this_val,js_Texture_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].format=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Texture_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Texture", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("id",js_Texture_get_id,js_Texture_set_id),
		JS_CGETSET_DEF("width",js_Texture_get_width,js_Texture_set_width),
		JS_CGETSET_DEF("height",js_Texture_get_height,js_Texture_set_height),
		JS_CGETSET_DEF("mipmaps",js_Texture_get_mipmaps,js_Texture_set_mipmaps),
		JS_CGETSET_DEF("format",js_Texture_get_format,js_Texture_set_format)
	};
	
	static int js_declare_Texture(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Texture_class_id);
		JSClassDef js_Texture_def={ .class_name = "Texture", .finalizer = js_Texture_finalizer };
		JS_NewClass(rt,js_Texture_class_id,(const JSClassDef *)&js_Texture_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Texture_proto_funcs,(int)countof(js_Texture_proto_funcs));
		JS_SetClassProto(ctx,js_Texture_class_id,proto);
		return 0;
	}
	
	static void js_RenderTexture_finalizer(JSRuntime * rt,JSValue val){
		RenderTexture * ptr=(RenderTexture *)JS_GetOpaque(val,js_RenderTexture_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_RenderTexture_get_id(JSContext * ctx,JSValue this_val){
		RenderTexture * ptr=(RenderTexture *)JS_GetOpaque2(ctx,this_val,js_RenderTexture_class_id);
		unsigned int id=ptr[0].id;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)id));
		return ret;
	}
	
	static JSValue js_RenderTexture_set_id(JSContext * ctx,JSValue this_val,JSValue v){
		RenderTexture * ptr=(RenderTexture *)JS_GetOpaque2(ctx,this_val,js_RenderTexture_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].id=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_RenderTexture_get_texture(JSContext * ctx,JSValue this_val){
		RenderTexture * ptr=(RenderTexture *)JS_GetOpaque2(ctx,this_val,js_RenderTexture_class_id);
		Texture texture=ptr[0].texture;
		Texture * ptr_ret=(Texture *)js_malloc(ctx,sizeof(Texture));
		ptr_ret[0]=texture;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Texture_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_RenderTexture_set_texture(JSContext * ctx,JSValue this_val,JSValue v){
		RenderTexture * ptr=(RenderTexture *)JS_GetOpaque2(ctx,this_val,js_RenderTexture_class_id);
		Texture * ptr_value=(Texture *)JS_GetOpaque(v,js_Texture_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Texture value=*ptr_value;
		ptr[0].texture=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_RenderTexture_get_depth(JSContext * ctx,JSValue this_val){
		RenderTexture * ptr=(RenderTexture *)JS_GetOpaque2(ctx,this_val,js_RenderTexture_class_id);
		Texture depth=ptr[0].depth;
		Texture * ptr_ret=(Texture *)js_malloc(ctx,sizeof(Texture));
		ptr_ret[0]=depth;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Texture_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_RenderTexture_set_depth(JSContext * ctx,JSValue this_val,JSValue v){
		RenderTexture * ptr=(RenderTexture *)JS_GetOpaque2(ctx,this_val,js_RenderTexture_class_id);
		Texture * ptr_value=(Texture *)JS_GetOpaque(v,js_Texture_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Texture value=*ptr_value;
		ptr[0].depth=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_RenderTexture_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","RenderTexture", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("id",js_RenderTexture_get_id,js_RenderTexture_set_id),
		JS_CGETSET_DEF("texture",js_RenderTexture_get_texture,js_RenderTexture_set_texture),
		JS_CGETSET_DEF("depth",js_RenderTexture_get_depth,js_RenderTexture_set_depth)
	};
	
	static int js_declare_RenderTexture(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_RenderTexture_class_id);
		JSClassDef js_RenderTexture_def={ .class_name = "RenderTexture", .finalizer = js_RenderTexture_finalizer };
		JS_NewClass(rt,js_RenderTexture_class_id,(const JSClassDef *)&js_RenderTexture_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_RenderTexture_proto_funcs,(int)countof(js_RenderTexture_proto_funcs));
		JS_SetClassProto(ctx,js_RenderTexture_class_id,proto);
		return 0;
	}
	
	static void js_NPatchInfo_finalizer(JSRuntime * rt,JSValue val){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque(val,js_NPatchInfo_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_NPatchInfo_get_source(JSContext * ctx,JSValue this_val){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque2(ctx,this_val,js_NPatchInfo_class_id);
		Rectangle source=ptr[0].source;
		Rectangle * ptr_ret=(Rectangle *)js_malloc(ctx,sizeof(Rectangle));
		ptr_ret[0]=source;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Rectangle_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_NPatchInfo_set_source(JSContext * ctx,JSValue this_val,JSValue v){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque2(ctx,this_val,js_NPatchInfo_class_id);
		Rectangle * ptr_value=(Rectangle *)JS_GetOpaque(v,js_Rectangle_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle value=*ptr_value;
		ptr[0].source=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_NPatchInfo_get_left(JSContext * ctx,JSValue this_val){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque2(ctx,this_val,js_NPatchInfo_class_id);
		int left=ptr[0].left;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)left));
		return ret;
	}
	
	static JSValue js_NPatchInfo_set_left(JSContext * ctx,JSValue this_val,JSValue v){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque2(ctx,this_val,js_NPatchInfo_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].left=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_NPatchInfo_get_top(JSContext * ctx,JSValue this_val){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque2(ctx,this_val,js_NPatchInfo_class_id);
		int top=ptr[0].top;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)top));
		return ret;
	}
	
	static JSValue js_NPatchInfo_set_top(JSContext * ctx,JSValue this_val,JSValue v){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque2(ctx,this_val,js_NPatchInfo_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].top=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_NPatchInfo_get_right(JSContext * ctx,JSValue this_val){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque2(ctx,this_val,js_NPatchInfo_class_id);
		int right=ptr[0].right;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)right));
		return ret;
	}
	
	static JSValue js_NPatchInfo_set_right(JSContext * ctx,JSValue this_val,JSValue v){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque2(ctx,this_val,js_NPatchInfo_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].right=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_NPatchInfo_get_bottom(JSContext * ctx,JSValue this_val){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque2(ctx,this_val,js_NPatchInfo_class_id);
		int bottom=ptr[0].bottom;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)bottom));
		return ret;
	}
	
	static JSValue js_NPatchInfo_set_bottom(JSContext * ctx,JSValue this_val,JSValue v){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque2(ctx,this_val,js_NPatchInfo_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].bottom=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_NPatchInfo_get_layout(JSContext * ctx,JSValue this_val){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque2(ctx,this_val,js_NPatchInfo_class_id);
		int layout=ptr[0].layout;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)layout));
		return ret;
	}
	
	static JSValue js_NPatchInfo_set_layout(JSContext * ctx,JSValue this_val,JSValue v){
		NPatchInfo * ptr=(NPatchInfo *)JS_GetOpaque2(ctx,this_val,js_NPatchInfo_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].layout=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_NPatchInfo_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","NPatchInfo", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("source",js_NPatchInfo_get_source,js_NPatchInfo_set_source),
		JS_CGETSET_DEF("left",js_NPatchInfo_get_left,js_NPatchInfo_set_left),
		JS_CGETSET_DEF("top",js_NPatchInfo_get_top,js_NPatchInfo_set_top),
		JS_CGETSET_DEF("right",js_NPatchInfo_get_right,js_NPatchInfo_set_right),
		JS_CGETSET_DEF("bottom",js_NPatchInfo_get_bottom,js_NPatchInfo_set_bottom),
		JS_CGETSET_DEF("layout",js_NPatchInfo_get_layout,js_NPatchInfo_set_layout)
	};
	
	static int js_declare_NPatchInfo(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_NPatchInfo_class_id);
		JSClassDef js_NPatchInfo_def={ .class_name = "NPatchInfo", .finalizer = js_NPatchInfo_finalizer };
		JS_NewClass(rt,js_NPatchInfo_class_id,(const JSClassDef *)&js_NPatchInfo_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_NPatchInfo_proto_funcs,(int)countof(js_NPatchInfo_proto_funcs));
		JS_SetClassProto(ctx,js_NPatchInfo_class_id,proto);
		return 0;
	}
	
	static void js_GlyphInfo_finalizer(JSRuntime * rt,JSValue val){
		GlyphInfo * ptr=(GlyphInfo *)JS_GetOpaque(val,js_GlyphInfo_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_GlyphInfo_get_value(JSContext * ctx,JSValue this_val){
		GlyphInfo * ptr=(GlyphInfo *)JS_GetOpaque2(ctx,this_val,js_GlyphInfo_class_id);
		int value=ptr[0].value;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)value));
		return ret;
	}
	
	static JSValue js_GlyphInfo_set_value(JSContext * ctx,JSValue this_val,JSValue v){
		GlyphInfo * ptr=(GlyphInfo *)JS_GetOpaque2(ctx,this_val,js_GlyphInfo_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].value=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_GlyphInfo_get_offsetX(JSContext * ctx,JSValue this_val){
		GlyphInfo * ptr=(GlyphInfo *)JS_GetOpaque2(ctx,this_val,js_GlyphInfo_class_id);
		int offsetX=ptr[0].offsetX;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)offsetX));
		return ret;
	}
	
	static JSValue js_GlyphInfo_set_offsetX(JSContext * ctx,JSValue this_val,JSValue v){
		GlyphInfo * ptr=(GlyphInfo *)JS_GetOpaque2(ctx,this_val,js_GlyphInfo_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].offsetX=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_GlyphInfo_get_offsetY(JSContext * ctx,JSValue this_val){
		GlyphInfo * ptr=(GlyphInfo *)JS_GetOpaque2(ctx,this_val,js_GlyphInfo_class_id);
		int offsetY=ptr[0].offsetY;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)offsetY));
		return ret;
	}
	
	static JSValue js_GlyphInfo_set_offsetY(JSContext * ctx,JSValue this_val,JSValue v){
		GlyphInfo * ptr=(GlyphInfo *)JS_GetOpaque2(ctx,this_val,js_GlyphInfo_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].offsetY=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_GlyphInfo_get_advanceX(JSContext * ctx,JSValue this_val){
		GlyphInfo * ptr=(GlyphInfo *)JS_GetOpaque2(ctx,this_val,js_GlyphInfo_class_id);
		int advanceX=ptr[0].advanceX;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)advanceX));
		return ret;
	}
	
	static JSValue js_GlyphInfo_set_advanceX(JSContext * ctx,JSValue this_val,JSValue v){
		GlyphInfo * ptr=(GlyphInfo *)JS_GetOpaque2(ctx,this_val,js_GlyphInfo_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].advanceX=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_GlyphInfo_get_image(JSContext * ctx,JSValue this_val){
		GlyphInfo * ptr=(GlyphInfo *)JS_GetOpaque2(ctx,this_val,js_GlyphInfo_class_id);
		Image image=ptr[0].image;
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=image;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GlyphInfo_set_image(JSContext * ctx,JSValue this_val,JSValue v){
		GlyphInfo * ptr=(GlyphInfo *)JS_GetOpaque2(ctx,this_val,js_GlyphInfo_class_id);
		Image * ptr_value=(Image *)JS_GetOpaque(v,js_Image_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Image value=*ptr_value;
		ptr[0].image=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_GlyphInfo_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","GlyphInfo", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("value",js_GlyphInfo_get_value,js_GlyphInfo_set_value),
		JS_CGETSET_DEF("offsetX",js_GlyphInfo_get_offsetX,js_GlyphInfo_set_offsetX),
		JS_CGETSET_DEF("offsetY",js_GlyphInfo_get_offsetY,js_GlyphInfo_set_offsetY),
		JS_CGETSET_DEF("advanceX",js_GlyphInfo_get_advanceX,js_GlyphInfo_set_advanceX),
		JS_CGETSET_DEF("image",js_GlyphInfo_get_image,js_GlyphInfo_set_image)
	};
	
	static int js_declare_GlyphInfo(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_GlyphInfo_class_id);
		JSClassDef js_GlyphInfo_def={ .class_name = "GlyphInfo", .finalizer = js_GlyphInfo_finalizer };
		JS_NewClass(rt,js_GlyphInfo_class_id,(const JSClassDef *)&js_GlyphInfo_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_GlyphInfo_proto_funcs,(int)countof(js_GlyphInfo_proto_funcs));
		JS_SetClassProto(ctx,js_GlyphInfo_class_id,proto);
		return 0;
	}
	
	static void js_Font_finalizer(JSRuntime * rt,JSValue val){
		Font * ptr=(Font *)JS_GetOpaque(val,js_Font_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Font_get_baseSize(JSContext * ctx,JSValue this_val){
		Font * ptr=(Font *)JS_GetOpaque2(ctx,this_val,js_Font_class_id);
		int baseSize=ptr[0].baseSize;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)baseSize));
		return ret;
	}
	
	static JSValue js_Font_set_baseSize(JSContext * ctx,JSValue this_val,JSValue v){
		Font * ptr=(Font *)JS_GetOpaque2(ctx,this_val,js_Font_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].baseSize=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Font_get_glyphCount(JSContext * ctx,JSValue this_val){
		Font * ptr=(Font *)JS_GetOpaque2(ctx,this_val,js_Font_class_id);
		int glyphCount=ptr[0].glyphCount;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)glyphCount));
		return ret;
	}
	
	static JSValue js_Font_set_glyphCount(JSContext * ctx,JSValue this_val,JSValue v){
		Font * ptr=(Font *)JS_GetOpaque2(ctx,this_val,js_Font_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].glyphCount=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Font_get_glyphPadding(JSContext * ctx,JSValue this_val){
		Font * ptr=(Font *)JS_GetOpaque2(ctx,this_val,js_Font_class_id);
		int glyphPadding=ptr[0].glyphPadding;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)glyphPadding));
		return ret;
	}
	
	static JSValue js_Font_set_glyphPadding(JSContext * ctx,JSValue this_val,JSValue v){
		Font * ptr=(Font *)JS_GetOpaque2(ctx,this_val,js_Font_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].glyphPadding=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Font_get_texture(JSContext * ctx,JSValue this_val){
		Font * ptr=(Font *)JS_GetOpaque2(ctx,this_val,js_Font_class_id);
		Texture2D texture=ptr[0].texture;
		Texture2D * ptr_ret=(Texture2D *)js_malloc(ctx,sizeof(Texture2D));
		ptr_ret[0]=texture;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Texture_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Font_set_texture(JSContext * ctx,JSValue this_val,JSValue v){
		Font * ptr=(Font *)JS_GetOpaque2(ctx,this_val,js_Font_class_id);
		Texture2D * ptr_value=(Texture2D *)JS_GetOpaque(v,js_Texture_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D value=*ptr_value;
		ptr[0].texture=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Font_recs_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Font * ptr=(Font *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].glyphCount;i++){
			Rectangle * ptr_js_ret=(Rectangle *)js_malloc(ctx,sizeof(Rectangle));
			ptr_js_ret[0]=ptr[0].recs[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_Rectangle_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Font_recs_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Font * ptr=(Font *)ptr_u;
		int length=ptr[0].glyphCount;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Font_recs_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Font * ptr=(Font *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].glyphCount));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].glyphCount){
				Rectangle src=ptr[0].recs[property];
				Rectangle * ptr_ret=(Rectangle *)js_malloc(ctx,sizeof(Rectangle));
				ptr_ret[0]=src;
				JSValue ret=JS_NewObjectClass(ctx,(int)js_Rectangle_class_id);
				JS_SetOpaque(ret,(void *)ptr_ret);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Font_recs_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Font * ptr=(Font *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			Rectangle * ptr_ret=(Rectangle *)JS_GetOpaque(set_to,js_Rectangle_class_id);
			if(ptr_ret==NULL){
				JS_ThrowTypeError(ctx,(const char *)"set_to does not allow null");
				return -1;
			}
			Rectangle ret=*ptr_ret;
			ptr[0].recs[property] =ret;
		}
		return true;
	}
	
	static int js_Font_recs_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Font * ptr=(Font *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].glyphCount){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Font_get_recs(JSContext * ctx,JSValue this_val){
		Font * ptr=(Font *)JS_GetOpaque2(ctx,this_val,js_Font_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Font_recs_values,.keys = js_Font_recs_keys,.get = js_Font_recs_get,.set = js_Font_recs_set,.has = js_Font_recs_has});
		return ret;
	}
	
	static JSValue js_Font_set_recs(JSContext * ctx,JSValue this_val,JSValue v){
		Font * ptr=(Font *)JS_GetOpaque2(ctx,this_val,js_Font_class_id);
		Rectangle * value;
		bool freesrc_value=(bool)false;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(Rectangle *)jsc_malloc(ctx,size_value*sizeof(Rectangle));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				Rectangle * ptr_valuei=(Rectangle *)JS_GetOpaque(js_value,js_Rectangle_class_id);
				if(ptr_valuei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_value does not allow null");
					return JS_EXCEPTION;
				}
				value[i] =*ptr_valuei;
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			Rectangle * js_value=(Rectangle *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(Rectangle *)jsc_malloc(ctx,size_value*sizeof(Rectangle *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			if(freesrc_value){
				JS_FreeValue(ctx,v);
			}
			JS_ThrowTypeError(ctx,(const char *)"v does not match type Rectangle *");
			return JS_EXCEPTION;
		}
		if(ptr[0].recs!=NULL){
			jsc_free(ctx,(void *)ptr[0].recs);
		}
		ptr[0].recs =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Font_glyphs_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Font * ptr=(Font *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].glyphCount;i++){
			GlyphInfo * ptr_js_ret=(GlyphInfo *)js_malloc(ctx,sizeof(GlyphInfo));
			ptr_js_ret[0]=ptr[0].glyphs[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_GlyphInfo_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Font_glyphs_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Font * ptr=(Font *)ptr_u;
		int length=ptr[0].glyphCount;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Font_glyphs_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Font * ptr=(Font *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].glyphCount));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].glyphCount){
				GlyphInfo src=ptr[0].glyphs[property];
				GlyphInfo * ptr_ret=(GlyphInfo *)js_malloc(ctx,sizeof(GlyphInfo));
				ptr_ret[0]=src;
				JSValue ret=JS_NewObjectClass(ctx,(int)js_GlyphInfo_class_id);
				JS_SetOpaque(ret,(void *)ptr_ret);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Font_glyphs_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Font * ptr=(Font *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			GlyphInfo * ptr_ret=(GlyphInfo *)JS_GetOpaque(set_to,js_GlyphInfo_class_id);
			if(ptr_ret==NULL){
				JS_ThrowTypeError(ctx,(const char *)"set_to does not allow null");
				return -1;
			}
			GlyphInfo ret=*ptr_ret;
			ptr[0].glyphs[property] =ret;
		}
		return true;
	}
	
	static int js_Font_glyphs_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Font * ptr=(Font *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].glyphCount){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Font_get_glyphs(JSContext * ctx,JSValue this_val){
		Font * ptr=(Font *)JS_GetOpaque2(ctx,this_val,js_Font_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Font_glyphs_values,.keys = js_Font_glyphs_keys,.get = js_Font_glyphs_get,.set = js_Font_glyphs_set,.has = js_Font_glyphs_has});
		return ret;
	}
	
	static JSValue js_Font_set_glyphs(JSContext * ctx,JSValue this_val,JSValue v){
		Font * ptr=(Font *)JS_GetOpaque2(ctx,this_val,js_Font_class_id);
		GlyphInfo * value;
		bool freesrc_value=(bool)false;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(GlyphInfo *)jsc_malloc(ctx,size_value*sizeof(GlyphInfo));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				GlyphInfo * ptr_valuei=(GlyphInfo *)JS_GetOpaque(js_value,js_GlyphInfo_class_id);
				if(ptr_valuei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_value does not allow null");
					return JS_EXCEPTION;
				}
				value[i] =*ptr_valuei;
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			GlyphInfo * js_value=(GlyphInfo *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(GlyphInfo *)jsc_malloc(ctx,size_value*sizeof(GlyphInfo *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			if(freesrc_value){
				JS_FreeValue(ctx,v);
			}
			JS_ThrowTypeError(ctx,(const char *)"v does not match type GlyphInfo *");
			return JS_EXCEPTION;
		}
		if(ptr[0].glyphs!=NULL){
			jsc_free(ctx,(void *)ptr[0].glyphs);
		}
		ptr[0].glyphs =value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Font_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Font", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("baseSize",js_Font_get_baseSize,js_Font_set_baseSize),
		JS_CGETSET_DEF("glyphCount",js_Font_get_glyphCount,js_Font_set_glyphCount),
		JS_CGETSET_DEF("glyphPadding",js_Font_get_glyphPadding,js_Font_set_glyphPadding),
		JS_CGETSET_DEF("texture",js_Font_get_texture,js_Font_set_texture),
		JS_CGETSET_DEF("recs",js_Font_get_recs,js_Font_set_recs),
		JS_CGETSET_DEF("glyphs",js_Font_get_glyphs,js_Font_set_glyphs)
	};
	
	static int js_declare_Font(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Font_class_id);
		JSClassDef js_Font_def={ .class_name = "Font", .finalizer = js_Font_finalizer };
		JS_NewClass(rt,js_Font_class_id,(const JSClassDef *)&js_Font_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Font_proto_funcs,(int)countof(js_Font_proto_funcs));
		JS_SetClassProto(ctx,js_Font_class_id,proto);
		return 0;
	}
	
	static void js_Camera3D_finalizer(JSRuntime * rt,JSValue val){
		Camera3D * ptr=(Camera3D *)JS_GetOpaque(val,js_Camera3D_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Camera3D_get_position(JSContext * ctx,JSValue this_val){
		Camera3D * ptr=(Camera3D *)JS_GetOpaque2(ctx,this_val,js_Camera3D_class_id);
		Vector3 position=ptr[0].position;
		Vector3 * ptr_ret=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr_ret[0]=position;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Camera3D_set_position(JSContext * ctx,JSValue this_val,JSValue v){
		Camera3D * ptr=(Camera3D *)JS_GetOpaque2(ctx,this_val,js_Camera3D_class_id);
		Vector3 * ptr_value=(Vector3 *)JS_GetOpaque(v,js_Vector3_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 value=*ptr_value;
		ptr[0].position=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Camera3D_get_target(JSContext * ctx,JSValue this_val){
		Camera3D * ptr=(Camera3D *)JS_GetOpaque2(ctx,this_val,js_Camera3D_class_id);
		Vector3 target=ptr[0].target;
		Vector3 * ptr_ret=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr_ret[0]=target;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Camera3D_set_target(JSContext * ctx,JSValue this_val,JSValue v){
		Camera3D * ptr=(Camera3D *)JS_GetOpaque2(ctx,this_val,js_Camera3D_class_id);
		Vector3 * ptr_value=(Vector3 *)JS_GetOpaque(v,js_Vector3_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 value=*ptr_value;
		ptr[0].target=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Camera3D_get_up(JSContext * ctx,JSValue this_val){
		Camera3D * ptr=(Camera3D *)JS_GetOpaque2(ctx,this_val,js_Camera3D_class_id);
		Vector3 up=ptr[0].up;
		Vector3 * ptr_ret=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr_ret[0]=up;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Camera3D_set_up(JSContext * ctx,JSValue this_val,JSValue v){
		Camera3D * ptr=(Camera3D *)JS_GetOpaque2(ctx,this_val,js_Camera3D_class_id);
		Vector3 * ptr_value=(Vector3 *)JS_GetOpaque(v,js_Vector3_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 value=*ptr_value;
		ptr[0].up=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Camera3D_get_fovy(JSContext * ctx,JSValue this_val){
		Camera3D * ptr=(Camera3D *)JS_GetOpaque2(ctx,this_val,js_Camera3D_class_id);
		float fovy=ptr[0].fovy;
		JSValue ret=JS_NewFloat64(ctx,((double)fovy));
		return ret;
	}
	
	static JSValue js_Camera3D_set_fovy(JSContext * ctx,JSValue this_val,JSValue v){
		Camera3D * ptr=(Camera3D *)JS_GetOpaque2(ctx,this_val,js_Camera3D_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].fovy=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Camera3D_get_projection(JSContext * ctx,JSValue this_val){
		Camera3D * ptr=(Camera3D *)JS_GetOpaque2(ctx,this_val,js_Camera3D_class_id);
		int projection=ptr[0].projection;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)projection));
		return ret;
	}
	
	static JSValue js_Camera3D_set_projection(JSContext * ctx,JSValue this_val,JSValue v){
		Camera3D * ptr=(Camera3D *)JS_GetOpaque2(ctx,this_val,js_Camera3D_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].projection=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Camera3D_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Camera3D", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("position",js_Camera3D_get_position,js_Camera3D_set_position),
		JS_CGETSET_DEF("target",js_Camera3D_get_target,js_Camera3D_set_target),
		JS_CGETSET_DEF("up",js_Camera3D_get_up,js_Camera3D_set_up),
		JS_CGETSET_DEF("fovy",js_Camera3D_get_fovy,js_Camera3D_set_fovy),
		JS_CGETSET_DEF("projection",js_Camera3D_get_projection,js_Camera3D_set_projection)
	};
	
	static int js_declare_Camera3D(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Camera3D_class_id);
		JSClassDef js_Camera3D_def={ .class_name = "Camera3D", .finalizer = js_Camera3D_finalizer };
		JS_NewClass(rt,js_Camera3D_class_id,(const JSClassDef *)&js_Camera3D_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Camera3D_proto_funcs,(int)countof(js_Camera3D_proto_funcs));
		JS_SetClassProto(ctx,js_Camera3D_class_id,proto);
		return 0;
	}
	
	static void js_Camera2D_finalizer(JSRuntime * rt,JSValue val){
		Camera2D * ptr=(Camera2D *)JS_GetOpaque(val,js_Camera2D_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Camera2D_get_offset(JSContext * ctx,JSValue this_val){
		Camera2D * ptr=(Camera2D *)JS_GetOpaque2(ctx,this_val,js_Camera2D_class_id);
		Vector2 offset=ptr[0].offset;
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=offset;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Camera2D_set_offset(JSContext * ctx,JSValue this_val,JSValue v){
		Camera2D * ptr=(Camera2D *)JS_GetOpaque2(ctx,this_val,js_Camera2D_class_id);
		Vector2 * ptr_value=(Vector2 *)JS_GetOpaque(v,js_Vector2_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 value=*ptr_value;
		ptr[0].offset=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Camera2D_get_target(JSContext * ctx,JSValue this_val){
		Camera2D * ptr=(Camera2D *)JS_GetOpaque2(ctx,this_val,js_Camera2D_class_id);
		Vector2 target=ptr[0].target;
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=target;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Camera2D_set_target(JSContext * ctx,JSValue this_val,JSValue v){
		Camera2D * ptr=(Camera2D *)JS_GetOpaque2(ctx,this_val,js_Camera2D_class_id);
		Vector2 * ptr_value=(Vector2 *)JS_GetOpaque(v,js_Vector2_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 value=*ptr_value;
		ptr[0].target=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Camera2D_get_rotation(JSContext * ctx,JSValue this_val){
		Camera2D * ptr=(Camera2D *)JS_GetOpaque2(ctx,this_val,js_Camera2D_class_id);
		float rotation=ptr[0].rotation;
		JSValue ret=JS_NewFloat64(ctx,((double)rotation));
		return ret;
	}
	
	static JSValue js_Camera2D_set_rotation(JSContext * ctx,JSValue this_val,JSValue v){
		Camera2D * ptr=(Camera2D *)JS_GetOpaque2(ctx,this_val,js_Camera2D_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].rotation=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Camera2D_get_zoom(JSContext * ctx,JSValue this_val){
		Camera2D * ptr=(Camera2D *)JS_GetOpaque2(ctx,this_val,js_Camera2D_class_id);
		float zoom=ptr[0].zoom;
		JSValue ret=JS_NewFloat64(ctx,((double)zoom));
		return ret;
	}
	
	static JSValue js_Camera2D_set_zoom(JSContext * ctx,JSValue this_val,JSValue v){
		Camera2D * ptr=(Camera2D *)JS_GetOpaque2(ctx,this_val,js_Camera2D_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].zoom=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Camera2D_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Camera2D", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("offset",js_Camera2D_get_offset,js_Camera2D_set_offset),
		JS_CGETSET_DEF("target",js_Camera2D_get_target,js_Camera2D_set_target),
		JS_CGETSET_DEF("rotation",js_Camera2D_get_rotation,js_Camera2D_set_rotation),
		JS_CGETSET_DEF("zoom",js_Camera2D_get_zoom,js_Camera2D_set_zoom)
	};
	
	static int js_declare_Camera2D(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Camera2D_class_id);
		JSClassDef js_Camera2D_def={ .class_name = "Camera2D", .finalizer = js_Camera2D_finalizer };
		JS_NewClass(rt,js_Camera2D_class_id,(const JSClassDef *)&js_Camera2D_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Camera2D_proto_funcs,(int)countof(js_Camera2D_proto_funcs));
		JS_SetClassProto(ctx,js_Camera2D_class_id,proto);
		return 0;
	}
	
	static void js_Mesh_finalizer(JSRuntime * rt,JSValue val){
		Mesh * ptr=(Mesh *)JS_GetOpaque(val,js_Mesh_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Mesh_get_vertexCount(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		int vertexCount=ptr[0].vertexCount;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)vertexCount));
		return ret;
	}
	
	static JSValue js_Mesh_set_vertexCount(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].vertexCount=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_get_triangleCount(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		int triangleCount=ptr[0].triangleCount;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)triangleCount));
		return ret;
	}
	
	static JSValue js_Mesh_set_triangleCount(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].triangleCount=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_vertices_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].vertexCount*3;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].vertices[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_vertices_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=(int)ptr[0].vertexCount*3;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_vertices_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)ptr[0].vertexCount*((long)3));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*3){
				float src=ptr[0].vertices[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_vertices_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].vertices[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_vertices_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*3){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_vertices(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_vertices_values,.keys = js_Mesh_vertices_keys,.get = js_Mesh_vertices_get,.set = js_Mesh_vertices_set,.has = js_Mesh_vertices_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_vertices(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].vertices!=NULL){
			jsc_free(ctx,(void *)ptr[0].vertices);
		}
		ptr[0].vertices =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_texcoords_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].vertexCount*2;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].texcoords[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_texcoords_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=(int)ptr[0].vertexCount*2;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_texcoords_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)ptr[0].vertexCount*((long)2));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*2){
				float src=ptr[0].texcoords[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_texcoords_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].texcoords[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_texcoords_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*2){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_texcoords(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_texcoords_values,.keys = js_Mesh_texcoords_keys,.get = js_Mesh_texcoords_get,.set = js_Mesh_texcoords_set,.has = js_Mesh_texcoords_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_texcoords(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].texcoords!=NULL){
			jsc_free(ctx,(void *)ptr[0].texcoords);
		}
		ptr[0].texcoords =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_texcoords2_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].vertexCount*2;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].texcoords2[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_texcoords2_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=(int)ptr[0].vertexCount*2;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_texcoords2_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)ptr[0].vertexCount*((long)2));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*2){
				float src=ptr[0].texcoords2[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_texcoords2_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].texcoords2[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_texcoords2_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*2){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_texcoords2(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_texcoords2_values,.keys = js_Mesh_texcoords2_keys,.get = js_Mesh_texcoords2_get,.set = js_Mesh_texcoords2_set,.has = js_Mesh_texcoords2_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_texcoords2(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].texcoords2!=NULL){
			jsc_free(ctx,(void *)ptr[0].texcoords2);
		}
		ptr[0].texcoords2 =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_normals_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].vertexCount*3;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].normals[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_normals_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=(int)ptr[0].vertexCount*3;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_normals_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)ptr[0].vertexCount*((long)3));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*3){
				float src=ptr[0].normals[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_normals_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].normals[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_normals_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*3){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_normals(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_normals_values,.keys = js_Mesh_normals_keys,.get = js_Mesh_normals_get,.set = js_Mesh_normals_set,.has = js_Mesh_normals_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_normals(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].normals!=NULL){
			jsc_free(ctx,(void *)ptr[0].normals);
		}
		ptr[0].normals =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_tangents_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].vertexCount*4;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].tangents[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_tangents_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=(int)ptr[0].vertexCount*4;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_tangents_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)ptr[0].vertexCount*((long)4));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*4){
				float src=ptr[0].tangents[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_tangents_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].tangents[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_tangents_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*4){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_tangents(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_tangents_values,.keys = js_Mesh_tangents_keys,.get = js_Mesh_tangents_get,.set = js_Mesh_tangents_set,.has = js_Mesh_tangents_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_tangents(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].tangents!=NULL){
			jsc_free(ctx,(void *)ptr[0].tangents);
		}
		ptr[0].tangents =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_colors_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].vertexCount*4;i++){
			JSValue js_ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)ptr[0].colors[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_colors_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=(int)ptr[0].vertexCount*4;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_colors_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)ptr[0].vertexCount*((long)4));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*4){
				unsigned char src=ptr[0].colors[property];
				JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_colors_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			uint32_t long_ret;
			int err_ret=JS_ToUint32(ctx,&long_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			unsigned char ret=((unsigned char)long_ret);
			ptr[0].colors[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_colors_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*4){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_colors(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_colors_values,.keys = js_Mesh_colors_keys,.get = js_Mesh_colors_get,.set = js_Mesh_colors_set,.has = js_Mesh_colors_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_colors(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		unsigned char * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(unsigned char *)jsc_malloc(ctx,size_value*sizeof(unsigned char));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				uint32_t long_valuei;
				int err_valuei=JS_ToUint32(ctx,&long_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((unsigned char)long_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			unsigned char * js_value=(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(unsigned char *)jsc_malloc(ctx,size_value*sizeof(unsigned char *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_UINT8_ARRAY||classid_value==JS_CLASS_UINT8C_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				unsigned char * js_value=(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(unsigned char *)jsc_malloc(ctx,size_value*sizeof(unsigned char *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].colors!=NULL){
			jsc_free(ctx,(void *)ptr[0].colors);
		}
		ptr[0].colors =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_indices_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].vertexCount;i++){
			JSValue js_ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)ptr[0].indices[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_indices_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=ptr[0].vertexCount;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_indices_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].vertexCount));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount){
				unsigned short src=ptr[0].indices[property];
				JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_indices_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			uint32_t long_ret;
			int err_ret=JS_ToUint32(ctx,&long_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			unsigned short ret=((unsigned short)long_ret);
			ptr[0].indices[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_indices_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_indices(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_indices_values,.keys = js_Mesh_indices_keys,.get = js_Mesh_indices_get,.set = js_Mesh_indices_set,.has = js_Mesh_indices_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_indices(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		unsigned short * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(unsigned short *)jsc_malloc(ctx,size_value*sizeof(unsigned short));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				uint32_t long_valuei;
				int err_valuei=JS_ToUint32(ctx,&long_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((unsigned short)long_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			unsigned short * js_value=(unsigned short *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(unsigned short *)jsc_malloc(ctx,size_value*sizeof(unsigned short *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_UINT16_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				unsigned short * js_value=(unsigned short *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(unsigned short *)jsc_malloc(ctx,size_value*sizeof(unsigned short *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type unsigned short *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].indices!=NULL){
			jsc_free(ctx,(void *)ptr[0].indices);
		}
		ptr[0].indices =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_animVertices_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].vertexCount*3;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].animVertices[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_animVertices_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=(int)ptr[0].vertexCount*3;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_animVertices_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)ptr[0].vertexCount*((long)3));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*3){
				float src=ptr[0].animVertices[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_animVertices_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].animVertices[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_animVertices_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*3){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_animVertices(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_animVertices_values,.keys = js_Mesh_animVertices_keys,.get = js_Mesh_animVertices_get,.set = js_Mesh_animVertices_set,.has = js_Mesh_animVertices_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_animVertices(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].animVertices!=NULL){
			jsc_free(ctx,(void *)ptr[0].animVertices);
		}
		ptr[0].animVertices =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_animNormals_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].vertexCount*3;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].animNormals[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_animNormals_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=(int)ptr[0].vertexCount*3;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_animNormals_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)ptr[0].vertexCount*((long)3));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*3){
				float src=ptr[0].animNormals[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_animNormals_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].animNormals[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_animNormals_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*3){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_animNormals(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_animNormals_values,.keys = js_Mesh_animNormals_keys,.get = js_Mesh_animNormals_get,.set = js_Mesh_animNormals_set,.has = js_Mesh_animNormals_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_animNormals(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].animNormals!=NULL){
			jsc_free(ctx,(void *)ptr[0].animNormals);
		}
		ptr[0].animNormals =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_boneIds_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].vertexCount*4;i++){
			JSValue js_ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)ptr[0].boneIds[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_boneIds_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=(int)ptr[0].vertexCount*4;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_boneIds_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)ptr[0].vertexCount*((long)4));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*4){
				unsigned char src=ptr[0].boneIds[property];
				JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_boneIds_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			uint32_t long_ret;
			int err_ret=JS_ToUint32(ctx,&long_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			unsigned char ret=((unsigned char)long_ret);
			ptr[0].boneIds[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_boneIds_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*4){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_boneIds(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_boneIds_values,.keys = js_Mesh_boneIds_keys,.get = js_Mesh_boneIds_get,.set = js_Mesh_boneIds_set,.has = js_Mesh_boneIds_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_boneIds(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		unsigned char * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(unsigned char *)jsc_malloc(ctx,size_value*sizeof(unsigned char));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				uint32_t long_valuei;
				int err_valuei=JS_ToUint32(ctx,&long_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((unsigned char)long_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			unsigned char * js_value=(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(unsigned char *)jsc_malloc(ctx,size_value*sizeof(unsigned char *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_UINT8_ARRAY||classid_value==JS_CLASS_UINT8C_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				unsigned char * js_value=(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(unsigned char *)jsc_malloc(ctx,size_value*sizeof(unsigned char *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].boneIds!=NULL){
			jsc_free(ctx,(void *)ptr[0].boneIds);
		}
		ptr[0].boneIds =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_boneWeights_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].vertexCount*4;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].boneWeights[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_boneWeights_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=(int)ptr[0].vertexCount*4;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_boneWeights_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)ptr[0].vertexCount*((long)4));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*4){
				float src=ptr[0].boneWeights[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_boneWeights_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].boneWeights[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_boneWeights_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].vertexCount*4){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_boneWeights(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_boneWeights_values,.keys = js_Mesh_boneWeights_keys,.get = js_Mesh_boneWeights_get,.set = js_Mesh_boneWeights_set,.has = js_Mesh_boneWeights_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_boneWeights(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].boneWeights!=NULL){
			jsc_free(ctx,(void *)ptr[0].boneWeights);
		}
		ptr[0].boneWeights =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_boneMatrices_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].boneCount;i++){
			Matrix * ptr_js_ret=(Matrix *)js_malloc(ctx,sizeof(Matrix));
			ptr_js_ret[0]=ptr[0].boneMatrices[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_Matrix_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_boneMatrices_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=ptr[0].boneCount;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_boneMatrices_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].boneCount));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].boneCount){
				Matrix src=ptr[0].boneMatrices[property];
				Matrix * ptr_ret=(Matrix *)js_malloc(ctx,sizeof(Matrix));
				ptr_ret[0]=src;
				JSValue ret=JS_NewObjectClass(ctx,(int)js_Matrix_class_id);
				JS_SetOpaque(ret,(void *)ptr_ret);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_boneMatrices_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			Matrix * ptr_ret=(Matrix *)JS_GetOpaque(set_to,js_Matrix_class_id);
			if(ptr_ret==NULL){
				JS_ThrowTypeError(ctx,(const char *)"set_to does not allow null");
				return -1;
			}
			Matrix ret=*ptr_ret;
			ptr[0].boneMatrices[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_boneMatrices_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].boneCount){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_boneMatrices(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_boneMatrices_values,.keys = js_Mesh_boneMatrices_keys,.get = js_Mesh_boneMatrices_get,.set = js_Mesh_boneMatrices_set,.has = js_Mesh_boneMatrices_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_boneMatrices(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		Matrix * value;
		bool freesrc_value=(bool)false;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(Matrix *)jsc_malloc(ctx,size_value*sizeof(Matrix));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				Matrix * ptr_valuei=(Matrix *)JS_GetOpaque(js_value,js_Matrix_class_id);
				if(ptr_valuei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_value does not allow null");
					return JS_EXCEPTION;
				}
				value[i] =*ptr_valuei;
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			Matrix * js_value=(Matrix *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(Matrix *)jsc_malloc(ctx,size_value*sizeof(Matrix *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			if(freesrc_value){
				JS_FreeValue(ctx,v);
			}
			JS_ThrowTypeError(ctx,(const char *)"v does not match type Matrix *");
			return JS_EXCEPTION;
		}
		if(ptr[0].boneMatrices!=NULL){
			jsc_free(ctx,(void *)ptr[0].boneMatrices);
		}
		ptr[0].boneMatrices =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_get_boneCount(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		int boneCount=ptr[0].boneCount;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)boneCount));
		return ret;
	}
	
	static JSValue js_Mesh_set_boneCount(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].boneCount=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_get_vaoId(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		unsigned int vaoId=ptr[0].vaoId;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)vaoId));
		return ret;
	}
	
	static JSValue js_Mesh_set_vaoId(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].vaoId=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Mesh_vboId_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<MAX_MESH_VERTEX_BUFFERS;i++){
			JSValue js_ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)ptr[0].vboId[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Mesh_vboId_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Mesh * ptr=(Mesh *)ptr_u;
		int length=MAX_MESH_VERTEX_BUFFERS;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Mesh_vboId_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)MAX_MESH_VERTEX_BUFFERS));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<MAX_MESH_VERTEX_BUFFERS){
				unsigned int src=ptr[0].vboId[property];
				JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Mesh_vboId_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			uint32_t long_ret;
			int err_ret=JS_ToUint32(ctx,&long_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			unsigned int ret=((unsigned int)long_ret);
			ptr[0].vboId[property] =ret;
		}
		return true;
	}
	
	static int js_Mesh_vboId_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Mesh * ptr=(Mesh *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<MAX_MESH_VERTEX_BUFFERS){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Mesh_get_vboId(JSContext * ctx,JSValue this_val){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Mesh_vboId_values,.keys = js_Mesh_vboId_keys,.get = js_Mesh_vboId_get,.set = js_Mesh_vboId_set,.has = js_Mesh_vboId_has});
		return ret;
	}
	
	static JSValue js_Mesh_set_vboId(JSContext * ctx,JSValue this_val,JSValue v){
		Mesh * ptr=(Mesh *)JS_GetOpaque2(ctx,this_val,js_Mesh_class_id);
		unsigned int * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(unsigned int *)jsc_malloc(ctx,size_value*sizeof(unsigned int));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				uint32_t long_valuei;
				int err_valuei=JS_ToUint32(ctx,&long_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((unsigned int)long_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			unsigned int * js_value=(unsigned int *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(unsigned int *)jsc_malloc(ctx,size_value*sizeof(unsigned int *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_UINT16_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				unsigned int * js_value=(unsigned int *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(unsigned int *)jsc_malloc(ctx,size_value*sizeof(unsigned int *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type unsigned int *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].vboId!=NULL){
			jsc_free(ctx,(void *)ptr[0].vboId);
		}
		ptr[0].vboId =value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Mesh_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Mesh", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("vertexCount",js_Mesh_get_vertexCount,js_Mesh_set_vertexCount),
		JS_CGETSET_DEF("triangleCount",js_Mesh_get_triangleCount,js_Mesh_set_triangleCount),
		JS_CGETSET_DEF("vertices",js_Mesh_get_vertices,js_Mesh_set_vertices),
		JS_CGETSET_DEF("texcoords",js_Mesh_get_texcoords,js_Mesh_set_texcoords),
		JS_CGETSET_DEF("texcoords2",js_Mesh_get_texcoords2,js_Mesh_set_texcoords2),
		JS_CGETSET_DEF("normals",js_Mesh_get_normals,js_Mesh_set_normals),
		JS_CGETSET_DEF("tangents",js_Mesh_get_tangents,js_Mesh_set_tangents),
		JS_CGETSET_DEF("colors",js_Mesh_get_colors,js_Mesh_set_colors),
		JS_CGETSET_DEF("indices",js_Mesh_get_indices,js_Mesh_set_indices),
		JS_CGETSET_DEF("animVertices",js_Mesh_get_animVertices,js_Mesh_set_animVertices),
		JS_CGETSET_DEF("animNormals",js_Mesh_get_animNormals,js_Mesh_set_animNormals),
		JS_CGETSET_DEF("boneIds",js_Mesh_get_boneIds,js_Mesh_set_boneIds),
		JS_CGETSET_DEF("boneWeights",js_Mesh_get_boneWeights,js_Mesh_set_boneWeights),
		JS_CGETSET_DEF("boneMatrices",js_Mesh_get_boneMatrices,js_Mesh_set_boneMatrices),
		JS_CGETSET_DEF("boneCount",js_Mesh_get_boneCount,js_Mesh_set_boneCount),
		JS_CGETSET_DEF("vaoId",js_Mesh_get_vaoId,js_Mesh_set_vaoId),
		JS_CGETSET_DEF("vboId",js_Mesh_get_vboId,js_Mesh_set_vboId)
	};
	
	static int js_declare_Mesh(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Mesh_class_id);
		JSClassDef js_Mesh_def={ .class_name = "Mesh", .finalizer = js_Mesh_finalizer };
		JS_NewClass(rt,js_Mesh_class_id,(const JSClassDef *)&js_Mesh_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Mesh_proto_funcs,(int)countof(js_Mesh_proto_funcs));
		JS_SetClassProto(ctx,js_Mesh_class_id,proto);
		return 0;
	}
	
	static void js_Shader_finalizer(JSRuntime * rt,JSValue val){
		Shader * ptr=(Shader *)JS_GetOpaque(val,js_Shader_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Shader_get_id(JSContext * ctx,JSValue this_val){
		Shader * ptr=(Shader *)JS_GetOpaque2(ctx,this_val,js_Shader_class_id);
		unsigned int id=ptr[0].id;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)id));
		return ret;
	}
	
	static JSValue js_Shader_set_id(JSContext * ctx,JSValue this_val,JSValue v){
		Shader * ptr=(Shader *)JS_GetOpaque2(ctx,this_val,js_Shader_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].id=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Shader_locs_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Shader * ptr=(Shader *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<RL_MAX_SHADER_LOCATIONS;i++){
			JSValue js_ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].locs[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Shader_locs_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Shader * ptr=(Shader *)ptr_u;
		int length=RL_MAX_SHADER_LOCATIONS;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Shader_locs_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Shader * ptr=(Shader *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)RL_MAX_SHADER_LOCATIONS));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<RL_MAX_SHADER_LOCATIONS){
				int src=ptr[0].locs[property];
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Shader_locs_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Shader * ptr=(Shader *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			int32_t long_ret;
			int err_ret=JS_ToInt32(ctx,&long_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			int ret=((int)long_ret);
			ptr[0].locs[property] =ret;
		}
		return true;
	}
	
	static int js_Shader_locs_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Shader * ptr=(Shader *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<RL_MAX_SHADER_LOCATIONS){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Shader_get_locs(JSContext * ctx,JSValue this_val){
		Shader * ptr=(Shader *)JS_GetOpaque2(ctx,this_val,js_Shader_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Shader_locs_values,.keys = js_Shader_locs_keys,.get = js_Shader_locs_get,.set = js_Shader_locs_set,.has = js_Shader_locs_has});
		return ret;
	}
	
	static JSValue js_Shader_set_locs(JSContext * ctx,JSValue this_val,JSValue v){
		Shader * ptr=(Shader *)JS_GetOpaque2(ctx,this_val,js_Shader_class_id);
		int * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(int *)jsc_malloc(ctx,size_value*sizeof(int));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				int32_t long_valuei;
				int err_valuei=JS_ToInt32(ctx,&long_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((int)long_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			int * js_value=(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(int *)jsc_malloc(ctx,size_value*sizeof(int *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_INT16_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				int * js_value=(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(int *)jsc_malloc(ctx,size_value*sizeof(int *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type int *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].locs!=NULL){
			jsc_free(ctx,(void *)ptr[0].locs);
		}
		ptr[0].locs =value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Shader_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Shader", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("id",js_Shader_get_id,js_Shader_set_id),
		JS_CGETSET_DEF("locs",js_Shader_get_locs,js_Shader_set_locs)
	};
	
	static int js_declare_Shader(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Shader_class_id);
		JSClassDef js_Shader_def={ .class_name = "Shader", .finalizer = js_Shader_finalizer };
		JS_NewClass(rt,js_Shader_class_id,(const JSClassDef *)&js_Shader_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Shader_proto_funcs,(int)countof(js_Shader_proto_funcs));
		JS_SetClassProto(ctx,js_Shader_class_id,proto);
		return 0;
	}
	
	static void js_MaterialMap_finalizer(JSRuntime * rt,JSValue val){
		MaterialMap * ptr=(MaterialMap *)JS_GetOpaque(val,js_MaterialMap_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_MaterialMap_get_texture(JSContext * ctx,JSValue this_val){
		MaterialMap * ptr=(MaterialMap *)JS_GetOpaque2(ctx,this_val,js_MaterialMap_class_id);
		Texture2D texture=ptr[0].texture;
		Texture2D * ptr_ret=(Texture2D *)js_malloc(ctx,sizeof(Texture2D));
		ptr_ret[0]=texture;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Texture_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_MaterialMap_set_texture(JSContext * ctx,JSValue this_val,JSValue v){
		MaterialMap * ptr=(MaterialMap *)JS_GetOpaque2(ctx,this_val,js_MaterialMap_class_id);
		Texture2D * ptr_value=(Texture2D *)JS_GetOpaque(v,js_Texture_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D value=*ptr_value;
		ptr[0].texture=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_MaterialMap_get_color(JSContext * ctx,JSValue this_val){
		MaterialMap * ptr=(MaterialMap *)JS_GetOpaque2(ctx,this_val,js_MaterialMap_class_id);
		Color color=ptr[0].color;
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=color;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_MaterialMap_set_color(JSContext * ctx,JSValue this_val,JSValue v){
		MaterialMap * ptr=(MaterialMap *)JS_GetOpaque2(ctx,this_val,js_MaterialMap_class_id);
		Color * ptr_value=(Color *)JS_GetOpaque(v,js_Color_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Color value=*ptr_value;
		ptr[0].color=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_MaterialMap_get_value(JSContext * ctx,JSValue this_val){
		MaterialMap * ptr=(MaterialMap *)JS_GetOpaque2(ctx,this_val,js_MaterialMap_class_id);
		float value=ptr[0].value;
		JSValue ret=JS_NewFloat64(ctx,((double)value));
		return ret;
	}
	
	static JSValue js_MaterialMap_set_value(JSContext * ctx,JSValue this_val,JSValue v){
		MaterialMap * ptr=(MaterialMap *)JS_GetOpaque2(ctx,this_val,js_MaterialMap_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].value=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_MaterialMap_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","MaterialMap", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("texture",js_MaterialMap_get_texture,js_MaterialMap_set_texture),
		JS_CGETSET_DEF("color",js_MaterialMap_get_color,js_MaterialMap_set_color),
		JS_CGETSET_DEF("value",js_MaterialMap_get_value,js_MaterialMap_set_value)
	};
	
	static int js_declare_MaterialMap(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_MaterialMap_class_id);
		JSClassDef js_MaterialMap_def={ .class_name = "MaterialMap", .finalizer = js_MaterialMap_finalizer };
		JS_NewClass(rt,js_MaterialMap_class_id,(const JSClassDef *)&js_MaterialMap_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_MaterialMap_proto_funcs,(int)countof(js_MaterialMap_proto_funcs));
		JS_SetClassProto(ctx,js_MaterialMap_class_id,proto);
		return 0;
	}
	
	static void js_Material_finalizer(JSRuntime * rt,JSValue val){
		Material * ptr=(Material *)JS_GetOpaque(val,js_Material_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Material_get_shader(JSContext * ctx,JSValue this_val){
		Material * ptr=(Material *)JS_GetOpaque2(ctx,this_val,js_Material_class_id);
		Shader shader=ptr[0].shader;
		Shader * ptr_ret=(Shader *)js_malloc(ctx,sizeof(Shader));
		ptr_ret[0]=shader;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Shader_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Material_set_shader(JSContext * ctx,JSValue this_val,JSValue v){
		Material * ptr=(Material *)JS_GetOpaque2(ctx,this_val,js_Material_class_id);
		Shader * ptr_value=(Shader *)JS_GetOpaque(v,js_Shader_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Shader value=*ptr_value;
		ptr[0].shader=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Material_maps_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Material * ptr=(Material *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		MaterialMap * ptr_js_ret0=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr_js_ret0[0]=ptr[0].maps[0];
		JSValue js_ret0=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(js_ret0,(void *)ptr_js_ret0);
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)0,js_ret0,JS_PROP_C_W_E);
		MaterialMap * ptr_js_ret1=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr_js_ret1[0]=ptr[0].maps[1];
		JSValue js_ret1=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(js_ret1,(void *)ptr_js_ret1);
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)1,js_ret1,JS_PROP_C_W_E);
		MaterialMap * ptr_js_ret2=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr_js_ret2[0]=ptr[0].maps[2];
		JSValue js_ret2=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(js_ret2,(void *)ptr_js_ret2);
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)2,js_ret2,JS_PROP_C_W_E);
		MaterialMap * ptr_js_ret3=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr_js_ret3[0]=ptr[0].maps[3];
		JSValue js_ret3=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(js_ret3,(void *)ptr_js_ret3);
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)3,js_ret3,JS_PROP_C_W_E);
		MaterialMap * ptr_js_ret4=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr_js_ret4[0]=ptr[0].maps[4];
		JSValue js_ret4=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(js_ret4,(void *)ptr_js_ret4);
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)4,js_ret4,JS_PROP_C_W_E);
		MaterialMap * ptr_js_ret5=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr_js_ret5[0]=ptr[0].maps[5];
		JSValue js_ret5=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(js_ret5,(void *)ptr_js_ret5);
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)5,js_ret5,JS_PROP_C_W_E);
		MaterialMap * ptr_js_ret6=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr_js_ret6[0]=ptr[0].maps[6];
		JSValue js_ret6=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(js_ret6,(void *)ptr_js_ret6);
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)6,js_ret6,JS_PROP_C_W_E);
		MaterialMap * ptr_js_ret7=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr_js_ret7[0]=ptr[0].maps[7];
		JSValue js_ret7=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(js_ret7,(void *)ptr_js_ret7);
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)7,js_ret7,JS_PROP_C_W_E);
		MaterialMap * ptr_js_ret8=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr_js_ret8[0]=ptr[0].maps[8];
		JSValue js_ret8=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(js_ret8,(void *)ptr_js_ret8);
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)8,js_ret8,JS_PROP_C_W_E);
		MaterialMap * ptr_js_ret9=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr_js_ret9[0]=ptr[0].maps[9];
		JSValue js_ret9=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(js_ret9,(void *)ptr_js_ret9);
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)9,js_ret9,JS_PROP_C_W_E);
		MaterialMap * ptr_js_ret10=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr_js_ret10[0]=ptr[0].maps[10];
		JSValue js_ret10=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(js_ret10,(void *)ptr_js_ret10);
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)10,js_ret10,JS_PROP_C_W_E);
		MaterialMap * ptr_js_ret11=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr_js_ret11[0]=ptr[0].maps[11];
		JSValue js_ret11=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(js_ret11,(void *)ptr_js_ret11);
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)11,js_ret11,JS_PROP_C_W_E);
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Material_maps_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Material * ptr=(Material *)ptr_u;
		int length=(int)12;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Material_maps_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Material * ptr=(Material *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)12));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<12){
				MaterialMap src=ptr[0].maps[property];
				MaterialMap * ptr_ret=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
				ptr_ret[0]=src;
				JSValue ret=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
				JS_SetOpaque(ret,(void *)ptr_ret);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Material_maps_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Material * ptr=(Material *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			MaterialMap * ptr_ret=(MaterialMap *)JS_GetOpaque(set_to,js_MaterialMap_class_id);
			if(ptr_ret==NULL){
				JS_ThrowTypeError(ctx,(const char *)"set_to does not allow null");
				return -1;
			}
			MaterialMap ret=*ptr_ret;
			ptr[0].maps[property] =ret;
		}
		return true;
	}
	
	static int js_Material_maps_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Material * ptr=(Material *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<12){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Material_get_maps(JSContext * ctx,JSValue this_val){
		Material * ptr=(Material *)JS_GetOpaque2(ctx,this_val,js_Material_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Material_maps_values,.keys = js_Material_maps_keys,.get = js_Material_maps_get,.set = js_Material_maps_set,.has = js_Material_maps_has});
		return ret;
	}
	
	static JSValue js_Material_set_maps(JSContext * ctx,JSValue this_val,JSValue v){
		Material * ptr=(Material *)JS_GetOpaque2(ctx,this_val,js_Material_class_id);
		MaterialMap * value;
		bool freesrc_value=(bool)false;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(MaterialMap *)jsc_malloc(ctx,size_value*sizeof(MaterialMap));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				MaterialMap * ptr_valuei=(MaterialMap *)JS_GetOpaque(js_value,js_MaterialMap_class_id);
				if(ptr_valuei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_value does not allow null");
					return JS_EXCEPTION;
				}
				value[i] =*ptr_valuei;
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			MaterialMap * js_value=(MaterialMap *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(MaterialMap *)jsc_malloc(ctx,size_value*sizeof(MaterialMap *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			if(freesrc_value){
				JS_FreeValue(ctx,v);
			}
			JS_ThrowTypeError(ctx,(const char *)"v does not match type MaterialMap *");
			return JS_EXCEPTION;
		}
		if(ptr[0].maps!=NULL){
			jsc_free(ctx,(void *)ptr[0].maps);
		}
		ptr[0].maps =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Material_params_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Material * ptr=(Material *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<4;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].params[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Material_params_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Material * ptr=(Material *)ptr_u;
		int length=(int)4;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Material_params_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Material * ptr=(Material *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)4));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<4){
				float src=ptr[0].params[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Material_params_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Material * ptr=(Material *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].params[property] =ret;
		}
		return true;
	}
	
	static int js_Material_params_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Material * ptr=(Material *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<4){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Material_get_params(JSContext * ctx,JSValue this_val){
		Material * ptr=(Material *)JS_GetOpaque2(ctx,this_val,js_Material_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Material_params_values,.keys = js_Material_params_keys,.get = js_Material_params_get,.set = js_Material_params_set,.has = js_Material_params_has});
		return ret;
	}
	
	static JSValue js_Material_set_params(JSContext * ctx,JSValue this_val,JSValue v){
		Material * ptr=(Material *)JS_GetOpaque2(ctx,this_val,js_Material_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			value =(float *)jsc_malloc(ctx,4*sizeof(float));
			int i;
			for(i=0;i<4;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		memcpy((void *)ptr[0].params,(const void *)value,4*sizeof(float));
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Material_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Material", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("shader",js_Material_get_shader,js_Material_set_shader),
		JS_CGETSET_DEF("maps",js_Material_get_maps,js_Material_set_maps),
		JS_CGETSET_DEF("params",js_Material_get_params,js_Material_set_params)
	};
	
	static int js_declare_Material(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Material_class_id);
		JSClassDef js_Material_def={ .class_name = "Material", .finalizer = js_Material_finalizer };
		JS_NewClass(rt,js_Material_class_id,(const JSClassDef *)&js_Material_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Material_proto_funcs,(int)countof(js_Material_proto_funcs));
		JS_SetClassProto(ctx,js_Material_class_id,proto);
		return 0;
	}
	
	static void js_Transform_finalizer(JSRuntime * rt,JSValue val){
		Transform * ptr=(Transform *)JS_GetOpaque(val,js_Transform_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Transform_get_translation(JSContext * ctx,JSValue this_val){
		Transform * ptr=(Transform *)JS_GetOpaque2(ctx,this_val,js_Transform_class_id);
		Vector3 translation=ptr[0].translation;
		Vector3 * ptr_ret=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr_ret[0]=translation;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Transform_set_translation(JSContext * ctx,JSValue this_val,JSValue v){
		Transform * ptr=(Transform *)JS_GetOpaque2(ctx,this_val,js_Transform_class_id);
		Vector3 * ptr_value=(Vector3 *)JS_GetOpaque(v,js_Vector3_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 value=*ptr_value;
		ptr[0].translation=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Transform_get_rotation(JSContext * ctx,JSValue this_val){
		Transform * ptr=(Transform *)JS_GetOpaque2(ctx,this_val,js_Transform_class_id);
		Quaternion rotation=ptr[0].rotation;
		Quaternion * ptr_ret=(Quaternion *)js_malloc(ctx,sizeof(Quaternion));
		ptr_ret[0]=rotation;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector4_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Transform_set_rotation(JSContext * ctx,JSValue this_val,JSValue v){
		Transform * ptr=(Transform *)JS_GetOpaque2(ctx,this_val,js_Transform_class_id);
		Quaternion * ptr_value=(Quaternion *)JS_GetOpaque(v,js_Vector4_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Quaternion value=*ptr_value;
		ptr[0].rotation=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Transform_get_scale(JSContext * ctx,JSValue this_val){
		Transform * ptr=(Transform *)JS_GetOpaque2(ctx,this_val,js_Transform_class_id);
		Vector3 scale=ptr[0].scale;
		Vector3 * ptr_ret=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr_ret[0]=scale;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Transform_set_scale(JSContext * ctx,JSValue this_val,JSValue v){
		Transform * ptr=(Transform *)JS_GetOpaque2(ctx,this_val,js_Transform_class_id);
		Vector3 * ptr_value=(Vector3 *)JS_GetOpaque(v,js_Vector3_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 value=*ptr_value;
		ptr[0].scale=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Transform_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Transform", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("translation",js_Transform_get_translation,js_Transform_set_translation),
		JS_CGETSET_DEF("rotation",js_Transform_get_rotation,js_Transform_set_rotation),
		JS_CGETSET_DEF("scale",js_Transform_get_scale,js_Transform_set_scale)
	};
	
	static int js_declare_Transform(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Transform_class_id);
		JSClassDef js_Transform_def={ .class_name = "Transform", .finalizer = js_Transform_finalizer };
		JS_NewClass(rt,js_Transform_class_id,(const JSClassDef *)&js_Transform_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Transform_proto_funcs,(int)countof(js_Transform_proto_funcs));
		JS_SetClassProto(ctx,js_Transform_class_id,proto);
		return 0;
	}
	
	static void js_BoneInfo_finalizer(JSRuntime * rt,JSValue val){
		BoneInfo * ptr=(BoneInfo *)JS_GetOpaque(val,js_BoneInfo_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_BoneInfo_name_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		BoneInfo * ptr=(BoneInfo *)ptr_u;
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)ptr[0].name);
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_BoneInfo_name_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		BoneInfo * ptr=(BoneInfo *)ptr_u;
		int length=(int)32;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_BoneInfo_name_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		BoneInfo * ptr=(BoneInfo *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)32));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<32){
				char src=ptr[0].name[property];
				JSValue ret=JS_NewStringLen(ctx,(const char *)&src,(size_t)1);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_BoneInfo_name_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		BoneInfo * ptr=(BoneInfo *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			char * js_ret=(char *)JS_ToCString(ctx,set_to);
			char ret=((char)js_ret[0]);
			JS_FreeCString(ctx,(const char *)js_ret);
			ptr[0].name[property] =ret;
		}
		return true;
	}
	
	static int js_BoneInfo_name_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		BoneInfo * ptr=(BoneInfo *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<32){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_BoneInfo_get_name(JSContext * ctx,JSValue this_val){
		BoneInfo * ptr=(BoneInfo *)JS_GetOpaque2(ctx,this_val,js_BoneInfo_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_BoneInfo_name_values,.keys = js_BoneInfo_name_keys,.get = js_BoneInfo_name_get,.set = js_BoneInfo_name_set,.has = js_BoneInfo_name_has});
		return ret;
	}
	
	static JSValue js_BoneInfo_set_name(JSContext * ctx,JSValue this_val,JSValue v){
		BoneInfo * ptr=(BoneInfo *)JS_GetOpaque2(ctx,this_val,js_BoneInfo_class_id);
		char * value;
		JSValue da_value;
		int64_t size_value;
		if(JS_IsString(v)==1){
			char * js_value=(char *)JS_ToCStringLen(ctx,(size_t *)&size_value,v);
			value =(char *)jsc_malloc(ctx,size_value*sizeof(char *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
			JS_FreeCString(ctx,(const char *)value);
		}else if(JS_IsArrayBuffer(v)==1){
			char * js_value=(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(char *)jsc_malloc(ctx,size_value*sizeof(char *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_INT8_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				char * js_value=(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(char *)jsc_malloc(ctx,size_value*sizeof(char *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				JS_ThrowTypeError(ctx,(const char *)"v does not match type char *");
				return JS_EXCEPTION;
			}
		}
		memcpy((void *)ptr[0].name,(const void *)value,32*sizeof(char));
		return JS_UNDEFINED;
	}
	
	static JSValue js_BoneInfo_get_parent(JSContext * ctx,JSValue this_val){
		BoneInfo * ptr=(BoneInfo *)JS_GetOpaque2(ctx,this_val,js_BoneInfo_class_id);
		int parent=ptr[0].parent;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)parent));
		return ret;
	}
	
	static JSValue js_BoneInfo_set_parent(JSContext * ctx,JSValue this_val,JSValue v){
		BoneInfo * ptr=(BoneInfo *)JS_GetOpaque2(ctx,this_val,js_BoneInfo_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].parent=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_BoneInfo_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","BoneInfo", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("name",js_BoneInfo_get_name,js_BoneInfo_set_name),
		JS_CGETSET_DEF("parent",js_BoneInfo_get_parent,js_BoneInfo_set_parent)
	};
	
	static int js_declare_BoneInfo(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_BoneInfo_class_id);
		JSClassDef js_BoneInfo_def={ .class_name = "BoneInfo", .finalizer = js_BoneInfo_finalizer };
		JS_NewClass(rt,js_BoneInfo_class_id,(const JSClassDef *)&js_BoneInfo_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_BoneInfo_proto_funcs,(int)countof(js_BoneInfo_proto_funcs));
		JS_SetClassProto(ctx,js_BoneInfo_class_id,proto);
		return 0;
	}
	
	static void js_Model_finalizer(JSRuntime * rt,JSValue val){
		Model * ptr=(Model *)JS_GetOpaque(val,js_Model_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Model_get_transform(JSContext * ctx,JSValue this_val){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		Matrix transform=ptr[0].transform;
		Matrix * ptr_ret=(Matrix *)js_malloc(ctx,sizeof(Matrix));
		ptr_ret[0]=transform;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Matrix_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Model_set_transform(JSContext * ctx,JSValue this_val,JSValue v){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		Matrix * ptr_value=(Matrix *)JS_GetOpaque(v,js_Matrix_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Matrix value=*ptr_value;
		ptr[0].transform=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Model_get_meshCount(JSContext * ctx,JSValue this_val){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		int meshCount=ptr[0].meshCount;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)meshCount));
		return ret;
	}
	
	static JSValue js_Model_set_meshCount(JSContext * ctx,JSValue this_val,JSValue v){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].meshCount=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Model_get_materialCount(JSContext * ctx,JSValue this_val){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		int materialCount=ptr[0].materialCount;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)materialCount));
		return ret;
	}
	
	static JSValue js_Model_set_materialCount(JSContext * ctx,JSValue this_val,JSValue v){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].materialCount=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Model_meshes_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].meshCount;i++){
			Mesh * ptr_js_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
			ptr_js_ret[0]=ptr[0].meshes[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Model_meshes_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Model * ptr=(Model *)ptr_u;
		int length=ptr[0].meshCount;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Model_meshes_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].meshCount));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].meshCount){
				Mesh src=ptr[0].meshes[property];
				Mesh * ptr_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
				ptr_ret[0]=src;
				JSValue ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
				JS_SetOpaque(ret,(void *)ptr_ret);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Model_meshes_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			Mesh * ptr_ret=(Mesh *)JS_GetOpaque(set_to,js_Mesh_class_id);
			if(ptr_ret==NULL){
				JS_ThrowTypeError(ctx,(const char *)"set_to does not allow null");
				return -1;
			}
			Mesh ret=*ptr_ret;
			ptr[0].meshes[property] =ret;
		}
		return true;
	}
	
	static int js_Model_meshes_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].meshCount){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Model_get_meshes(JSContext * ctx,JSValue this_val){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Model_meshes_values,.keys = js_Model_meshes_keys,.get = js_Model_meshes_get,.set = js_Model_meshes_set,.has = js_Model_meshes_has});
		return ret;
	}
	
	static JSValue js_Model_set_meshes(JSContext * ctx,JSValue this_val,JSValue v){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		Mesh * value;
		bool freesrc_value=(bool)false;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(Mesh *)jsc_malloc(ctx,size_value*sizeof(Mesh));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				Mesh * ptr_valuei=(Mesh *)JS_GetOpaque(js_value,js_Mesh_class_id);
				if(ptr_valuei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_value does not allow null");
					return JS_EXCEPTION;
				}
				value[i] =*ptr_valuei;
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			Mesh * js_value=(Mesh *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(Mesh *)jsc_malloc(ctx,size_value*sizeof(Mesh *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			if(freesrc_value){
				JS_FreeValue(ctx,v);
			}
			JS_ThrowTypeError(ctx,(const char *)"v does not match type Mesh *");
			return JS_EXCEPTION;
		}
		if(ptr[0].meshes!=NULL){
			jsc_free(ctx,(void *)ptr[0].meshes);
		}
		ptr[0].meshes =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Model_materials_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].materialCount;i++){
			Material * ptr_js_ret=(Material *)js_malloc(ctx,sizeof(Material));
			ptr_js_ret[0]=ptr[0].materials[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_Material_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Model_materials_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Model * ptr=(Model *)ptr_u;
		int length=ptr[0].materialCount;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Model_materials_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].materialCount));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].materialCount){
				Material src=ptr[0].materials[property];
				Material * ptr_ret=(Material *)js_malloc(ctx,sizeof(Material));
				ptr_ret[0]=src;
				JSValue ret=JS_NewObjectClass(ctx,(int)js_Material_class_id);
				JS_SetOpaque(ret,(void *)ptr_ret);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Model_materials_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			Material * ptr_ret=(Material *)JS_GetOpaque(set_to,js_Material_class_id);
			if(ptr_ret==NULL){
				JS_ThrowTypeError(ctx,(const char *)"set_to does not allow null");
				return -1;
			}
			Material ret=*ptr_ret;
			ptr[0].materials[property] =ret;
		}
		return true;
	}
	
	static int js_Model_materials_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].materialCount){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Model_get_materials(JSContext * ctx,JSValue this_val){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Model_materials_values,.keys = js_Model_materials_keys,.get = js_Model_materials_get,.set = js_Model_materials_set,.has = js_Model_materials_has});
		return ret;
	}
	
	static JSValue js_Model_set_materials(JSContext * ctx,JSValue this_val,JSValue v){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		Material * value;
		bool freesrc_value=(bool)false;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(Material *)jsc_malloc(ctx,size_value*sizeof(Material));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				Material * ptr_valuei=(Material *)JS_GetOpaque(js_value,js_Material_class_id);
				if(ptr_valuei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_value does not allow null");
					return JS_EXCEPTION;
				}
				value[i] =*ptr_valuei;
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			Material * js_value=(Material *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(Material *)jsc_malloc(ctx,size_value*sizeof(Material *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			if(freesrc_value){
				JS_FreeValue(ctx,v);
			}
			JS_ThrowTypeError(ctx,(const char *)"v does not match type Material *");
			return JS_EXCEPTION;
		}
		if(ptr[0].materials!=NULL){
			jsc_free(ctx,(void *)ptr[0].materials);
		}
		ptr[0].materials =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Model_meshMaterial_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].meshCount;i++){
			JSValue js_ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].meshMaterial[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Model_meshMaterial_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Model * ptr=(Model *)ptr_u;
		int length=ptr[0].meshCount;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Model_meshMaterial_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].meshCount));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].meshCount){
				int src=ptr[0].meshMaterial[property];
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Model_meshMaterial_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			int32_t long_ret;
			int err_ret=JS_ToInt32(ctx,&long_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			int ret=((int)long_ret);
			ptr[0].meshMaterial[property] =ret;
		}
		return true;
	}
	
	static int js_Model_meshMaterial_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].meshCount){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Model_get_meshMaterial(JSContext * ctx,JSValue this_val){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Model_meshMaterial_values,.keys = js_Model_meshMaterial_keys,.get = js_Model_meshMaterial_get,.set = js_Model_meshMaterial_set,.has = js_Model_meshMaterial_has});
		return ret;
	}
	
	static JSValue js_Model_set_meshMaterial(JSContext * ctx,JSValue this_val,JSValue v){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		int * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(int *)jsc_malloc(ctx,size_value*sizeof(int));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				int32_t long_valuei;
				int err_valuei=JS_ToInt32(ctx,&long_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((int)long_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			int * js_value=(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(int *)jsc_malloc(ctx,size_value*sizeof(int *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_INT16_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				int * js_value=(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(int *)jsc_malloc(ctx,size_value*sizeof(int *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type int *");
				return JS_EXCEPTION;
			}
		}
		if(ptr[0].meshMaterial!=NULL){
			jsc_free(ctx,(void *)ptr[0].meshMaterial);
		}
		ptr[0].meshMaterial =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Model_get_boneCount(JSContext * ctx,JSValue this_val){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		int boneCount=ptr[0].boneCount;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)boneCount));
		return ret;
	}
	
	static JSValue js_Model_set_boneCount(JSContext * ctx,JSValue this_val,JSValue v){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].boneCount=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Model_bones_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].boneCount;i++){
			BoneInfo * ptr_js_ret=(BoneInfo *)js_malloc(ctx,sizeof(BoneInfo));
			ptr_js_ret[0]=ptr[0].bones[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_BoneInfo_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Model_bones_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Model * ptr=(Model *)ptr_u;
		int length=ptr[0].boneCount;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Model_bones_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].boneCount));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].boneCount){
				BoneInfo src=ptr[0].bones[property];
				BoneInfo * ptr_ret=(BoneInfo *)js_malloc(ctx,sizeof(BoneInfo));
				ptr_ret[0]=src;
				JSValue ret=JS_NewObjectClass(ctx,(int)js_BoneInfo_class_id);
				JS_SetOpaque(ret,(void *)ptr_ret);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Model_bones_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			BoneInfo * ptr_ret=(BoneInfo *)JS_GetOpaque(set_to,js_BoneInfo_class_id);
			if(ptr_ret==NULL){
				JS_ThrowTypeError(ctx,(const char *)"set_to does not allow null");
				return -1;
			}
			BoneInfo ret=*ptr_ret;
			ptr[0].bones[property] =ret;
		}
		return true;
	}
	
	static int js_Model_bones_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].boneCount){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Model_get_bones(JSContext * ctx,JSValue this_val){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Model_bones_values,.keys = js_Model_bones_keys,.get = js_Model_bones_get,.set = js_Model_bones_set,.has = js_Model_bones_has});
		return ret;
	}
	
	static JSValue js_Model_set_bones(JSContext * ctx,JSValue this_val,JSValue v){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		BoneInfo * value;
		bool freesrc_value=(bool)false;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(BoneInfo *)jsc_malloc(ctx,size_value*sizeof(BoneInfo));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				BoneInfo * ptr_valuei=(BoneInfo *)JS_GetOpaque(js_value,js_BoneInfo_class_id);
				if(ptr_valuei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_value does not allow null");
					return JS_EXCEPTION;
				}
				value[i] =*ptr_valuei;
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			BoneInfo * js_value=(BoneInfo *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(BoneInfo *)jsc_malloc(ctx,size_value*sizeof(BoneInfo *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			if(freesrc_value){
				JS_FreeValue(ctx,v);
			}
			JS_ThrowTypeError(ctx,(const char *)"v does not match type BoneInfo *");
			return JS_EXCEPTION;
		}
		if(ptr[0].bones!=NULL){
			jsc_free(ctx,(void *)ptr[0].bones);
		}
		ptr[0].bones =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Model_bindPose_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].boneCount;i++){
			Transform * ptr_js_ret=(Transform *)js_malloc(ctx,sizeof(Transform));
			ptr_js_ret[0]=ptr[0].bindPose[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_Transform_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Model_bindPose_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Model * ptr=(Model *)ptr_u;
		int length=ptr[0].boneCount;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Model_bindPose_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].boneCount));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].boneCount){
				Transform src=ptr[0].bindPose[property];
				Transform * ptr_ret=(Transform *)js_malloc(ctx,sizeof(Transform));
				ptr_ret[0]=src;
				JSValue ret=JS_NewObjectClass(ctx,(int)js_Transform_class_id);
				JS_SetOpaque(ret,(void *)ptr_ret);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Model_bindPose_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			Transform * ptr_ret=(Transform *)JS_GetOpaque(set_to,js_Transform_class_id);
			if(ptr_ret==NULL){
				JS_ThrowTypeError(ctx,(const char *)"set_to does not allow null");
				return -1;
			}
			Transform ret=*ptr_ret;
			ptr[0].bindPose[property] =ret;
		}
		return true;
	}
	
	static int js_Model_bindPose_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Model * ptr=(Model *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].boneCount){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Model_get_bindPose(JSContext * ctx,JSValue this_val){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Model_bindPose_values,.keys = js_Model_bindPose_keys,.get = js_Model_bindPose_get,.set = js_Model_bindPose_set,.has = js_Model_bindPose_has});
		return ret;
	}
	
	static JSValue js_Model_set_bindPose(JSContext * ctx,JSValue this_val,JSValue v){
		Model * ptr=(Model *)JS_GetOpaque2(ctx,this_val,js_Model_class_id);
		Transform * value;
		bool freesrc_value=(bool)false;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(Transform *)jsc_malloc(ctx,size_value*sizeof(Transform));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				Transform * ptr_valuei=(Transform *)JS_GetOpaque(js_value,js_Transform_class_id);
				if(ptr_valuei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_value does not allow null");
					return JS_EXCEPTION;
				}
				value[i] =*ptr_valuei;
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			Transform * js_value=(Transform *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(Transform *)jsc_malloc(ctx,size_value*sizeof(Transform *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			if(freesrc_value){
				JS_FreeValue(ctx,v);
			}
			JS_ThrowTypeError(ctx,(const char *)"v does not match type Transform *");
			return JS_EXCEPTION;
		}
		if(ptr[0].bindPose!=NULL){
			jsc_free(ctx,(void *)ptr[0].bindPose);
		}
		ptr[0].bindPose =value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Model_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Model", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("transform",js_Model_get_transform,js_Model_set_transform),
		JS_CGETSET_DEF("meshCount",js_Model_get_meshCount,js_Model_set_meshCount),
		JS_CGETSET_DEF("materialCount",js_Model_get_materialCount,js_Model_set_materialCount),
		JS_CGETSET_DEF("meshes",js_Model_get_meshes,js_Model_set_meshes),
		JS_CGETSET_DEF("materials",js_Model_get_materials,js_Model_set_materials),
		JS_CGETSET_DEF("meshMaterial",js_Model_get_meshMaterial,js_Model_set_meshMaterial),
		JS_CGETSET_DEF("boneCount",js_Model_get_boneCount,js_Model_set_boneCount),
		JS_CGETSET_DEF("bones",js_Model_get_bones,js_Model_set_bones),
		JS_CGETSET_DEF("bindPose",js_Model_get_bindPose,js_Model_set_bindPose)
	};
	
	static int js_declare_Model(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Model_class_id);
		JSClassDef js_Model_def={ .class_name = "Model", .finalizer = js_Model_finalizer };
		JS_NewClass(rt,js_Model_class_id,(const JSClassDef *)&js_Model_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Model_proto_funcs,(int)countof(js_Model_proto_funcs));
		JS_SetClassProto(ctx,js_Model_class_id,proto);
		return 0;
	}
	
	static void js_ModelAnimation_finalizer(JSRuntime * rt,JSValue val){
		ModelAnimation * ptr=(ModelAnimation *)JS_GetOpaque(val,js_ModelAnimation_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_ModelAnimation_get_boneCount(JSContext * ctx,JSValue this_val){
		ModelAnimation * ptr=(ModelAnimation *)JS_GetOpaque2(ctx,this_val,js_ModelAnimation_class_id);
		int boneCount=ptr[0].boneCount;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)boneCount));
		return ret;
	}
	
	static JSValue js_ModelAnimation_set_boneCount(JSContext * ctx,JSValue this_val,JSValue v){
		ModelAnimation * ptr=(ModelAnimation *)JS_GetOpaque2(ctx,this_val,js_ModelAnimation_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].boneCount=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_ModelAnimation_get_frameCount(JSContext * ctx,JSValue this_val){
		ModelAnimation * ptr=(ModelAnimation *)JS_GetOpaque2(ctx,this_val,js_ModelAnimation_class_id);
		int frameCount=ptr[0].frameCount;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)frameCount));
		return ret;
	}
	
	static JSValue js_ModelAnimation_set_frameCount(JSContext * ctx,JSValue this_val,JSValue v){
		ModelAnimation * ptr=(ModelAnimation *)JS_GetOpaque2(ctx,this_val,js_ModelAnimation_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].frameCount=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_ModelAnimation_bones_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].boneCount;i++){
			BoneInfo * ptr_js_ret=(BoneInfo *)js_malloc(ctx,sizeof(BoneInfo));
			ptr_js_ret[0]=ptr[0].bones[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_BoneInfo_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_ModelAnimation_bones_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		int length=ptr[0].boneCount;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_ModelAnimation_bones_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].boneCount));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].boneCount){
				BoneInfo src=ptr[0].bones[property];
				BoneInfo * ptr_ret=(BoneInfo *)js_malloc(ctx,sizeof(BoneInfo));
				ptr_ret[0]=src;
				JSValue ret=JS_NewObjectClass(ctx,(int)js_BoneInfo_class_id);
				JS_SetOpaque(ret,(void *)ptr_ret);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_ModelAnimation_bones_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			BoneInfo * ptr_ret=(BoneInfo *)JS_GetOpaque(set_to,js_BoneInfo_class_id);
			if(ptr_ret==NULL){
				JS_ThrowTypeError(ctx,(const char *)"set_to does not allow null");
				return -1;
			}
			BoneInfo ret=*ptr_ret;
			ptr[0].bones[property] =ret;
		}
		return true;
	}
	
	static int js_ModelAnimation_bones_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].boneCount){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_ModelAnimation_get_bones(JSContext * ctx,JSValue this_val){
		ModelAnimation * ptr=(ModelAnimation *)JS_GetOpaque2(ctx,this_val,js_ModelAnimation_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_ModelAnimation_bones_values,.keys = js_ModelAnimation_bones_keys,.get = js_ModelAnimation_bones_get,.set = js_ModelAnimation_bones_set,.has = js_ModelAnimation_bones_has});
		return ret;
	}
	
	static JSValue js_ModelAnimation_set_bones(JSContext * ctx,JSValue this_val,JSValue v){
		ModelAnimation * ptr=(ModelAnimation *)JS_GetOpaque2(ctx,this_val,js_ModelAnimation_class_id);
		BoneInfo * value;
		bool freesrc_value=(bool)false;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(BoneInfo *)jsc_malloc(ctx,size_value*sizeof(BoneInfo));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				BoneInfo * ptr_valuei=(BoneInfo *)JS_GetOpaque(js_value,js_BoneInfo_class_id);
				if(ptr_valuei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_value does not allow null");
					return JS_EXCEPTION;
				}
				value[i] =*ptr_valuei;
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			BoneInfo * js_value=(BoneInfo *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(BoneInfo *)jsc_malloc(ctx,size_value*sizeof(BoneInfo *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			if(freesrc_value){
				JS_FreeValue(ctx,v);
			}
			JS_ThrowTypeError(ctx,(const char *)"v does not match type BoneInfo *");
			return JS_EXCEPTION;
		}
		if(ptr[0].bones!=NULL){
			jsc_free(ctx,(void *)ptr[0].bones);
		}
		ptr[0].bones =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_ModelAnimation_framePoses_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].frameCount;i++){
			JSValue js_ret;
			js_ret =JS_NewArray(ctx);
			Transform * sizeref_js_ret=ptr[0].framePoses[i];
			size_t size_js_ret=sizeof(sizeref_js_ret);
			size_t size1_js_ret=sizeof(Transform);
			size_js_ret =size_js_ret/size1_js_ret;
			int i0;
			for(i0=0;i0<size_js_ret;i0++){
				Transform * ptr_js_js_ret=(Transform *)js_malloc(ctx,sizeof(Transform));
				ptr_js_js_ret[0]=ptr[0].framePoses[i][i0];
				JSValue js_js_ret=JS_NewObjectClass(ctx,(int)js_Transform_class_id);
				JS_SetOpaque(js_js_ret,(void *)ptr_js_js_ret);
				JS_DefinePropertyValueUint32(ctx,js_ret,(uint32_t)i0,js_js_ret,JS_PROP_C_W_E);
			}
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_ModelAnimation_framePoses_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		int length=ptr[0].frameCount;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_ModelAnimation_framePoses_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].frameCount));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].frameCount){
				Transform * src=ptr[0].framePoses[property];
				JSValue ret;
				ret =JS_NewArray(ctx);
				Transform * sizeref_ret=src;
				size_t size_ret=sizeof(sizeref_ret);
				size_t size1_ret=sizeof(Transform);
				size_ret =size_ret/size1_ret;
				int i;
				for(i=0;i<size_ret;i++){
					Transform * ptr_js_ret=(Transform *)js_malloc(ctx,sizeof(Transform));
					ptr_js_ret[0]=src[i];
					JSValue js_ret=JS_NewObjectClass(ctx,(int)js_Transform_class_id);
					JS_SetOpaque(js_ret,(void *)ptr_js_ret);
					JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
				}
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_ModelAnimation_framePoses_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			Transform * ret;
			bool freesrc_ret=(bool)false;
			int64_t size_ret;
			JSClassID ret_class=JS_GetClassID(set_to);
			if(ret_class==js_ArrayProxy_class_id){
				void * opaque_ret=JS_GetOpaque(set_to,js_ArrayProxy_class_id);
				ArrayProxy_class AP_ret=((ArrayProxy_class *)opaque_ret)[0];
				set_to =AP_ret.values(ctx,AP_ret.opaque,(int)0,(bool)false);
				freesrc_ret =(bool)true;
			}
			if(JS_IsArray(set_to)==1){
				if(JS_GetLength(ctx,set_to,&size_ret)==-1){
					return -1;
				}
				ret =(Transform *)js_malloc(ctx,size_ret*sizeof(Transform));
				int i;
				for(i=0;i<size_ret;i++){
					JSValue js_ret=JS_GetPropertyUint32(ctx,set_to,(uint32_t)i);
					Transform * ptr_reti=(Transform *)JS_GetOpaque(js_ret,js_Transform_class_id);
					if(ptr_reti==NULL){
						JS_ThrowTypeError(ctx,(const char *)"js_ret does not allow null");
						return -1;
					}
					ret[i] =*ptr_reti;
					JS_FreeValue(ctx,js_ret);
				}
			}else if(JS_IsArrayBuffer(set_to)==1){
				ret =(Transform *)JS_GetArrayBuffer(ctx,(size_t *)&size_ret,set_to);
			}else{
				if(freesrc_ret){
					JS_FreeValue(ctx,set_to);
				}
				JS_ThrowTypeError(ctx,(const char *)"set_to does not match type Transform *");
				return -1;
			}
			ptr[0].framePoses[property] =ret;
		}
		return true;
	}
	
	static int js_ModelAnimation_framePoses_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].frameCount){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_ModelAnimation_get_framePoses(JSContext * ctx,JSValue this_val){
		ModelAnimation * ptr=(ModelAnimation *)JS_GetOpaque2(ctx,this_val,js_ModelAnimation_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_ModelAnimation_framePoses_values,.keys = js_ModelAnimation_framePoses_keys,.get = js_ModelAnimation_framePoses_get,.set = js_ModelAnimation_framePoses_set,.has = js_ModelAnimation_framePoses_has});
		return ret;
	}
	
	static JSValue js_ModelAnimation_set_framePoses(JSContext * ctx,JSValue this_val,JSValue v){
		ModelAnimation * ptr=(ModelAnimation *)JS_GetOpaque2(ctx,this_val,js_ModelAnimation_class_id);
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		Transform * * value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&v);
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(Transform * *)jsc_malloc(ctx,size_value*sizeof(Transform *));
			memoryCurrent =memoryStore(memoryCurrent,jsc_free,(void *)*value);
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				int64_t size_valuei;
				JSClassID valuei_class=JS_GetClassID(js_value);
				if(valuei_class==js_ArrayProxy_class_id){
					void * opaque_valuei=JS_GetOpaque(js_value,js_ArrayProxy_class_id);
					ArrayProxy_class AP_valuei=((ArrayProxy_class *)opaque_valuei)[0];
					js_value =AP_valuei.values(ctx,AP_valuei.opaque,(int)0,(bool)false);
					memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&js_value);
				}
				if(JS_IsArray(js_value)==1){
					if(JS_GetLength(ctx,js_value,&size_valuei)==-1){
						return JS_EXCEPTION;
					}
					value[i] =(Transform *)js_malloc(ctx,size_valuei*sizeof(Transform));
					memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)value[i]);
					int i0;
					for(i0=0;i0<size_valuei;i0++){
						JSValue js_valuei=JS_GetPropertyUint32(ctx,js_value,(uint32_t)i0);
						Transform * ptr_valueii0=(Transform *)JS_GetOpaque(js_valuei,js_Transform_class_id);
						if(ptr_valueii0==NULL){
							JS_ThrowTypeError(ctx,(const char *)"js_valuei does not allow null");
							return JS_EXCEPTION;
						}
						value[i][i0] =*ptr_valueii0;
						JS_FreeValue(ctx,js_valuei);
					}
				}else if(JS_IsArrayBuffer(js_value)==1){
					value[i] =(Transform *)JS_GetArrayBuffer(ctx,(size_t *)&size_valuei,js_value);
				}else{
					JS_ThrowTypeError(ctx,(const char *)"js_value does not match type Transform *");
					return JS_EXCEPTION;
				}
				JS_FreeValue(ctx,js_value);
			}
		}else{
			JS_ThrowTypeError(ctx,(const char *)"v does not match type Transform * *");
			return JS_EXCEPTION;
		}
		if(ptr[0].framePoses!=NULL){
			jsc_free(ctx,(void *)*ptr[0].framePoses);
		}
		ptr[0].framePoses =value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_ModelAnimation_name_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)ptr[0].name);
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_ModelAnimation_name_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		int length=(int)32;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_ModelAnimation_name_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)32));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<32){
				char src=ptr[0].name[property];
				JSValue ret=JS_NewStringLen(ctx,(const char *)&src,(size_t)1);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_ModelAnimation_name_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			char * js_ret=(char *)JS_ToCString(ctx,set_to);
			char ret=((char)js_ret[0]);
			JS_FreeCString(ctx,(const char *)js_ret);
			ptr[0].name[property] =ret;
		}
		return true;
	}
	
	static int js_ModelAnimation_name_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		ModelAnimation * ptr=(ModelAnimation *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<32){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_ModelAnimation_get_name(JSContext * ctx,JSValue this_val){
		ModelAnimation * ptr=(ModelAnimation *)JS_GetOpaque2(ctx,this_val,js_ModelAnimation_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_ModelAnimation_name_values,.keys = js_ModelAnimation_name_keys,.get = js_ModelAnimation_name_get,.set = js_ModelAnimation_name_set,.has = js_ModelAnimation_name_has});
		return ret;
	}
	
	static JSValue js_ModelAnimation_set_name(JSContext * ctx,JSValue this_val,JSValue v){
		ModelAnimation * ptr=(ModelAnimation *)JS_GetOpaque2(ctx,this_val,js_ModelAnimation_class_id);
		char * value;
		JSValue da_value;
		int64_t size_value;
		if(JS_IsString(v)==1){
			char * js_value=(char *)JS_ToCStringLen(ctx,(size_t *)&size_value,v);
			value =(char *)jsc_malloc(ctx,size_value*sizeof(char *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
			JS_FreeCString(ctx,(const char *)value);
		}else if(JS_IsArrayBuffer(v)==1){
			char * js_value=(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(char *)jsc_malloc(ctx,size_value*sizeof(char *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_INT8_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				char * js_value=(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(char *)jsc_malloc(ctx,size_value*sizeof(char *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				JS_ThrowTypeError(ctx,(const char *)"v does not match type char *");
				return JS_EXCEPTION;
			}
		}
		memcpy((void *)ptr[0].name,(const void *)value,32*sizeof(char));
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_ModelAnimation_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","ModelAnimation", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("boneCount",js_ModelAnimation_get_boneCount,js_ModelAnimation_set_boneCount),
		JS_CGETSET_DEF("frameCount",js_ModelAnimation_get_frameCount,js_ModelAnimation_set_frameCount),
		JS_CGETSET_DEF("bones",js_ModelAnimation_get_bones,js_ModelAnimation_set_bones),
		JS_CGETSET_DEF("framePoses",js_ModelAnimation_get_framePoses,js_ModelAnimation_set_framePoses),
		JS_CGETSET_DEF("name",js_ModelAnimation_get_name,js_ModelAnimation_set_name)
	};
	
	static int js_declare_ModelAnimation(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_ModelAnimation_class_id);
		JSClassDef js_ModelAnimation_def={ .class_name = "ModelAnimation", .finalizer = js_ModelAnimation_finalizer };
		JS_NewClass(rt,js_ModelAnimation_class_id,(const JSClassDef *)&js_ModelAnimation_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_ModelAnimation_proto_funcs,(int)countof(js_ModelAnimation_proto_funcs));
		JS_SetClassProto(ctx,js_ModelAnimation_class_id,proto);
		return 0;
	}
	
	static void js_Ray_finalizer(JSRuntime * rt,JSValue val){
		Ray * ptr=(Ray *)JS_GetOpaque(val,js_Ray_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Ray_get_position(JSContext * ctx,JSValue this_val){
		Ray * ptr=(Ray *)JS_GetOpaque2(ctx,this_val,js_Ray_class_id);
		Vector3 position=ptr[0].position;
		Vector3 * ptr_ret=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr_ret[0]=position;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Ray_set_position(JSContext * ctx,JSValue this_val,JSValue v){
		Ray * ptr=(Ray *)JS_GetOpaque2(ctx,this_val,js_Ray_class_id);
		Vector3 * ptr_value=(Vector3 *)JS_GetOpaque(v,js_Vector3_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 value=*ptr_value;
		ptr[0].position=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Ray_get_direction(JSContext * ctx,JSValue this_val){
		Ray * ptr=(Ray *)JS_GetOpaque2(ctx,this_val,js_Ray_class_id);
		Vector3 direction=ptr[0].direction;
		Vector3 * ptr_ret=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr_ret[0]=direction;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Ray_set_direction(JSContext * ctx,JSValue this_val,JSValue v){
		Ray * ptr=(Ray *)JS_GetOpaque2(ctx,this_val,js_Ray_class_id);
		Vector3 * ptr_value=(Vector3 *)JS_GetOpaque(v,js_Vector3_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 value=*ptr_value;
		ptr[0].direction=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Ray_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Ray", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("position",js_Ray_get_position,js_Ray_set_position),
		JS_CGETSET_DEF("direction",js_Ray_get_direction,js_Ray_set_direction)
	};
	
	static int js_declare_Ray(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Ray_class_id);
		JSClassDef js_Ray_def={ .class_name = "Ray", .finalizer = js_Ray_finalizer };
		JS_NewClass(rt,js_Ray_class_id,(const JSClassDef *)&js_Ray_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Ray_proto_funcs,(int)countof(js_Ray_proto_funcs));
		JS_SetClassProto(ctx,js_Ray_class_id,proto);
		return 0;
	}
	
	static void js_RayCollision_finalizer(JSRuntime * rt,JSValue val){
		RayCollision * ptr=(RayCollision *)JS_GetOpaque(val,js_RayCollision_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_RayCollision_get_hit(JSContext * ctx,JSValue this_val){
		RayCollision * ptr=(RayCollision *)JS_GetOpaque2(ctx,this_val,js_RayCollision_class_id);
		bool hit=ptr[0].hit;
		JSValue ret=JS_NewBool(ctx,hit);
		return ret;
	}
	
	static JSValue js_RayCollision_set_hit(JSContext * ctx,JSValue this_val,JSValue v){
		RayCollision * ptr=(RayCollision *)JS_GetOpaque2(ctx,this_val,js_RayCollision_class_id);
		int js_value=JS_ToBool(ctx,v);
		if(js_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not a bool");
			return JS_EXCEPTION;
		}
		bool value=(bool)js_value;
		ptr[0].hit=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_RayCollision_get_distance(JSContext * ctx,JSValue this_val){
		RayCollision * ptr=(RayCollision *)JS_GetOpaque2(ctx,this_val,js_RayCollision_class_id);
		float distance=ptr[0].distance;
		JSValue ret=JS_NewFloat64(ctx,((double)distance));
		return ret;
	}
	
	static JSValue js_RayCollision_set_distance(JSContext * ctx,JSValue this_val,JSValue v){
		RayCollision * ptr=(RayCollision *)JS_GetOpaque2(ctx,this_val,js_RayCollision_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].distance=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_RayCollision_get_point(JSContext * ctx,JSValue this_val){
		RayCollision * ptr=(RayCollision *)JS_GetOpaque2(ctx,this_val,js_RayCollision_class_id);
		Vector3 point=ptr[0].point;
		Vector3 * ptr_ret=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr_ret[0]=point;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_RayCollision_set_point(JSContext * ctx,JSValue this_val,JSValue v){
		RayCollision * ptr=(RayCollision *)JS_GetOpaque2(ctx,this_val,js_RayCollision_class_id);
		Vector3 * ptr_value=(Vector3 *)JS_GetOpaque(v,js_Vector3_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 value=*ptr_value;
		ptr[0].point=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_RayCollision_get_normal(JSContext * ctx,JSValue this_val){
		RayCollision * ptr=(RayCollision *)JS_GetOpaque2(ctx,this_val,js_RayCollision_class_id);
		Vector3 normal=ptr[0].normal;
		Vector3 * ptr_ret=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr_ret[0]=normal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_RayCollision_set_normal(JSContext * ctx,JSValue this_val,JSValue v){
		RayCollision * ptr=(RayCollision *)JS_GetOpaque2(ctx,this_val,js_RayCollision_class_id);
		Vector3 * ptr_value=(Vector3 *)JS_GetOpaque(v,js_Vector3_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 value=*ptr_value;
		ptr[0].normal=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_RayCollision_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","RayCollision", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("hit",js_RayCollision_get_hit,js_RayCollision_set_hit),
		JS_CGETSET_DEF("distance",js_RayCollision_get_distance,js_RayCollision_set_distance),
		JS_CGETSET_DEF("point",js_RayCollision_get_point,js_RayCollision_set_point),
		JS_CGETSET_DEF("normal",js_RayCollision_get_normal,js_RayCollision_set_normal)
	};
	
	static int js_declare_RayCollision(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_RayCollision_class_id);
		JSClassDef js_RayCollision_def={ .class_name = "RayCollision", .finalizer = js_RayCollision_finalizer };
		JS_NewClass(rt,js_RayCollision_class_id,(const JSClassDef *)&js_RayCollision_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_RayCollision_proto_funcs,(int)countof(js_RayCollision_proto_funcs));
		JS_SetClassProto(ctx,js_RayCollision_class_id,proto);
		return 0;
	}
	
	static void js_BoundingBox_finalizer(JSRuntime * rt,JSValue val){
		BoundingBox * ptr=(BoundingBox *)JS_GetOpaque(val,js_BoundingBox_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_BoundingBox_get_min(JSContext * ctx,JSValue this_val){
		BoundingBox * ptr=(BoundingBox *)JS_GetOpaque2(ctx,this_val,js_BoundingBox_class_id);
		Vector3 min=ptr[0].min;
		Vector3 * ptr_ret=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr_ret[0]=min;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_BoundingBox_set_min(JSContext * ctx,JSValue this_val,JSValue v){
		BoundingBox * ptr=(BoundingBox *)JS_GetOpaque2(ctx,this_val,js_BoundingBox_class_id);
		Vector3 * ptr_value=(Vector3 *)JS_GetOpaque(v,js_Vector3_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 value=*ptr_value;
		ptr[0].min=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_BoundingBox_get_max(JSContext * ctx,JSValue this_val){
		BoundingBox * ptr=(BoundingBox *)JS_GetOpaque2(ctx,this_val,js_BoundingBox_class_id);
		Vector3 max=ptr[0].max;
		Vector3 * ptr_ret=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr_ret[0]=max;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_BoundingBox_set_max(JSContext * ctx,JSValue this_val,JSValue v){
		BoundingBox * ptr=(BoundingBox *)JS_GetOpaque2(ctx,this_val,js_BoundingBox_class_id);
		Vector3 * ptr_value=(Vector3 *)JS_GetOpaque(v,js_Vector3_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 value=*ptr_value;
		ptr[0].max=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_BoundingBox_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","BoundingBox", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("min",js_BoundingBox_get_min,js_BoundingBox_set_min),
		JS_CGETSET_DEF("max",js_BoundingBox_get_max,js_BoundingBox_set_max)
	};
	
	static int js_declare_BoundingBox(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_BoundingBox_class_id);
		JSClassDef js_BoundingBox_def={ .class_name = "BoundingBox", .finalizer = js_BoundingBox_finalizer };
		JS_NewClass(rt,js_BoundingBox_class_id,(const JSClassDef *)&js_BoundingBox_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_BoundingBox_proto_funcs,(int)countof(js_BoundingBox_proto_funcs));
		JS_SetClassProto(ctx,js_BoundingBox_class_id,proto);
		return 0;
	}
	
	static void js_Wave_finalizer(JSRuntime * rt,JSValue val){
		Wave * ptr=(Wave *)JS_GetOpaque(val,js_Wave_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Wave_get_frameCount(JSContext * ctx,JSValue this_val){
		Wave * ptr=(Wave *)JS_GetOpaque2(ctx,this_val,js_Wave_class_id);
		unsigned int frameCount=ptr[0].frameCount;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)frameCount));
		return ret;
	}
	
	static JSValue js_Wave_set_frameCount(JSContext * ctx,JSValue this_val,JSValue v){
		Wave * ptr=(Wave *)JS_GetOpaque2(ctx,this_val,js_Wave_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].frameCount=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Wave_get_sampleRate(JSContext * ctx,JSValue this_val){
		Wave * ptr=(Wave *)JS_GetOpaque2(ctx,this_val,js_Wave_class_id);
		unsigned int sampleRate=ptr[0].sampleRate;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)sampleRate));
		return ret;
	}
	
	static JSValue js_Wave_set_sampleRate(JSContext * ctx,JSValue this_val,JSValue v){
		Wave * ptr=(Wave *)JS_GetOpaque2(ctx,this_val,js_Wave_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].sampleRate=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Wave_get_sampleSize(JSContext * ctx,JSValue this_val){
		Wave * ptr=(Wave *)JS_GetOpaque2(ctx,this_val,js_Wave_class_id);
		unsigned int sampleSize=ptr[0].sampleSize;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)sampleSize));
		return ret;
	}
	
	static JSValue js_Wave_set_sampleSize(JSContext * ctx,JSValue this_val,JSValue v){
		Wave * ptr=(Wave *)JS_GetOpaque2(ctx,this_val,js_Wave_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].sampleSize=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Wave_get_channels(JSContext * ctx,JSValue this_val){
		Wave * ptr=(Wave *)JS_GetOpaque2(ctx,this_val,js_Wave_class_id);
		unsigned int channels=ptr[0].channels;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)channels));
		return ret;
	}
	
	static JSValue js_Wave_set_channels(JSContext * ctx,JSValue this_val,JSValue v){
		Wave * ptr=(Wave *)JS_GetOpaque2(ctx,this_val,js_Wave_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].channels=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Wave_data_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Wave * ptr=(Wave *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].frameCount*ptr[0].channels;i++){
			JSValue js_ret=JS_NewInt32(ctx,(int32_t)((long)((short *)ptr[0].data)[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_Wave_data_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		Wave * ptr=(Wave *)ptr_u;
		int length=ptr[0].frameCount*ptr[0].channels;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_Wave_data_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Wave * ptr=(Wave *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)ptr[0].frameCount*((long)ptr[0].channels));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].frameCount*ptr[0].channels){
				short * ptrcast=(short *)ptr[0].data;
				short src=ptrcast[property];
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_Wave_data_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		Wave * ptr=(Wave *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			int32_t long_ret;
			int err_ret=JS_ToInt32(ctx,&long_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			short ret=((short)long_ret);
			((short *)ptr[0].data)[property] =ret;
		}
		return true;
	}
	
	static int js_Wave_data_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		Wave * ptr=(Wave *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].frameCount*ptr[0].channels){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_Wave_get_data(JSContext * ctx,JSValue this_val){
		Wave * ptr=(Wave *)JS_GetOpaque2(ctx,this_val,js_Wave_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_Wave_data_values,.keys = js_Wave_data_keys,.get = js_Wave_data_get,.set = js_Wave_data_set,.has = js_Wave_data_has});
		return ret;
	}
	
	static JSValue js_Wave_set_data(JSContext * ctx,JSValue this_val,JSValue v){
		Wave * ptr=(Wave *)JS_GetOpaque2(ctx,this_val,js_Wave_class_id);
		void * value;
		int64_t size_value;
		if(JS_IsArrayBuffer(v)==1){
			void * js_value=(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =jsc_malloc(ctx,size_value*sizeof(void *));
			memcpy(value,(const void *)js_value,(size_t)size_value);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"v does not match type void *");
			return JS_EXCEPTION;
		}
		if(ptr[0].data!=NULL){
			jsc_free(ctx,ptr[0].data);
		}
		ptr[0].data =value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Wave_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Wave", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("frameCount",js_Wave_get_frameCount,js_Wave_set_frameCount),
		JS_CGETSET_DEF("sampleRate",js_Wave_get_sampleRate,js_Wave_set_sampleRate),
		JS_CGETSET_DEF("sampleSize",js_Wave_get_sampleSize,js_Wave_set_sampleSize),
		JS_CGETSET_DEF("channels",js_Wave_get_channels,js_Wave_set_channels),
		JS_CGETSET_DEF("data",js_Wave_get_data,js_Wave_set_data)
	};
	
	static int js_declare_Wave(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Wave_class_id);
		JSClassDef js_Wave_def={ .class_name = "Wave", .finalizer = js_Wave_finalizer };
		JS_NewClass(rt,js_Wave_class_id,(const JSClassDef *)&js_Wave_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Wave_proto_funcs,(int)countof(js_Wave_proto_funcs));
		JS_SetClassProto(ctx,js_Wave_class_id,proto);
		return 0;
	}
	
	static void js_rAudioBuffer_finalizer(JSRuntime * rt,JSValue val){
		rAudioBuffer * ptr=(rAudioBuffer *)JS_GetOpaque(val,js_rAudioBuffer_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	static const JSCFunctionListEntry js_rAudioBuffer_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","rAudioBuffer", JS_PROP_CONFIGURABLE)
	};
	
	static int js_declare_rAudioBuffer(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_rAudioBuffer_class_id);
		JSClassDef js_rAudioBuffer_def={ .class_name = "rAudioBuffer", .finalizer = js_rAudioBuffer_finalizer };
		JS_NewClass(rt,js_rAudioBuffer_class_id,(const JSClassDef *)&js_rAudioBuffer_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_rAudioBuffer_proto_funcs,(int)countof(js_rAudioBuffer_proto_funcs));
		JS_SetClassProto(ctx,js_rAudioBuffer_class_id,proto);
		return 0;
	}
	
	static void js_rAudioProcessor_finalizer(JSRuntime * rt,JSValue val){
		rAudioProcessor * ptr=(rAudioProcessor *)JS_GetOpaque(val,js_rAudioProcessor_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	static const JSCFunctionListEntry js_rAudioProcessor_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","rAudioProcessor", JS_PROP_CONFIGURABLE)
	};
	
	static int js_declare_rAudioProcessor(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_rAudioProcessor_class_id);
		JSClassDef js_rAudioProcessor_def={ .class_name = "rAudioProcessor", .finalizer = js_rAudioProcessor_finalizer };
		JS_NewClass(rt,js_rAudioProcessor_class_id,(const JSClassDef *)&js_rAudioProcessor_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_rAudioProcessor_proto_funcs,(int)countof(js_rAudioProcessor_proto_funcs));
		JS_SetClassProto(ctx,js_rAudioProcessor_class_id,proto);
		return 0;
	}
	
	static void js_AudioStream_finalizer(JSRuntime * rt,JSValue val){
		AudioStream * ptr=(AudioStream *)JS_GetOpaque(val,js_AudioStream_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_AudioStream_get_sampleRate(JSContext * ctx,JSValue this_val){
		AudioStream * ptr=(AudioStream *)JS_GetOpaque2(ctx,this_val,js_AudioStream_class_id);
		unsigned int sampleRate=ptr[0].sampleRate;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)sampleRate));
		return ret;
	}
	
	static JSValue js_AudioStream_set_sampleRate(JSContext * ctx,JSValue this_val,JSValue v){
		AudioStream * ptr=(AudioStream *)JS_GetOpaque2(ctx,this_val,js_AudioStream_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].sampleRate=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_AudioStream_get_sampleSize(JSContext * ctx,JSValue this_val){
		AudioStream * ptr=(AudioStream *)JS_GetOpaque2(ctx,this_val,js_AudioStream_class_id);
		unsigned int sampleSize=ptr[0].sampleSize;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)sampleSize));
		return ret;
	}
	
	static JSValue js_AudioStream_set_sampleSize(JSContext * ctx,JSValue this_val,JSValue v){
		AudioStream * ptr=(AudioStream *)JS_GetOpaque2(ctx,this_val,js_AudioStream_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].sampleSize=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_AudioStream_get_channels(JSContext * ctx,JSValue this_val){
		AudioStream * ptr=(AudioStream *)JS_GetOpaque2(ctx,this_val,js_AudioStream_class_id);
		unsigned int channels=ptr[0].channels;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)channels));
		return ret;
	}
	
	static JSValue js_AudioStream_set_channels(JSContext * ctx,JSValue this_val,JSValue v){
		AudioStream * ptr=(AudioStream *)JS_GetOpaque2(ctx,this_val,js_AudioStream_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].channels=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_AudioStream_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","AudioStream", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("buffer",NULL,NULL),
		JS_CGETSET_DEF("processor",NULL,NULL),
		JS_CGETSET_DEF("sampleRate",js_AudioStream_get_sampleRate,js_AudioStream_set_sampleRate),
		JS_CGETSET_DEF("sampleSize",js_AudioStream_get_sampleSize,js_AudioStream_set_sampleSize),
		JS_CGETSET_DEF("channels",js_AudioStream_get_channels,js_AudioStream_set_channels)
	};
	
	static int js_declare_AudioStream(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_AudioStream_class_id);
		JSClassDef js_AudioStream_def={ .class_name = "AudioStream", .finalizer = js_AudioStream_finalizer };
		JS_NewClass(rt,js_AudioStream_class_id,(const JSClassDef *)&js_AudioStream_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_AudioStream_proto_funcs,(int)countof(js_AudioStream_proto_funcs));
		JS_SetClassProto(ctx,js_AudioStream_class_id,proto);
		return 0;
	}
	
	static void js_Sound_finalizer(JSRuntime * rt,JSValue val){
		Sound * ptr=(Sound *)JS_GetOpaque(val,js_Sound_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Sound_get_stream(JSContext * ctx,JSValue this_val){
		Sound * ptr=(Sound *)JS_GetOpaque2(ctx,this_val,js_Sound_class_id);
		AudioStream stream=ptr[0].stream;
		AudioStream * ptr_ret=(AudioStream *)js_malloc(ctx,sizeof(AudioStream));
		ptr_ret[0]=stream;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_AudioStream_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Sound_set_stream(JSContext * ctx,JSValue this_val,JSValue v){
		Sound * ptr=(Sound *)JS_GetOpaque2(ctx,this_val,js_Sound_class_id);
		AudioStream * ptr_value=(AudioStream *)JS_GetOpaque(v,js_AudioStream_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream value=*ptr_value;
		ptr[0].stream=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Sound_get_frameCount(JSContext * ctx,JSValue this_val){
		Sound * ptr=(Sound *)JS_GetOpaque2(ctx,this_val,js_Sound_class_id);
		unsigned int frameCount=ptr[0].frameCount;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)frameCount));
		return ret;
	}
	
	static JSValue js_Sound_set_frameCount(JSContext * ctx,JSValue this_val,JSValue v){
		Sound * ptr=(Sound *)JS_GetOpaque2(ctx,this_val,js_Sound_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].frameCount=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Sound_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Sound", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("stream",js_Sound_get_stream,js_Sound_set_stream),
		JS_CGETSET_DEF("frameCount",js_Sound_get_frameCount,js_Sound_set_frameCount)
	};
	
	static int js_declare_Sound(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Sound_class_id);
		JSClassDef js_Sound_def={ .class_name = "Sound", .finalizer = js_Sound_finalizer };
		JS_NewClass(rt,js_Sound_class_id,(const JSClassDef *)&js_Sound_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Sound_proto_funcs,(int)countof(js_Sound_proto_funcs));
		JS_SetClassProto(ctx,js_Sound_class_id,proto);
		return 0;
	}
	
	static void js_Music_finalizer(JSRuntime * rt,JSValue val){
		Music * ptr=(Music *)JS_GetOpaque(val,js_Music_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_Music_get_stream(JSContext * ctx,JSValue this_val){
		Music * ptr=(Music *)JS_GetOpaque2(ctx,this_val,js_Music_class_id);
		AudioStream stream=ptr[0].stream;
		AudioStream * ptr_ret=(AudioStream *)js_malloc(ctx,sizeof(AudioStream));
		ptr_ret[0]=stream;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_AudioStream_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_Music_set_stream(JSContext * ctx,JSValue this_val,JSValue v){
		Music * ptr=(Music *)JS_GetOpaque2(ctx,this_val,js_Music_class_id);
		AudioStream * ptr_value=(AudioStream *)JS_GetOpaque(v,js_AudioStream_class_id);
		if(ptr_value==NULL){
			JS_ThrowTypeError(ctx,(const char *)"v does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream value=*ptr_value;
		ptr[0].stream=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Music_get_frameCount(JSContext * ctx,JSValue this_val){
		Music * ptr=(Music *)JS_GetOpaque2(ctx,this_val,js_Music_class_id);
		unsigned int frameCount=ptr[0].frameCount;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)frameCount));
		return ret;
	}
	
	static JSValue js_Music_set_frameCount(JSContext * ctx,JSValue this_val,JSValue v){
		Music * ptr=(Music *)JS_GetOpaque2(ctx,this_val,js_Music_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].frameCount=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Music_get_looping(JSContext * ctx,JSValue this_val){
		Music * ptr=(Music *)JS_GetOpaque2(ctx,this_val,js_Music_class_id);
		bool looping=ptr[0].looping;
		JSValue ret=JS_NewBool(ctx,looping);
		return ret;
	}
	
	static JSValue js_Music_set_looping(JSContext * ctx,JSValue this_val,JSValue v){
		Music * ptr=(Music *)JS_GetOpaque2(ctx,this_val,js_Music_class_id);
		int js_value=JS_ToBool(ctx,v);
		if(js_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not a bool");
			return JS_EXCEPTION;
		}
		bool value=(bool)js_value;
		ptr[0].looping=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_Music_get_ctxType(JSContext * ctx,JSValue this_val){
		Music * ptr=(Music *)JS_GetOpaque2(ctx,this_val,js_Music_class_id);
		int ctxType=ptr[0].ctxType;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ctxType));
		return ret;
	}
	
	static JSValue js_Music_set_ctxType(JSContext * ctx,JSValue this_val,JSValue v){
		Music * ptr=(Music *)JS_GetOpaque2(ctx,this_val,js_Music_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].ctxType=value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_Music_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","Music", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("stream",js_Music_get_stream,js_Music_set_stream),
		JS_CGETSET_DEF("frameCount",js_Music_get_frameCount,js_Music_set_frameCount),
		JS_CGETSET_DEF("looping",js_Music_get_looping,js_Music_set_looping),
		JS_CGETSET_DEF("ctxType",js_Music_get_ctxType,js_Music_set_ctxType),
		JS_CGETSET_DEF("ctxData",NULL,NULL)
	};
	
	static int js_declare_Music(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_Music_class_id);
		JSClassDef js_Music_def={ .class_name = "Music", .finalizer = js_Music_finalizer };
		JS_NewClass(rt,js_Music_class_id,(const JSClassDef *)&js_Music_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_Music_proto_funcs,(int)countof(js_Music_proto_funcs));
		JS_SetClassProto(ctx,js_Music_class_id,proto);
		return 0;
	}
	
	static void js_VrDeviceInfo_finalizer(JSRuntime * rt,JSValue val){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque(val,js_VrDeviceInfo_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_VrDeviceInfo_get_hResolution(JSContext * ctx,JSValue this_val){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		int hResolution=ptr[0].hResolution;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)hResolution));
		return ret;
	}
	
	static JSValue js_VrDeviceInfo_set_hResolution(JSContext * ctx,JSValue this_val,JSValue v){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].hResolution=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrDeviceInfo_get_vResolution(JSContext * ctx,JSValue this_val){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		int vResolution=ptr[0].vResolution;
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)vResolution));
		return ret;
	}
	
	static JSValue js_VrDeviceInfo_set_vResolution(JSContext * ctx,JSValue this_val,JSValue v){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		ptr[0].vResolution=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrDeviceInfo_get_hScreenSize(JSContext * ctx,JSValue this_val){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		float hScreenSize=ptr[0].hScreenSize;
		JSValue ret=JS_NewFloat64(ctx,((double)hScreenSize));
		return ret;
	}
	
	static JSValue js_VrDeviceInfo_set_hScreenSize(JSContext * ctx,JSValue this_val,JSValue v){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].hScreenSize=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrDeviceInfo_get_vScreenSize(JSContext * ctx,JSValue this_val){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		float vScreenSize=ptr[0].vScreenSize;
		JSValue ret=JS_NewFloat64(ctx,((double)vScreenSize));
		return ret;
	}
	
	static JSValue js_VrDeviceInfo_set_vScreenSize(JSContext * ctx,JSValue this_val,JSValue v){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].vScreenSize=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrDeviceInfo_get_eyeToScreenDistance(JSContext * ctx,JSValue this_val){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		float eyeToScreenDistance=ptr[0].eyeToScreenDistance;
		JSValue ret=JS_NewFloat64(ctx,((double)eyeToScreenDistance));
		return ret;
	}
	
	static JSValue js_VrDeviceInfo_set_eyeToScreenDistance(JSContext * ctx,JSValue this_val,JSValue v){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].eyeToScreenDistance=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrDeviceInfo_get_lensSeparationDistance(JSContext * ctx,JSValue this_val){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		float lensSeparationDistance=ptr[0].lensSeparationDistance;
		JSValue ret=JS_NewFloat64(ctx,((double)lensSeparationDistance));
		return ret;
	}
	
	static JSValue js_VrDeviceInfo_set_lensSeparationDistance(JSContext * ctx,JSValue this_val,JSValue v){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].lensSeparationDistance=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrDeviceInfo_get_interpupillaryDistance(JSContext * ctx,JSValue this_val){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		float interpupillaryDistance=ptr[0].interpupillaryDistance;
		JSValue ret=JS_NewFloat64(ctx,((double)interpupillaryDistance));
		return ret;
	}
	
	static JSValue js_VrDeviceInfo_set_interpupillaryDistance(JSContext * ctx,JSValue this_val,JSValue v){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		ptr[0].interpupillaryDistance=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrDeviceInfo_lensDistortionValues_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrDeviceInfo * ptr=(VrDeviceInfo *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<4;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].lensDistortionValues[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_VrDeviceInfo_lensDistortionValues_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		VrDeviceInfo * ptr=(VrDeviceInfo *)ptr_u;
		int length=(int)4;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_VrDeviceInfo_lensDistortionValues_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrDeviceInfo * ptr=(VrDeviceInfo *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)4));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<4){
				float src=ptr[0].lensDistortionValues[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_VrDeviceInfo_lensDistortionValues_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		VrDeviceInfo * ptr=(VrDeviceInfo *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].lensDistortionValues[property] =ret;
		}
		return true;
	}
	
	static int js_VrDeviceInfo_lensDistortionValues_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrDeviceInfo * ptr=(VrDeviceInfo *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<4){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_VrDeviceInfo_get_lensDistortionValues(JSContext * ctx,JSValue this_val){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_VrDeviceInfo_lensDistortionValues_values,.keys = js_VrDeviceInfo_lensDistortionValues_keys,.get = js_VrDeviceInfo_lensDistortionValues_get,.set = js_VrDeviceInfo_lensDistortionValues_set,.has = js_VrDeviceInfo_lensDistortionValues_has});
		return ret;
	}
	
	static JSValue js_VrDeviceInfo_set_lensDistortionValues(JSContext * ctx,JSValue this_val,JSValue v){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			value =(float *)jsc_malloc(ctx,4*sizeof(float));
			int i;
			for(i=0;i<4;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		memcpy((void *)ptr[0].lensDistortionValues,(const void *)value,4*sizeof(float));
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrDeviceInfo_chromaAbCorrection_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrDeviceInfo * ptr=(VrDeviceInfo *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<4;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].chromaAbCorrection[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_VrDeviceInfo_chromaAbCorrection_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		VrDeviceInfo * ptr=(VrDeviceInfo *)ptr_u;
		int length=(int)4;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_VrDeviceInfo_chromaAbCorrection_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrDeviceInfo * ptr=(VrDeviceInfo *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)4));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<4){
				float src=ptr[0].chromaAbCorrection[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_VrDeviceInfo_chromaAbCorrection_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		VrDeviceInfo * ptr=(VrDeviceInfo *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].chromaAbCorrection[property] =ret;
		}
		return true;
	}
	
	static int js_VrDeviceInfo_chromaAbCorrection_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrDeviceInfo * ptr=(VrDeviceInfo *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<4){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_VrDeviceInfo_get_chromaAbCorrection(JSContext * ctx,JSValue this_val){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_VrDeviceInfo_chromaAbCorrection_values,.keys = js_VrDeviceInfo_chromaAbCorrection_keys,.get = js_VrDeviceInfo_chromaAbCorrection_get,.set = js_VrDeviceInfo_chromaAbCorrection_set,.has = js_VrDeviceInfo_chromaAbCorrection_has});
		return ret;
	}
	
	static JSValue js_VrDeviceInfo_set_chromaAbCorrection(JSContext * ctx,JSValue this_val,JSValue v){
		VrDeviceInfo * ptr=(VrDeviceInfo *)JS_GetOpaque2(ctx,this_val,js_VrDeviceInfo_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			value =(float *)jsc_malloc(ctx,4*sizeof(float));
			int i;
			for(i=0;i<4;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		memcpy((void *)ptr[0].chromaAbCorrection,(const void *)value,4*sizeof(float));
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_VrDeviceInfo_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","VrDeviceInfo", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("hResolution",js_VrDeviceInfo_get_hResolution,js_VrDeviceInfo_set_hResolution),
		JS_CGETSET_DEF("vResolution",js_VrDeviceInfo_get_vResolution,js_VrDeviceInfo_set_vResolution),
		JS_CGETSET_DEF("hScreenSize",js_VrDeviceInfo_get_hScreenSize,js_VrDeviceInfo_set_hScreenSize),
		JS_CGETSET_DEF("vScreenSize",js_VrDeviceInfo_get_vScreenSize,js_VrDeviceInfo_set_vScreenSize),
		JS_CGETSET_DEF("eyeToScreenDistance",js_VrDeviceInfo_get_eyeToScreenDistance,js_VrDeviceInfo_set_eyeToScreenDistance),
		JS_CGETSET_DEF("lensSeparationDistance",js_VrDeviceInfo_get_lensSeparationDistance,js_VrDeviceInfo_set_lensSeparationDistance),
		JS_CGETSET_DEF("interpupillaryDistance",js_VrDeviceInfo_get_interpupillaryDistance,js_VrDeviceInfo_set_interpupillaryDistance),
		JS_CGETSET_DEF("lensDistortionValues",js_VrDeviceInfo_get_lensDistortionValues,js_VrDeviceInfo_set_lensDistortionValues),
		JS_CGETSET_DEF("chromaAbCorrection",js_VrDeviceInfo_get_chromaAbCorrection,js_VrDeviceInfo_set_chromaAbCorrection)
	};
	
	static int js_declare_VrDeviceInfo(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_VrDeviceInfo_class_id);
		JSClassDef js_VrDeviceInfo_def={ .class_name = "VrDeviceInfo", .finalizer = js_VrDeviceInfo_finalizer };
		JS_NewClass(rt,js_VrDeviceInfo_class_id,(const JSClassDef *)&js_VrDeviceInfo_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_VrDeviceInfo_proto_funcs,(int)countof(js_VrDeviceInfo_proto_funcs));
		JS_SetClassProto(ctx,js_VrDeviceInfo_class_id,proto);
		return 0;
	}
	
	static void js_VrStereoConfig_finalizer(JSRuntime * rt,JSValue val){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque(val,js_VrStereoConfig_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_VrStereoConfig_projection_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<2;i++){
			Matrix * ptr_js_ret=(Matrix *)js_malloc(ctx,sizeof(Matrix));
			ptr_js_ret[0]=ptr[0].projection[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_Matrix_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_VrStereoConfig_projection_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		int length=(int)2;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_VrStereoConfig_projection_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)2));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<2){
				Matrix src=ptr[0].projection[property];
				Matrix * ptr_ret=(Matrix *)js_malloc(ctx,sizeof(Matrix));
				ptr_ret[0]=src;
				JSValue ret=JS_NewObjectClass(ctx,(int)js_Matrix_class_id);
				JS_SetOpaque(ret,(void *)ptr_ret);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_VrStereoConfig_projection_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			Matrix * ptr_ret=(Matrix *)JS_GetOpaque(set_to,js_Matrix_class_id);
			if(ptr_ret==NULL){
				JS_ThrowTypeError(ctx,(const char *)"set_to does not allow null");
				return -1;
			}
			Matrix ret=*ptr_ret;
			ptr[0].projection[property] =ret;
		}
		return true;
	}
	
	static int js_VrStereoConfig_projection_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<2){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_VrStereoConfig_get_projection(JSContext * ctx,JSValue this_val){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_VrStereoConfig_projection_values,.keys = js_VrStereoConfig_projection_keys,.get = js_VrStereoConfig_projection_get,.set = js_VrStereoConfig_projection_set,.has = js_VrStereoConfig_projection_has});
		return ret;
	}
	
	static JSValue js_VrStereoConfig_set_projection(JSContext * ctx,JSValue this_val,JSValue v){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		Matrix * value;
		bool freesrc_value=(bool)false;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			value =(Matrix *)jsc_malloc(ctx,2*sizeof(Matrix));
			int i;
			for(i=0;i<2;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				Matrix * ptr_valuei=(Matrix *)JS_GetOpaque(js_value,js_Matrix_class_id);
				if(ptr_valuei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_value does not allow null");
					return JS_EXCEPTION;
				}
				value[i] =*ptr_valuei;
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			Matrix * js_value=(Matrix *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(Matrix *)jsc_malloc(ctx,size_value*sizeof(Matrix *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			if(freesrc_value){
				JS_FreeValue(ctx,v);
			}
			JS_ThrowTypeError(ctx,(const char *)"v does not match type Matrix *");
			return JS_EXCEPTION;
		}
		memcpy((void *)ptr[0].projection,(const void *)value,2*sizeof(Matrix));
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrStereoConfig_viewOffset_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<2;i++){
			Matrix * ptr_js_ret=(Matrix *)js_malloc(ctx,sizeof(Matrix));
			ptr_js_ret[0]=ptr[0].viewOffset[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_Matrix_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_VrStereoConfig_viewOffset_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		int length=(int)2;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_VrStereoConfig_viewOffset_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)2));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<2){
				Matrix src=ptr[0].viewOffset[property];
				Matrix * ptr_ret=(Matrix *)js_malloc(ctx,sizeof(Matrix));
				ptr_ret[0]=src;
				JSValue ret=JS_NewObjectClass(ctx,(int)js_Matrix_class_id);
				JS_SetOpaque(ret,(void *)ptr_ret);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_VrStereoConfig_viewOffset_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			Matrix * ptr_ret=(Matrix *)JS_GetOpaque(set_to,js_Matrix_class_id);
			if(ptr_ret==NULL){
				JS_ThrowTypeError(ctx,(const char *)"set_to does not allow null");
				return -1;
			}
			Matrix ret=*ptr_ret;
			ptr[0].viewOffset[property] =ret;
		}
		return true;
	}
	
	static int js_VrStereoConfig_viewOffset_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<2){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_VrStereoConfig_get_viewOffset(JSContext * ctx,JSValue this_val){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_VrStereoConfig_viewOffset_values,.keys = js_VrStereoConfig_viewOffset_keys,.get = js_VrStereoConfig_viewOffset_get,.set = js_VrStereoConfig_viewOffset_set,.has = js_VrStereoConfig_viewOffset_has});
		return ret;
	}
	
	static JSValue js_VrStereoConfig_set_viewOffset(JSContext * ctx,JSValue this_val,JSValue v){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		Matrix * value;
		bool freesrc_value=(bool)false;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			value =(Matrix *)jsc_malloc(ctx,2*sizeof(Matrix));
			int i;
			for(i=0;i<2;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				Matrix * ptr_valuei=(Matrix *)JS_GetOpaque(js_value,js_Matrix_class_id);
				if(ptr_valuei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_value does not allow null");
					return JS_EXCEPTION;
				}
				value[i] =*ptr_valuei;
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			Matrix * js_value=(Matrix *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(Matrix *)jsc_malloc(ctx,size_value*sizeof(Matrix *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			if(freesrc_value){
				JS_FreeValue(ctx,v);
			}
			JS_ThrowTypeError(ctx,(const char *)"v does not match type Matrix *");
			return JS_EXCEPTION;
		}
		memcpy((void *)ptr[0].viewOffset,(const void *)value,2*sizeof(Matrix));
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrStereoConfig_leftLensCenter_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<2;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].leftLensCenter[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_VrStereoConfig_leftLensCenter_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		int length=(int)2;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_VrStereoConfig_leftLensCenter_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)2));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<2){
				float src=ptr[0].leftLensCenter[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_VrStereoConfig_leftLensCenter_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].leftLensCenter[property] =ret;
		}
		return true;
	}
	
	static int js_VrStereoConfig_leftLensCenter_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<2){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_VrStereoConfig_get_leftLensCenter(JSContext * ctx,JSValue this_val){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_VrStereoConfig_leftLensCenter_values,.keys = js_VrStereoConfig_leftLensCenter_keys,.get = js_VrStereoConfig_leftLensCenter_get,.set = js_VrStereoConfig_leftLensCenter_set,.has = js_VrStereoConfig_leftLensCenter_has});
		return ret;
	}
	
	static JSValue js_VrStereoConfig_set_leftLensCenter(JSContext * ctx,JSValue this_val,JSValue v){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			value =(float *)jsc_malloc(ctx,2*sizeof(float));
			int i;
			for(i=0;i<2;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		memcpy((void *)ptr[0].leftLensCenter,(const void *)value,2*sizeof(float));
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrStereoConfig_rightLensCenter_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<2;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].rightLensCenter[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_VrStereoConfig_rightLensCenter_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		int length=(int)2;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_VrStereoConfig_rightLensCenter_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)2));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<2){
				float src=ptr[0].rightLensCenter[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_VrStereoConfig_rightLensCenter_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].rightLensCenter[property] =ret;
		}
		return true;
	}
	
	static int js_VrStereoConfig_rightLensCenter_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<2){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_VrStereoConfig_get_rightLensCenter(JSContext * ctx,JSValue this_val){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_VrStereoConfig_rightLensCenter_values,.keys = js_VrStereoConfig_rightLensCenter_keys,.get = js_VrStereoConfig_rightLensCenter_get,.set = js_VrStereoConfig_rightLensCenter_set,.has = js_VrStereoConfig_rightLensCenter_has});
		return ret;
	}
	
	static JSValue js_VrStereoConfig_set_rightLensCenter(JSContext * ctx,JSValue this_val,JSValue v){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			value =(float *)jsc_malloc(ctx,2*sizeof(float));
			int i;
			for(i=0;i<2;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		memcpy((void *)ptr[0].rightLensCenter,(const void *)value,2*sizeof(float));
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrStereoConfig_leftScreenCenter_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<2;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].leftScreenCenter[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_VrStereoConfig_leftScreenCenter_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		int length=(int)2;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_VrStereoConfig_leftScreenCenter_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)2));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<2){
				float src=ptr[0].leftScreenCenter[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_VrStereoConfig_leftScreenCenter_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].leftScreenCenter[property] =ret;
		}
		return true;
	}
	
	static int js_VrStereoConfig_leftScreenCenter_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<2){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_VrStereoConfig_get_leftScreenCenter(JSContext * ctx,JSValue this_val){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_VrStereoConfig_leftScreenCenter_values,.keys = js_VrStereoConfig_leftScreenCenter_keys,.get = js_VrStereoConfig_leftScreenCenter_get,.set = js_VrStereoConfig_leftScreenCenter_set,.has = js_VrStereoConfig_leftScreenCenter_has});
		return ret;
	}
	
	static JSValue js_VrStereoConfig_set_leftScreenCenter(JSContext * ctx,JSValue this_val,JSValue v){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			value =(float *)jsc_malloc(ctx,2*sizeof(float));
			int i;
			for(i=0;i<2;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		memcpy((void *)ptr[0].leftScreenCenter,(const void *)value,2*sizeof(float));
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrStereoConfig_rightScreenCenter_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<2;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].rightScreenCenter[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_VrStereoConfig_rightScreenCenter_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		int length=(int)2;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_VrStereoConfig_rightScreenCenter_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)2));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<2){
				float src=ptr[0].rightScreenCenter[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_VrStereoConfig_rightScreenCenter_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].rightScreenCenter[property] =ret;
		}
		return true;
	}
	
	static int js_VrStereoConfig_rightScreenCenter_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<2){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_VrStereoConfig_get_rightScreenCenter(JSContext * ctx,JSValue this_val){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_VrStereoConfig_rightScreenCenter_values,.keys = js_VrStereoConfig_rightScreenCenter_keys,.get = js_VrStereoConfig_rightScreenCenter_get,.set = js_VrStereoConfig_rightScreenCenter_set,.has = js_VrStereoConfig_rightScreenCenter_has});
		return ret;
	}
	
	static JSValue js_VrStereoConfig_set_rightScreenCenter(JSContext * ctx,JSValue this_val,JSValue v){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			value =(float *)jsc_malloc(ctx,2*sizeof(float));
			int i;
			for(i=0;i<2;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		memcpy((void *)ptr[0].rightScreenCenter,(const void *)value,2*sizeof(float));
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrStereoConfig_scale_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<2;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].scale[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_VrStereoConfig_scale_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		int length=(int)2;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_VrStereoConfig_scale_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)2));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<2){
				float src=ptr[0].scale[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_VrStereoConfig_scale_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].scale[property] =ret;
		}
		return true;
	}
	
	static int js_VrStereoConfig_scale_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<2){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_VrStereoConfig_get_scale(JSContext * ctx,JSValue this_val){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_VrStereoConfig_scale_values,.keys = js_VrStereoConfig_scale_keys,.get = js_VrStereoConfig_scale_get,.set = js_VrStereoConfig_scale_set,.has = js_VrStereoConfig_scale_has});
		return ret;
	}
	
	static JSValue js_VrStereoConfig_set_scale(JSContext * ctx,JSValue this_val,JSValue v){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			value =(float *)jsc_malloc(ctx,2*sizeof(float));
			int i;
			for(i=0;i<2;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		memcpy((void *)ptr[0].scale,(const void *)value,2*sizeof(float));
		return JS_UNDEFINED;
	}
	
	static JSValue js_VrStereoConfig_scaleIn_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<2;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)ptr[0].scaleIn[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_VrStereoConfig_scaleIn_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		int length=(int)2;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_VrStereoConfig_scaleIn_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)2));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<2){
				float src=ptr[0].scaleIn[property];
				JSValue ret=JS_NewFloat64(ctx,((double)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_VrStereoConfig_scaleIn_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			double double_ret;
			int err_ret=JS_ToFloat64(ctx,&double_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			float ret=((float)double_ret);
			ptr[0].scaleIn[property] =ret;
		}
		return true;
	}
	
	static int js_VrStereoConfig_scaleIn_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		VrStereoConfig * ptr=(VrStereoConfig *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<2){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_VrStereoConfig_get_scaleIn(JSContext * ctx,JSValue this_val){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_VrStereoConfig_scaleIn_values,.keys = js_VrStereoConfig_scaleIn_keys,.get = js_VrStereoConfig_scaleIn_get,.set = js_VrStereoConfig_scaleIn_set,.has = js_VrStereoConfig_scaleIn_has});
		return ret;
	}
	
	static JSValue js_VrStereoConfig_set_scaleIn(JSContext * ctx,JSValue this_val,JSValue v){
		VrStereoConfig * ptr=(VrStereoConfig *)JS_GetOpaque2(ctx,this_val,js_VrStereoConfig_class_id);
		float * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			value =(float *)jsc_malloc(ctx,2*sizeof(float));
			int i;
			for(i=0;i<2;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				double double_valuei;
				int err_valuei=JS_ToFloat64(ctx,&double_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((float)double_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				float * js_value=(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(float *)jsc_malloc(ctx,size_value*sizeof(float *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type float *");
				return JS_EXCEPTION;
			}
		}
		memcpy((void *)ptr[0].scaleIn,(const void *)value,2*sizeof(float));
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_VrStereoConfig_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","VrStereoConfig", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("projection",js_VrStereoConfig_get_projection,js_VrStereoConfig_set_projection),
		JS_CGETSET_DEF("viewOffset",js_VrStereoConfig_get_viewOffset,js_VrStereoConfig_set_viewOffset),
		JS_CGETSET_DEF("leftLensCenter",js_VrStereoConfig_get_leftLensCenter,js_VrStereoConfig_set_leftLensCenter),
		JS_CGETSET_DEF("rightLensCenter",js_VrStereoConfig_get_rightLensCenter,js_VrStereoConfig_set_rightLensCenter),
		JS_CGETSET_DEF("leftScreenCenter",js_VrStereoConfig_get_leftScreenCenter,js_VrStereoConfig_set_leftScreenCenter),
		JS_CGETSET_DEF("rightScreenCenter",js_VrStereoConfig_get_rightScreenCenter,js_VrStereoConfig_set_rightScreenCenter),
		JS_CGETSET_DEF("scale",js_VrStereoConfig_get_scale,js_VrStereoConfig_set_scale),
		JS_CGETSET_DEF("scaleIn",js_VrStereoConfig_get_scaleIn,js_VrStereoConfig_set_scaleIn)
	};
	
	static int js_declare_VrStereoConfig(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_VrStereoConfig_class_id);
		JSClassDef js_VrStereoConfig_def={ .class_name = "VrStereoConfig", .finalizer = js_VrStereoConfig_finalizer };
		JS_NewClass(rt,js_VrStereoConfig_class_id,(const JSClassDef *)&js_VrStereoConfig_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_VrStereoConfig_proto_funcs,(int)countof(js_VrStereoConfig_proto_funcs));
		JS_SetClassProto(ctx,js_VrStereoConfig_class_id,proto);
		return 0;
	}
	
	static void js_FilePathList_finalizer(JSRuntime * rt,JSValue val){
		FilePathList * ptr=(FilePathList *)JS_GetOpaque(val,js_FilePathList_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_FilePathList_get_capacity(JSContext * ctx,JSValue this_val){
		FilePathList * ptr=(FilePathList *)JS_GetOpaque2(ctx,this_val,js_FilePathList_class_id);
		unsigned int capacity=ptr[0].capacity;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)capacity));
		return ret;
	}
	
	static JSValue js_FilePathList_set_capacity(JSContext * ctx,JSValue this_val,JSValue v){
		FilePathList * ptr=(FilePathList *)JS_GetOpaque2(ctx,this_val,js_FilePathList_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].capacity=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_FilePathList_get_count(JSContext * ctx,JSValue this_val){
		FilePathList * ptr=(FilePathList *)JS_GetOpaque2(ctx,this_val,js_FilePathList_class_id);
		unsigned int count=ptr[0].count;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)count));
		return ret;
	}
	
	static JSValue js_FilePathList_set_count(JSContext * ctx,JSValue this_val,JSValue v){
		FilePathList * ptr=(FilePathList *)JS_GetOpaque2(ctx,this_val,js_FilePathList_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].count=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_FilePathList_paths_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		FilePathList * ptr=(FilePathList *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].count;i++){
			JSValue js_ret;
			js_ret =JS_NewString(ctx,(const char *)ptr[0].paths[i]);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_FilePathList_paths_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		FilePathList * ptr=(FilePathList *)ptr_u;
		int length=(int)ptr[0].count;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_FilePathList_paths_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		FilePathList * ptr=(FilePathList *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].count));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].count){
				char * src=ptr[0].paths[property];
				JSValue ret;
				ret =JS_NewString(ctx,(const char *)src);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_FilePathList_paths_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		FilePathList * ptr=(FilePathList *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			char * ret;
			JSValue da_ret;
			int64_t size_ret;
			if(JS_IsString(set_to)==1){
				ret =(char *)JS_ToCStringLen(ctx,(size_t *)&size_ret,set_to);
			}else if(JS_IsArrayBuffer(set_to)==1){
				ret =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_ret,set_to);
			}else{
				JSClassID classid_ret=JS_GetClassID(set_to);
				if(classid_ret==JS_CLASS_INT8_ARRAY){
					size_t offset_ret;
					da_ret =JS_GetTypedArrayBuffer(ctx,set_to,&offset_ret,(size_t *)&size_ret,NULL);
					ret =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_ret,da_ret);
					ret +=offset_ret;
					size_ret -=offset_ret;
				}else{
					JS_ThrowTypeError(ctx,(const char *)"set_to does not match type char *");
					return -1;
				}
			}
			ptr[0].paths[property] =ret;
		}
		return true;
	}
	
	static int js_FilePathList_paths_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		FilePathList * ptr=(FilePathList *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].count){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_FilePathList_get_paths(JSContext * ctx,JSValue this_val){
		FilePathList * ptr=(FilePathList *)JS_GetOpaque2(ctx,this_val,js_FilePathList_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_FilePathList_paths_values,.keys = js_FilePathList_paths_keys,.get = js_FilePathList_paths_get,.set = js_FilePathList_paths_set,.has = js_FilePathList_paths_has});
		return ret;
	}
	
	static JSValue js_FilePathList_set_paths(JSContext * ctx,JSValue this_val,JSValue v){
		FilePathList * ptr=(FilePathList *)JS_GetOpaque2(ctx,this_val,js_FilePathList_class_id);
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * * value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&v);
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(char * *)jsc_malloc(ctx,size_value*sizeof(char *));
			memoryCurrent =memoryStore(memoryCurrent,jsc_free,(void *)*value);
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				int64_t size_valuei;
				if(JS_IsString(js_value)==1){
					value[i] =(char *)JS_ToCStringLen(ctx,(size_t *)&size_valuei,js_value);
					memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)value[i]);
				}else if(JS_IsArrayBuffer(js_value)==1){
					value[i] =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_valuei,js_value);
				}else{
					JSClassID classid_valuei=JS_GetClassID(js_value);
					if(classid_valuei==JS_CLASS_INT8_ARRAY){
						size_t offset_valuei;
						JSValue da_valuei=JS_GetTypedArrayBuffer(ctx,js_value,&offset_valuei,(size_t *)&size_valuei,NULL);
						value[i] =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_valuei,da_valuei);
						value[i] +=offset_valuei;
						size_valuei -=offset_valuei;
						memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_valuei);
					}else{
						JS_ThrowTypeError(ctx,(const char *)"js_value does not match type char *");
						return JS_EXCEPTION;
					}
				}
				JS_FreeValue(ctx,js_value);
			}
		}else{
			JS_ThrowTypeError(ctx,(const char *)"v does not match type char * *");
			return JS_EXCEPTION;
		}
		if(ptr[0].paths!=NULL){
			jsc_free(ctx,(void *)*ptr[0].paths);
		}
		ptr[0].paths =value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_FilePathList_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","FilePathList", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("capacity",js_FilePathList_get_capacity,js_FilePathList_set_capacity),
		JS_CGETSET_DEF("count",js_FilePathList_get_count,js_FilePathList_set_count),
		JS_CGETSET_DEF("paths",js_FilePathList_get_paths,js_FilePathList_set_paths)
	};
	
	static int js_declare_FilePathList(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_FilePathList_class_id);
		JSClassDef js_FilePathList_def={ .class_name = "FilePathList", .finalizer = js_FilePathList_finalizer };
		JS_NewClass(rt,js_FilePathList_class_id,(const JSClassDef *)&js_FilePathList_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_FilePathList_proto_funcs,(int)countof(js_FilePathList_proto_funcs));
		JS_SetClassProto(ctx,js_FilePathList_class_id,proto);
		return 0;
	}
	
	static void js_AutomationEvent_finalizer(JSRuntime * rt,JSValue val){
		AutomationEvent * ptr=(AutomationEvent *)JS_GetOpaque(val,js_AutomationEvent_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_AutomationEvent_get_frame(JSContext * ctx,JSValue this_val){
		AutomationEvent * ptr=(AutomationEvent *)JS_GetOpaque2(ctx,this_val,js_AutomationEvent_class_id);
		unsigned int frame=ptr[0].frame;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)frame));
		return ret;
	}
	
	static JSValue js_AutomationEvent_set_frame(JSContext * ctx,JSValue this_val,JSValue v){
		AutomationEvent * ptr=(AutomationEvent *)JS_GetOpaque2(ctx,this_val,js_AutomationEvent_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].frame=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_AutomationEvent_get_type(JSContext * ctx,JSValue this_val){
		AutomationEvent * ptr=(AutomationEvent *)JS_GetOpaque2(ctx,this_val,js_AutomationEvent_class_id);
		unsigned int type=ptr[0].type;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)type));
		return ret;
	}
	
	static JSValue js_AutomationEvent_set_type(JSContext * ctx,JSValue this_val,JSValue v){
		AutomationEvent * ptr=(AutomationEvent *)JS_GetOpaque2(ctx,this_val,js_AutomationEvent_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].type=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_AutomationEvent_params_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		AutomationEvent * ptr=(AutomationEvent *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<4;i++){
			JSValue js_ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].params[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_AutomationEvent_params_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		AutomationEvent * ptr=(AutomationEvent *)ptr_u;
		int length=(int)4;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_AutomationEvent_params_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		AutomationEvent * ptr=(AutomationEvent *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)4));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<4){
				int src=ptr[0].params[property];
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)src));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_AutomationEvent_params_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		AutomationEvent * ptr=(AutomationEvent *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			int32_t long_ret;
			int err_ret=JS_ToInt32(ctx,&long_ret,set_to);
			if(err_ret<0){
				JS_ThrowTypeError(ctx,(const char *)"set_to is not numeric");
				return -1;
			}
			int ret=((int)long_ret);
			ptr[0].params[property] =ret;
		}
		return true;
	}
	
	static int js_AutomationEvent_params_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		AutomationEvent * ptr=(AutomationEvent *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<4){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_AutomationEvent_get_params(JSContext * ctx,JSValue this_val){
		AutomationEvent * ptr=(AutomationEvent *)JS_GetOpaque2(ctx,this_val,js_AutomationEvent_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_AutomationEvent_params_values,.keys = js_AutomationEvent_params_keys,.get = js_AutomationEvent_params_get,.set = js_AutomationEvent_params_set,.has = js_AutomationEvent_params_has});
		return ret;
	}
	
	static JSValue js_AutomationEvent_set_params(JSContext * ctx,JSValue this_val,JSValue v){
		AutomationEvent * ptr=(AutomationEvent *)JS_GetOpaque2(ctx,this_val,js_AutomationEvent_class_id);
		int * value;
		bool freesrc_value=(bool)false;
		JSValue da_value;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			value =(int *)jsc_malloc(ctx,4*sizeof(int));
			int i;
			for(i=0;i<4;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				int32_t long_valuei;
				int err_valuei=JS_ToInt32(ctx,&long_valuei,js_value);
				if(err_valuei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_value is not numeric");
					return JS_EXCEPTION;
				}
				value[i] =((int)long_valuei);
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			int * js_value=(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(int *)jsc_malloc(ctx,size_value*sizeof(int *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			JSClassID classid_value=JS_GetClassID(v);
			if(classid_value==JS_CLASS_INT16_ARRAY){
				size_t offset_value;
				da_value =JS_GetTypedArrayBuffer(ctx,v,&offset_value,(size_t *)&size_value,NULL);
				int * js_value=(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,da_value);
				js_value +=offset_value;
				size_value -=offset_value;
				value =(int *)jsc_malloc(ctx,size_value*sizeof(int *));
				memcpy((void *)value,(const void *)js_value,(size_t)size_value);
				JS_FreeValuePtr(ctx,&da_value);
			}else{
				if(freesrc_value){
					JS_FreeValue(ctx,v);
				}
				JS_ThrowTypeError(ctx,(const char *)"v does not match type int *");
				return JS_EXCEPTION;
			}
		}
		memcpy((void *)ptr[0].params,(const void *)value,4*sizeof(int));
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_AutomationEvent_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","AutomationEvent", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("frame",js_AutomationEvent_get_frame,js_AutomationEvent_set_frame),
		JS_CGETSET_DEF("type",js_AutomationEvent_get_type,js_AutomationEvent_set_type),
		JS_CGETSET_DEF("params",js_AutomationEvent_get_params,js_AutomationEvent_set_params)
	};
	
	static int js_declare_AutomationEvent(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_AutomationEvent_class_id);
		JSClassDef js_AutomationEvent_def={ .class_name = "AutomationEvent", .finalizer = js_AutomationEvent_finalizer };
		JS_NewClass(rt,js_AutomationEvent_class_id,(const JSClassDef *)&js_AutomationEvent_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_AutomationEvent_proto_funcs,(int)countof(js_AutomationEvent_proto_funcs));
		JS_SetClassProto(ctx,js_AutomationEvent_class_id,proto);
		return 0;
	}
	
	static void js_AutomationEventList_finalizer(JSRuntime * rt,JSValue val){
		AutomationEventList * ptr=(AutomationEventList *)JS_GetOpaque(val,js_AutomationEventList_class_id);
		if(ptr){
			js_free_rt(rt,(void *)ptr);
		}
	}
	
	static JSValue js_AutomationEventList_get_capacity(JSContext * ctx,JSValue this_val){
		AutomationEventList * ptr=(AutomationEventList *)JS_GetOpaque2(ctx,this_val,js_AutomationEventList_class_id);
		unsigned int capacity=ptr[0].capacity;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)capacity));
		return ret;
	}
	
	static JSValue js_AutomationEventList_set_capacity(JSContext * ctx,JSValue this_val,JSValue v){
		AutomationEventList * ptr=(AutomationEventList *)JS_GetOpaque2(ctx,this_val,js_AutomationEventList_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].capacity=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_AutomationEventList_get_count(JSContext * ctx,JSValue this_val){
		AutomationEventList * ptr=(AutomationEventList *)JS_GetOpaque2(ctx,this_val,js_AutomationEventList_class_id);
		unsigned int count=ptr[0].count;
		JSValue ret=JS_NewUint32(ctx,(uint32_t)((unsigned long)count));
		return ret;
	}
	
	static JSValue js_AutomationEventList_set_count(JSContext * ctx,JSValue this_val,JSValue v){
		AutomationEventList * ptr=(AutomationEventList *)JS_GetOpaque2(ctx,this_val,js_AutomationEventList_class_id);
		uint32_t long_value;
		int err_value=JS_ToUint32(ctx,&long_value,v);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"v is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int value=((unsigned int)long_value);
		ptr[0].count=value;
		return JS_UNDEFINED;
	}
	
	static JSValue js_AutomationEventList_events_values(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		AutomationEventList * ptr=(AutomationEventList *)ptr_u;
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<ptr[0].count;i++){
			AutomationEvent * ptr_js_ret=(AutomationEvent *)js_malloc(ctx,sizeof(AutomationEvent));
			ptr_js_ret[0]=ptr[0].events[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_AutomationEvent_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(as_sting==true){
			ret =JS_JSONStringify(ctx,ret,JS_UNDEFINED,JS_UNDEFINED);
		}
		return ret;
	}
	
	static int js_AutomationEventList_events_keys(JSContext * ctx,void * ptr_u,JSPropertyEnum * * keys){
		AutomationEventList * ptr=(AutomationEventList *)ptr_u;
		int length=(int)ptr[0].count;
		keys[0] =(JSPropertyEnum *)js_malloc(ctx,(length+1)*sizeof(JSPropertyEnum));
		int i;
		for(i=0;i<length;i++){
			keys[0][i] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_NewAtomUInt32(ctx,i)};
		}
		keys[0][length] =(JSPropertyEnum){.is_enumerable=false, .atom=JS_ATOM_length};
		return true;
	}
	
	static JSValue js_AutomationEventList_events_get(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		AutomationEventList * ptr=(AutomationEventList *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				JSValue ret=JS_NewInt32(ctx,(int32_t)((long)ptr[0].count));
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}else{
			if(property>=0&&property<ptr[0].count){
				AutomationEvent src=ptr[0].events[property];
				AutomationEvent * ptr_ret=(AutomationEvent *)js_malloc(ctx,sizeof(AutomationEvent));
				ptr_ret[0]=src;
				JSValue ret=JS_NewObjectClass(ctx,(int)js_AutomationEvent_class_id);
				JS_SetOpaque(ret,(void *)ptr_ret);
				return ret;
			}else{
				return JS_UNDEFINED;
			}
		}
	}
	
	static int js_AutomationEventList_events_set(JSContext * ctx,void * ptr_u,JSValue set_to,int property,bool as_sting){
		AutomationEventList * ptr=(AutomationEventList *)ptr_u;
		if(as_sting==true){
			return false;
		}else{
			AutomationEvent * ptr_ret=(AutomationEvent *)JS_GetOpaque(set_to,js_AutomationEvent_class_id);
			if(ptr_ret==NULL){
				JS_ThrowTypeError(ctx,(const char *)"set_to does not allow null");
				return -1;
			}
			AutomationEvent ret=*ptr_ret;
			ptr[0].events[property] =ret;
		}
		return true;
	}
	
	static int js_AutomationEventList_events_has(JSContext * ctx,void * ptr_u,int property,bool as_sting){
		AutomationEventList * ptr=(AutomationEventList *)ptr_u;
		if(as_sting==true){
			if(property==JS_ATOM_length){
				return true;
			}else{
				return false;
			}
		}else{
			if(property>=0&&property<ptr[0].count){
				return true;
			}else{
				return false;
			}
		}
	}
	
	static JSValue js_AutomationEventList_get_events(JSContext * ctx,JSValue this_val){
		AutomationEventList * ptr=(AutomationEventList *)JS_GetOpaque2(ctx,this_val,js_AutomationEventList_class_id);
		JSValue ret=js_NewArrayProxy(ctx,(ArrayProxy_class){.anchor = this_val,.opaque = ptr,.values = js_AutomationEventList_events_values,.keys = js_AutomationEventList_events_keys,.get = js_AutomationEventList_events_get,.set = js_AutomationEventList_events_set,.has = js_AutomationEventList_events_has});
		return ret;
	}
	
	static JSValue js_AutomationEventList_set_events(JSContext * ctx,JSValue this_val,JSValue v){
		AutomationEventList * ptr=(AutomationEventList *)JS_GetOpaque2(ctx,this_val,js_AutomationEventList_class_id);
		AutomationEvent * value;
		bool freesrc_value=(bool)false;
		int64_t size_value;
		JSClassID value_class=JS_GetClassID(v);
		if(value_class==js_ArrayProxy_class_id){
			void * opaque_value=JS_GetOpaque(v,js_ArrayProxy_class_id);
			ArrayProxy_class AP_value=((ArrayProxy_class *)opaque_value)[0];
			v =AP_value.values(ctx,AP_value.opaque,(int)0,(bool)false);
			freesrc_value =(bool)true;
		}
		if(JS_IsArray(v)==1){
			if(JS_GetLength(ctx,v,&size_value)==-1){
				return JS_EXCEPTION;
			}
			value =(AutomationEvent *)jsc_malloc(ctx,size_value*sizeof(AutomationEvent));
			int i;
			for(i=0;i<size_value;i++){
				JSValue js_value=JS_GetPropertyUint32(ctx,v,(uint32_t)i);
				AutomationEvent * ptr_valuei=(AutomationEvent *)JS_GetOpaque(js_value,js_AutomationEvent_class_id);
				if(ptr_valuei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_value does not allow null");
					return JS_EXCEPTION;
				}
				value[i] =*ptr_valuei;
				JS_FreeValue(ctx,js_value);
			}
		}else if(JS_IsArrayBuffer(v)==1){
			AutomationEvent * js_value=(AutomationEvent *)JS_GetArrayBuffer(ctx,(size_t *)&size_value,v);
			value =(AutomationEvent *)jsc_malloc(ctx,size_value*sizeof(AutomationEvent *));
			memcpy((void *)value,(const void *)js_value,(size_t)size_value);
		}else{
			if(freesrc_value){
				JS_FreeValue(ctx,v);
			}
			JS_ThrowTypeError(ctx,(const char *)"v does not match type AutomationEvent *");
			return JS_EXCEPTION;
		}
		if(ptr[0].events!=NULL){
			jsc_free(ctx,(void *)ptr[0].events);
		}
		ptr[0].events =value;
		return JS_UNDEFINED;
	}
	static const JSCFunctionListEntry js_AutomationEventList_proto_funcs[]={
		JS_PROP_STRING_DEF("[Symbol.toStringTag]","AutomationEventList", JS_PROP_CONFIGURABLE),
		JS_CGETSET_DEF("capacity",js_AutomationEventList_get_capacity,js_AutomationEventList_set_capacity),
		JS_CGETSET_DEF("count",js_AutomationEventList_get_count,js_AutomationEventList_set_count),
		JS_CGETSET_DEF("events",js_AutomationEventList_get_events,js_AutomationEventList_set_events)
	};
	
	static int js_declare_AutomationEventList(JSContext * ctx,JSModuleDef * m){
		JSRuntime * rt=JS_GetRuntime(ctx);
		JS_NewClassID(rt,&js_AutomationEventList_class_id);
		JSClassDef js_AutomationEventList_def={ .class_name = "AutomationEventList", .finalizer = js_AutomationEventList_finalizer };
		JS_NewClass(rt,js_AutomationEventList_class_id,(const JSClassDef *)&js_AutomationEventList_def);
		JSValue proto=JS_NewObject(ctx);
		JS_SetPropertyFunctionList(ctx,proto,js_AutomationEventList_proto_funcs,(int)countof(js_AutomationEventList_proto_funcs));
		JS_SetClassProto(ctx,js_AutomationEventList_class_id,proto);
		return 0;
	}
	static trampolineContext * LoadFileDataCallback_arr=NULL;
	
	static unsigned char * callback_LoadFileDataCallback(const char * fileName,int dataSize[1]){
		JSValue func1;
		trampolineContext tctx=*LoadFileDataCallback_arr;
		JSContext * ctx=tctx.ctx;
		JSValue js0;
		js0 =JS_NewString(ctx,fileName);
		JSValue js1;
		js1 =JS_NewArray(ctx);
		JSValue js_js10=JS_NewInt32(ctx,(int32_t)((long)dataSize[0]));
		JS_DefinePropertyValueUint32(ctx,js1,(uint32_t)0,js_js10,JS_PROP_C_W_E);
		JSValue argv[2]={
			js0,
			js1
		};
		JS_DupContext(ctx);
		JS_DupValue(ctx,tctx.func_obj);
		JSValue js_ret=JS_Call(ctx,tctx.func_obj,JS_UNDEFINED,(int)2,argv);
		JS_FreeValue(ctx,tctx.func_obj);
		JS_FreeContext(ctx);
		JS_FreeValue(ctx,argv[0]);
		bool freesrc_dataSize=(bool)false;
		int64_t size_dataSize;
		JSClassID dataSize_class=JS_GetClassID(js1);
		if(dataSize_class==js_ArrayProxy_class_id){
			void * opaque_dataSize=JS_GetOpaque(js1,js_ArrayProxy_class_id);
			ArrayProxy_class AP_dataSize=((ArrayProxy_class *)opaque_dataSize)[0];
			js1 =AP_dataSize.values(ctx,AP_dataSize.opaque,(int)0,(bool)false);
			freesrc_dataSize =(bool)true;
		}
		if(JS_IsArray(js1)==1){
			if(JS_GetLength(ctx,js1,&size_dataSize)==-1){
				JS_FreeValue(ctx,js_ret);
				JS_FreeValue(ctx,argv[1]);
				return NULL;
			}
			if(size_dataSize!=1){
				JS_FreeValue(ctx,js_ret);
				JS_FreeValue(ctx,argv[1]);
				return NULL;
			}
			int i;
			for(i=0;i<size_dataSize;i++){
				JSValue js_dataSize=JS_GetPropertyUint32(ctx,js1,(uint32_t)i);
				int32_t long_dataSizei;
				int err_dataSizei=JS_ToInt32(ctx,&long_dataSizei,js_dataSize);
				if(err_dataSizei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_dataSize is not numeric");
					return NULL;
				}
				dataSize[i] =((int)long_dataSizei);
				JS_FreeValue(ctx,js_dataSize);
			}
		}else{
			JS_FreeValue(ctx,js_ret);
			JS_FreeValue(ctx,argv[1]);
			if(freesrc_dataSize){
				JS_FreeValue(ctx,js1);
			}
			JS_ThrowTypeError(ctx,(const char *)"js1 does not match type int *");
			return NULL;
		}
		unsigned char * resp;
		bool freesrc_resp=(bool)false;
		JSValue da_resp;
		int64_t size_resp;
		JSClassID resp_class=JS_GetClassID(js_ret);
		if(resp_class==js_ArrayProxy_class_id){
			void * opaque_resp=JS_GetOpaque(js_ret,js_ArrayProxy_class_id);
			ArrayProxy_class AP_resp=((ArrayProxy_class *)opaque_resp)[0];
			js_ret =AP_resp.values(ctx,AP_resp.opaque,(int)0,(bool)false);
			freesrc_resp =(bool)true;
		}
		if(JS_IsArray(js_ret)==1){
			if(JS_GetLength(ctx,js_ret,&size_resp)==-1){
				JS_FreeValue(ctx,js_ret);
				JS_FreeValue(ctx,argv[1]);
				return NULL;
			}
			resp =(unsigned char *)js_malloc(ctx,size_resp*sizeof(unsigned char));
			int i;
			for(i=0;i<size_resp;i++){
				JSValue js_resp=JS_GetPropertyUint32(ctx,js_ret,(uint32_t)i);
				uint32_t long_respi;
				int err_respi=JS_ToUint32(ctx,&long_respi,js_resp);
				if(err_respi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_resp is not numeric");
					return NULL;
				}
				resp[i] =((unsigned char)long_respi);
				JS_FreeValue(ctx,js_resp);
			}
		}else if(JS_IsArrayBuffer(js_ret)==1){
			resp =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_resp,js_ret);
		}else{
			JSClassID classid_resp=JS_GetClassID(js_ret);
			if(classid_resp==JS_CLASS_UINT8_ARRAY||classid_resp==JS_CLASS_UINT8C_ARRAY){
				size_t offset_resp;
				da_resp =JS_GetTypedArrayBuffer(ctx,js_ret,&offset_resp,(size_t *)&size_resp,NULL);
				resp =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_resp,da_resp);
				resp +=offset_resp;
				size_resp -=offset_resp;
			}else{
				JS_FreeValue(ctx,js_ret);
				JS_FreeValue(ctx,argv[1]);
				if(freesrc_resp){
					JS_FreeValue(ctx,js_ret);
				}
				JS_ThrowTypeError(ctx,(const char *)"js_ret does not match type unsigned char *");
				return NULL;
			}
		}
		JS_FreeValue(ctx,js_ret);
		JS_FreeValue(ctx,argv[1]);
		return resp;
	}
	static trampolineContext * SaveFileDataCallback_arr=NULL;
	
	static bool callback_SaveFileDataCallback(const char * fileName,unsigned char * data,int dataSize){
		JSValue func1;
		trampolineContext tctx=*SaveFileDataCallback_arr;
		JSContext * ctx=tctx.ctx;
		JSValue js0;
		js0 =JS_NewString(ctx,fileName);
		JSValue js1;
		js1 =JS_NewArray(ctx);
		int i;
		for(i=0;i<dataSize;i++){
			JSValue js_js1=JS_NewUint32(ctx,(uint32_t)((unsigned long)data[i]));
			JS_DefinePropertyValueUint32(ctx,js1,(uint32_t)i,js_js1,JS_PROP_C_W_E);
		}
		JSValue js2=JS_NewInt32(ctx,(int32_t)((long)dataSize));
		JSValue argv[3]={
			js0,
			js1,
			js2
		};
		JS_DupContext(ctx);
		JS_DupValue(ctx,tctx.func_obj);
		JSValue js_ret=JS_Call(ctx,tctx.func_obj,JS_UNDEFINED,(int)3,argv);
		JS_FreeValue(ctx,tctx.func_obj);
		JS_FreeContext(ctx);
		JS_FreeValue(ctx,argv[0]);
		JS_FreeValue(ctx,argv[1]);
		JS_FreeValue(ctx,argv[2]);
		int js_resp=JS_ToBool(ctx,js_ret);
		if(js_resp<0){
			JS_FreeValue(ctx,js_ret);
			JS_ThrowTypeError(ctx,(const char *)"js_ret is not a bool");
			return false;
		}
		bool resp=(bool)js_resp;
		JS_FreeValue(ctx,js_ret);
		return resp;
	}
	static trampolineContext * LoadFileTextCallback_arr=NULL;
	
	static char * callback_LoadFileTextCallback(const char * fileName){
		JSValue func1;
		trampolineContext tctx=*LoadFileTextCallback_arr;
		JSContext * ctx=tctx.ctx;
		JSValue js0;
		js0 =JS_NewString(ctx,fileName);
		JSValue argv[1]={
			js0
		};
		JS_DupContext(ctx);
		JS_DupValue(ctx,tctx.func_obj);
		JSValue js_ret=JS_Call(ctx,tctx.func_obj,JS_UNDEFINED,(int)1,argv);
		JS_FreeValue(ctx,tctx.func_obj);
		JS_FreeContext(ctx);
		JS_FreeValue(ctx,argv[0]);
		char * resp;
		JSValue da_resp;
		int64_t size_resp;
		if(JS_IsString(js_ret)==1){
			resp =(char *)JS_ToCStringLen(ctx,(size_t *)&size_resp,js_ret);
		}else if(JS_IsArrayBuffer(js_ret)==1){
			resp =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_resp,js_ret);
		}else{
			JSClassID classid_resp=JS_GetClassID(js_ret);
			if(classid_resp==JS_CLASS_INT8_ARRAY){
				size_t offset_resp;
				da_resp =JS_GetTypedArrayBuffer(ctx,js_ret,&offset_resp,(size_t *)&size_resp,NULL);
				resp =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_resp,da_resp);
				resp +=offset_resp;
				size_resp -=offset_resp;
			}else{
				JS_FreeValue(ctx,js_ret);
				JS_ThrowTypeError(ctx,(const char *)"js_ret does not match type char *");
				return NULL;
			}
		}
		JS_FreeValue(ctx,js_ret);
		return resp;
	}
	static trampolineContext * SaveFileTextCallback_arr=NULL;
	
	static bool callback_SaveFileTextCallback(const char * fileName,const char * text){
		JSValue func1;
		trampolineContext tctx=*SaveFileTextCallback_arr;
		JSContext * ctx=tctx.ctx;
		JSValue js0;
		js0 =JS_NewString(ctx,fileName);
		JSValue js1;
		js1 =JS_NewString(ctx,text);
		JSValue argv[2]={
			js0,
			js1
		};
		JS_DupContext(ctx);
		JS_DupValue(ctx,tctx.func_obj);
		JSValue js_ret=JS_Call(ctx,tctx.func_obj,JS_UNDEFINED,(int)2,argv);
		JS_FreeValue(ctx,tctx.func_obj);
		JS_FreeContext(ctx);
		JS_FreeValue(ctx,argv[0]);
		JS_FreeValue(ctx,argv[1]);
		int js_resp=JS_ToBool(ctx,js_ret);
		if(js_resp<0){
			JS_FreeValue(ctx,js_ret);
			JS_ThrowTypeError(ctx,(const char *)"js_ret is not a bool");
			return false;
		}
		bool resp=(bool)js_resp;
		JS_FreeValue(ctx,js_ret);
		return resp;
	}
	static trampolineContext * AudioStreamCallback_arr=NULL;
	static JSContext * AudioStreamCallback_ctx=NULL;
	
	static void callback_AudioStreamCallback(float * bufferData,unsigned int frames){
		JSValue func1;
		trampolineContext tctx=*AudioStreamCallback_arr;
		JSContext * ctx=AudioStreamCallback_ctx;
		JSValue js0;
		js0 =JS_NewArray(ctx);
		int i;
		for(i=0;i<frames*2;i++){
			JSValue js_js0=JS_NewFloat64(ctx,((double)bufferData[i]));
			JS_DefinePropertyValueUint32(ctx,js0,(uint32_t)i,js_js0,JS_PROP_C_W_E);
		}
		JSValue js1=JS_NewUint32(ctx,(uint32_t)((unsigned long)frames));
		JSValue argv[3]={
			tctx.func_obj,
			js0,
			js1
		};
		JSValue js_ret=js_postMessage(ctx,tctx.thread_id,(int)3,argv);
		JS_FreeValue(ctx,argv[1]);
		JS_FreeValue(ctx,argv[2]);
		JS_FreeValue(ctx,js_ret);
	}
	static trampolineContext * AudioCallback_arr=NULL;
	static JSContext * AudioCallback_ctx=NULL;
	static size_t AudioCallback_size=(size_t)0;
	
	static void callback_AudioCallback(float * bufferData,unsigned int frames){
		JSValue func1;
		int i;
		for(i=0;i<AudioCallback_size;i++){
			trampolineContext tctx=AudioCallback_arr[i];
			JSContext * ctx=AudioCallback_ctx;
			JSValue js0;
			js0 =JS_NewArray(ctx);
			float * sizeref_js0=bufferData;
			size_t size_js0=sizeof(sizeref_js0);
			size_t size1_js0=sizeof(float);
			size_js0 =size_js0/size1_js0;
			int i0;
			for(i0=0;i0<size_js0;i0++){
				JSValue js_js0=JS_NewFloat64(ctx,((double)bufferData[i0]));
				JS_DefinePropertyValueUint32(ctx,js0,(uint32_t)i0,js_js0,JS_PROP_C_W_E);
			}
			JSValue js1=JS_NewUint32(ctx,(uint32_t)((unsigned long)frames));
			JSValue argv[3]={
				tctx.func_obj,
				js0,
				js1
			};
			JSValue js_ret=js_postMessage(ctx,tctx.thread_id,(int)3,argv);
			JS_FreeValue(ctx,argv[1]);
			JS_FreeValue(ctx,argv[2]);
			if(i==AudioCallback_size-1){
				JS_FreeValue(ctx,js_ret);
			}
		}
	}
	static trampolineContext * AudioMixedProcessor_arr=NULL;
	static JSContext * AudioMixedProcessor_ctx=NULL;
	static size_t AudioMixedProcessor_size=(size_t)0;
	
	static void callback_AudioMixedProcessor(float * bufferData,unsigned int frames){
		JSValue func1;
		int i;
		for(i=0;i<AudioMixedProcessor_size;i++){
			trampolineContext tctx=AudioMixedProcessor_arr[i];
			JSContext * ctx=AudioMixedProcessor_ctx;
			JSValue js0;
			js0 =JS_NewArray(ctx);
			int i0;
			for(i0=0;i0<frames*2;i0++){
				JSValue js_js0=JS_NewFloat64(ctx,((double)bufferData[i0]));
				JS_DefinePropertyValueUint32(ctx,js0,(uint32_t)i0,js_js0,JS_PROP_C_W_E);
			}
			JSValue js1=JS_NewUint32(ctx,(uint32_t)((unsigned long)frames));
			JSValue argv[3]={
				tctx.func_obj,
				js0,
				js1
			};
			JSValue js_ret=js_postMessage(ctx,tctx.thread_id,(int)3,argv);
			JS_FreeValue(ctx,argv[1]);
			JS_FreeValue(ctx,argv[2]);
			if(i==AudioMixedProcessor_size-1){
				JS_FreeValue(ctx,js_ret);
			}
		}
	}
	
	static JSValue js_Vector2_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Vector2 * ptr__return=(Vector2 *)js_calloc(ctx,(size_t)1,sizeof(Vector2));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		double double_x;
		int err_x=JS_ToFloat64(ctx,&double_x,argv[0]);
		if(err_x<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float x=((float)double_x);
		double double_y;
		int err_y=JS_ToFloat64(ctx,&double_y,argv[1]);
		if(err_y<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float y=((float)double_y);
		Vector2 _struct={
			x,
			y
		};
		Vector2 * ptr__return=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Vector3_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Vector3 * ptr__return=(Vector3 *)js_calloc(ctx,(size_t)1,sizeof(Vector3));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		double double_x;
		int err_x=JS_ToFloat64(ctx,&double_x,argv[0]);
		if(err_x<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float x=((float)double_x);
		double double_y;
		int err_y=JS_ToFloat64(ctx,&double_y,argv[1]);
		if(err_y<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float y=((float)double_y);
		double double_z;
		int err_z=JS_ToFloat64(ctx,&double_z,argv[2]);
		if(err_z<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float z=((float)double_z);
		Vector3 _struct={
			x,
			y,
			z
		};
		Vector3 * ptr__return=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Vector4_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Vector4 * ptr__return=(Vector4 *)js_calloc(ctx,(size_t)1,sizeof(Vector4));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Vector4_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		double double_x;
		int err_x=JS_ToFloat64(ctx,&double_x,argv[0]);
		if(err_x<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float x=((float)double_x);
		double double_y;
		int err_y=JS_ToFloat64(ctx,&double_y,argv[1]);
		if(err_y<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float y=((float)double_y);
		double double_z;
		int err_z=JS_ToFloat64(ctx,&double_z,argv[2]);
		if(err_z<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float z=((float)double_z);
		double double_w;
		int err_w=JS_ToFloat64(ctx,&double_w,argv[3]);
		if(err_w<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float w=((float)double_w);
		Vector4 _struct={
			x,
			y,
			z,
			w
		};
		Vector4 * ptr__return=(Vector4 *)js_malloc(ctx,sizeof(Vector4));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Vector4_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Matrix_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Matrix * ptr__return=(Matrix *)js_calloc(ctx,(size_t)1,sizeof(Matrix));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Matrix_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		double double_m0;
		int err_m0=JS_ToFloat64(ctx,&double_m0,argv[0]);
		if(err_m0<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float m0=((float)double_m0);
		double double_m4;
		int err_m4=JS_ToFloat64(ctx,&double_m4,argv[1]);
		if(err_m4<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float m4=((float)double_m4);
		double double_m8;
		int err_m8=JS_ToFloat64(ctx,&double_m8,argv[2]);
		if(err_m8<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float m8=((float)double_m8);
		double double_m12;
		int err_m12=JS_ToFloat64(ctx,&double_m12,argv[3]);
		if(err_m12<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float m12=((float)double_m12);
		double double_m1;
		int err_m1=JS_ToFloat64(ctx,&double_m1,argv[4]);
		if(err_m1<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float m1=((float)double_m1);
		double double_m5;
		int err_m5=JS_ToFloat64(ctx,&double_m5,argv[5]);
		if(err_m5<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] is not numeric");
			return JS_EXCEPTION;
		}
		float m5=((float)double_m5);
		double double_m9;
		int err_m9=JS_ToFloat64(ctx,&double_m9,argv[6]);
		if(err_m9<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[6] is not numeric");
			return JS_EXCEPTION;
		}
		float m9=((float)double_m9);
		double double_m13;
		int err_m13=JS_ToFloat64(ctx,&double_m13,argv[7]);
		if(err_m13<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[7] is not numeric");
			return JS_EXCEPTION;
		}
		float m13=((float)double_m13);
		double double_m2;
		int err_m2=JS_ToFloat64(ctx,&double_m2,argv[8]);
		if(err_m2<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[8] is not numeric");
			return JS_EXCEPTION;
		}
		float m2=((float)double_m2);
		double double_m6;
		int err_m6=JS_ToFloat64(ctx,&double_m6,argv[9]);
		if(err_m6<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[9] is not numeric");
			return JS_EXCEPTION;
		}
		float m6=((float)double_m6);
		double double_m10;
		int err_m10=JS_ToFloat64(ctx,&double_m10,argv[10]);
		if(err_m10<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[10] is not numeric");
			return JS_EXCEPTION;
		}
		float m10=((float)double_m10);
		double double_m14;
		int err_m14=JS_ToFloat64(ctx,&double_m14,argv[11]);
		if(err_m14<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[11] is not numeric");
			return JS_EXCEPTION;
		}
		float m14=((float)double_m14);
		double double_m3;
		int err_m3=JS_ToFloat64(ctx,&double_m3,argv[12]);
		if(err_m3<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[12] is not numeric");
			return JS_EXCEPTION;
		}
		float m3=((float)double_m3);
		double double_m7;
		int err_m7=JS_ToFloat64(ctx,&double_m7,argv[13]);
		if(err_m7<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[13] is not numeric");
			return JS_EXCEPTION;
		}
		float m7=((float)double_m7);
		double double_m11;
		int err_m11=JS_ToFloat64(ctx,&double_m11,argv[14]);
		if(err_m11<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[14] is not numeric");
			return JS_EXCEPTION;
		}
		float m11=((float)double_m11);
		double double_m15;
		int err_m15=JS_ToFloat64(ctx,&double_m15,argv[15]);
		if(err_m15<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[15] is not numeric");
			return JS_EXCEPTION;
		}
		float m15=((float)double_m15);
		Matrix _struct={
			m0,
			m4,
			m8,
			m12,
			m1,
			m5,
			m9,
			m13,
			m2,
			m6,
			m10,
			m14,
			m3,
			m7,
			m11,
			m15
		};
		Matrix * ptr__return=(Matrix *)js_malloc(ctx,sizeof(Matrix));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Matrix_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Color_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Color * ptr__return=(Color *)js_calloc(ctx,(size_t)1,sizeof(Color));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Color_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		uint32_t long_r;
		int err_r=JS_ToUint32(ctx,&long_r,argv[0]);
		if(err_r<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned char r=((unsigned char)long_r);
		uint32_t long_g;
		int err_g=JS_ToUint32(ctx,&long_g,argv[1]);
		if(err_g<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned char g=((unsigned char)long_g);
		uint32_t long_b;
		int err_b=JS_ToUint32(ctx,&long_b,argv[2]);
		if(err_b<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned char b=((unsigned char)long_b);
		uint32_t long_a;
		int err_a=JS_ToUint32(ctx,&long_a,argv[3]);
		if(err_a<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned char a=((unsigned char)long_a);
		Color _struct={
			r,
			g,
			b,
			a
		};
		Color * ptr__return=(Color *)js_malloc(ctx,sizeof(Color));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Rectangle_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Rectangle * ptr__return=(Rectangle *)js_calloc(ctx,(size_t)1,sizeof(Rectangle));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Rectangle_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		double double_x;
		int err_x=JS_ToFloat64(ctx,&double_x,argv[0]);
		if(err_x<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float x=((float)double_x);
		double double_y;
		int err_y=JS_ToFloat64(ctx,&double_y,argv[1]);
		if(err_y<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float y=((float)double_y);
		double double_width;
		int err_width=JS_ToFloat64(ctx,&double_width,argv[2]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float width=((float)double_width);
		double double_height;
		int err_height=JS_ToFloat64(ctx,&double_height,argv[3]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float height=((float)double_height);
		Rectangle _struct={
			x,
			y,
			width,
			height
		};
		Rectangle * ptr__return=(Rectangle *)js_malloc(ctx,sizeof(Rectangle));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Rectangle_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Image_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Image * ptr__return=(Image *)js_calloc(ctx,(size_t)1,sizeof(Image));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Image_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		void * data;
		int64_t size_data;
		if(JS_IsArrayBuffer(argv[0])==1){
			data =(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[0]);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type void *");
			return JS_EXCEPTION;
		}
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[1]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[2]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		int32_t long_mipmaps;
		int err_mipmaps=JS_ToInt32(ctx,&long_mipmaps,argv[3]);
		if(err_mipmaps<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int mipmaps=((int)long_mipmaps);
		int32_t long_format;
		int err_format=JS_ToInt32(ctx,&long_format,argv[4]);
		if(err_format<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int format=((int)long_format);
		Image _struct={
			data,
			width,
			height,
			mipmaps,
			format
		};
		Image * ptr__return=(Image *)js_malloc(ctx,sizeof(Image));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Texture_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Texture * ptr__return=(Texture *)js_calloc(ctx,(size_t)1,sizeof(Texture));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Texture_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		uint32_t long_id;
		int err_id=JS_ToUint32(ctx,&long_id,argv[0]);
		if(err_id<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int id=((unsigned int)long_id);
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[1]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[2]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		int32_t long_mipmaps;
		int err_mipmaps=JS_ToInt32(ctx,&long_mipmaps,argv[3]);
		if(err_mipmaps<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int mipmaps=((int)long_mipmaps);
		int32_t long_format;
		int err_format=JS_ToInt32(ctx,&long_format,argv[4]);
		if(err_format<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int format=((int)long_format);
		Texture _struct={
			id,
			width,
			height,
			mipmaps,
			format
		};
		Texture * ptr__return=(Texture *)js_malloc(ctx,sizeof(Texture));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Texture_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_RenderTexture_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			RenderTexture * ptr__return=(RenderTexture *)js_calloc(ctx,(size_t)1,sizeof(RenderTexture));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_RenderTexture_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		uint32_t long_id;
		int err_id=JS_ToUint32(ctx,&long_id,argv[0]);
		if(err_id<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int id=((unsigned int)long_id);
		Texture * ptr_texture=(Texture *)JS_GetOpaque(argv[1],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Texture texture=*ptr_texture;
		Texture * ptr_depth=(Texture *)JS_GetOpaque(argv[2],js_Texture_class_id);
		if(ptr_depth==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Texture depth=*ptr_depth;
		RenderTexture _struct={
			id,
			texture,
			depth
		};
		RenderTexture * ptr__return=(RenderTexture *)js_malloc(ctx,sizeof(RenderTexture));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_RenderTexture_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_NPatchInfo_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			NPatchInfo * ptr__return=(NPatchInfo *)js_calloc(ctx,(size_t)1,sizeof(NPatchInfo));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_NPatchInfo_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		Rectangle * ptr_source=(Rectangle *)JS_GetOpaque(argv[0],js_Rectangle_class_id);
		if(ptr_source==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle source=*ptr_source;
		int32_t long_left;
		int err_left=JS_ToInt32(ctx,&long_left,argv[1]);
		if(err_left<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int left=((int)long_left);
		int32_t long_top;
		int err_top=JS_ToInt32(ctx,&long_top,argv[2]);
		if(err_top<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int top=((int)long_top);
		int32_t long_right;
		int err_right=JS_ToInt32(ctx,&long_right,argv[3]);
		if(err_right<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int right=((int)long_right);
		int32_t long_bottom;
		int err_bottom=JS_ToInt32(ctx,&long_bottom,argv[4]);
		if(err_bottom<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int bottom=((int)long_bottom);
		int32_t long_layout;
		int err_layout=JS_ToInt32(ctx,&long_layout,argv[5]);
		if(err_layout<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] is not numeric");
			return JS_EXCEPTION;
		}
		int layout=((int)long_layout);
		NPatchInfo _struct={
			source,
			left,
			top,
			right,
			bottom,
			layout
		};
		NPatchInfo * ptr__return=(NPatchInfo *)js_malloc(ctx,sizeof(NPatchInfo));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_NPatchInfo_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_GlyphInfo_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			GlyphInfo * ptr__return=(GlyphInfo *)js_calloc(ctx,(size_t)1,sizeof(GlyphInfo));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_GlyphInfo_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		int32_t long_value;
		int err_value=JS_ToInt32(ctx,&long_value,argv[0]);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int value=((int)long_value);
		int32_t long_offsetX;
		int err_offsetX=JS_ToInt32(ctx,&long_offsetX,argv[1]);
		if(err_offsetX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int offsetX=((int)long_offsetX);
		int32_t long_offsetY;
		int err_offsetY=JS_ToInt32(ctx,&long_offsetY,argv[2]);
		if(err_offsetY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int offsetY=((int)long_offsetY);
		int32_t long_advanceX;
		int err_advanceX=JS_ToInt32(ctx,&long_advanceX,argv[3]);
		if(err_advanceX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int advanceX=((int)long_advanceX);
		Image * ptr_image=(Image *)JS_GetOpaque(argv[4],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		GlyphInfo _struct={
			value,
			offsetX,
			offsetY,
			advanceX,
			image
		};
		GlyphInfo * ptr__return=(GlyphInfo *)js_malloc(ctx,sizeof(GlyphInfo));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_GlyphInfo_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Font_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Font * ptr__return=(Font *)js_calloc(ctx,(size_t)1,sizeof(Font));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Font_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		int32_t long_baseSize;
		int err_baseSize=JS_ToInt32(ctx,&long_baseSize,argv[0]);
		if(err_baseSize<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int baseSize=((int)long_baseSize);
		int32_t long_glyphCount;
		int err_glyphCount=JS_ToInt32(ctx,&long_glyphCount,argv[1]);
		if(err_glyphCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int glyphCount=((int)long_glyphCount);
		int32_t long_glyphPadding;
		int err_glyphPadding=JS_ToInt32(ctx,&long_glyphPadding,argv[2]);
		if(err_glyphPadding<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int glyphPadding=((int)long_glyphPadding);
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[3],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		Rectangle * recs;
		bool freesrc_recs=(bool)false;
		int64_t size_recs;
		JSClassID recs_class=JS_GetClassID(argv[4]);
		if(recs_class==js_ArrayProxy_class_id){
			void * opaque_recs=JS_GetOpaque(argv[4],js_ArrayProxy_class_id);
			ArrayProxy_class AP_recs=((ArrayProxy_class *)opaque_recs)[0];
			argv[4] =AP_recs.values(ctx,AP_recs.opaque,(int)0,(bool)false);
			freesrc_recs =(bool)true;
		}
		if(JS_IsArray(argv[4])==1){
			if(JS_GetLength(ctx,argv[4],&size_recs)==-1){
				return JS_EXCEPTION;
			}
			recs =(Rectangle *)js_malloc(ctx,size_recs*sizeof(Rectangle));
			int i;
			for(i=0;i<size_recs;i++){
				JSValue js_recs=JS_GetPropertyUint32(ctx,argv[4],(uint32_t)i);
				Rectangle * ptr_recsi=(Rectangle *)JS_GetOpaque(js_recs,js_Rectangle_class_id);
				if(ptr_recsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_recs does not allow null");
					return JS_EXCEPTION;
				}
				recs[i] =*ptr_recsi;
				JS_FreeValue(ctx,js_recs);
			}
		}else if(JS_IsArrayBuffer(argv[4])==1){
			recs =(Rectangle *)JS_GetArrayBuffer(ctx,(size_t *)&size_recs,argv[4]);
		}else{
			if(freesrc_recs){
				JS_FreeValue(ctx,argv[4]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not match type Rectangle *");
			return JS_EXCEPTION;
		}
		GlyphInfo * glyphs;
		bool freesrc_glyphs=(bool)false;
		int64_t size_glyphs;
		JSClassID glyphs_class=JS_GetClassID(argv[5]);
		if(glyphs_class==js_ArrayProxy_class_id){
			void * opaque_glyphs=JS_GetOpaque(argv[5],js_ArrayProxy_class_id);
			ArrayProxy_class AP_glyphs=((ArrayProxy_class *)opaque_glyphs)[0];
			argv[5] =AP_glyphs.values(ctx,AP_glyphs.opaque,(int)0,(bool)false);
			freesrc_glyphs =(bool)true;
		}
		if(JS_IsArray(argv[5])==1){
			if(JS_GetLength(ctx,argv[5],&size_glyphs)==-1){
				return JS_EXCEPTION;
			}
			glyphs =(GlyphInfo *)js_malloc(ctx,size_glyphs*sizeof(GlyphInfo));
			int i;
			for(i=0;i<size_glyphs;i++){
				JSValue js_glyphs=JS_GetPropertyUint32(ctx,argv[5],(uint32_t)i);
				GlyphInfo * ptr_glyphsi=(GlyphInfo *)JS_GetOpaque(js_glyphs,js_GlyphInfo_class_id);
				if(ptr_glyphsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_glyphs does not allow null");
					return JS_EXCEPTION;
				}
				glyphs[i] =*ptr_glyphsi;
				JS_FreeValue(ctx,js_glyphs);
			}
		}else if(JS_IsArrayBuffer(argv[5])==1){
			glyphs =(GlyphInfo *)JS_GetArrayBuffer(ctx,(size_t *)&size_glyphs,argv[5]);
		}else{
			if(freesrc_glyphs){
				JS_FreeValue(ctx,argv[5]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not match type GlyphInfo *");
			return JS_EXCEPTION;
		}
		Font _struct={
			baseSize,
			glyphCount,
			glyphPadding,
			texture,
			recs,
			glyphs
		};
		Font * ptr__return=(Font *)js_malloc(ctx,sizeof(Font));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Font_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Camera3D_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Camera3D * ptr__return=(Camera3D *)js_calloc(ctx,(size_t)1,sizeof(Camera3D));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Camera3D_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		Vector3 * ptr_target=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_target==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 target=*ptr_target;
		Vector3 * ptr_up=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_up==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 up=*ptr_up;
		double double_fovy;
		int err_fovy=JS_ToFloat64(ctx,&double_fovy,argv[3]);
		if(err_fovy<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float fovy=((float)double_fovy);
		int32_t long_projection;
		int err_projection=JS_ToInt32(ctx,&long_projection,argv[4]);
		if(err_projection<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int projection=((int)long_projection);
		Camera3D _struct={
			position,
			target,
			up,
			fovy,
			projection
		};
		Camera3D * ptr__return=(Camera3D *)js_malloc(ctx,sizeof(Camera3D));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Camera3D_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Camera2D_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Camera2D * ptr__return=(Camera2D *)js_calloc(ctx,(size_t)1,sizeof(Camera2D));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Camera2D_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		Vector2 * ptr_offset=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_offset==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 offset=*ptr_offset;
		Vector2 * ptr_target=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_target==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 target=*ptr_target;
		double double_rotation;
		int err_rotation=JS_ToFloat64(ctx,&double_rotation,argv[2]);
		if(err_rotation<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float rotation=((float)double_rotation);
		double double_zoom;
		int err_zoom=JS_ToFloat64(ctx,&double_zoom,argv[3]);
		if(err_zoom<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float zoom=((float)double_zoom);
		Camera2D _struct={
			offset,
			target,
			rotation,
			zoom
		};
		Camera2D * ptr__return=(Camera2D *)js_malloc(ctx,sizeof(Camera2D));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Camera2D_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Mesh_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Mesh * ptr__return=(Mesh *)js_calloc(ctx,(size_t)1,sizeof(Mesh));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		int32_t long_vertexCount;
		int err_vertexCount=JS_ToInt32(ctx,&long_vertexCount,argv[0]);
		if(err_vertexCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int vertexCount=((int)long_vertexCount);
		int32_t long_triangleCount;
		int err_triangleCount=JS_ToInt32(ctx,&long_triangleCount,argv[1]);
		if(err_triangleCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int triangleCount=((int)long_triangleCount);
		float * vertices;
		bool freesrc_vertices=(bool)false;
		JSValue da_vertices;
		int64_t size_vertices;
		JSClassID vertices_class=JS_GetClassID(argv[2]);
		if(vertices_class==js_ArrayProxy_class_id){
			void * opaque_vertices=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_vertices=((ArrayProxy_class *)opaque_vertices)[0];
			argv[2] =AP_vertices.values(ctx,AP_vertices.opaque,(int)0,(bool)false);
			freesrc_vertices =(bool)true;
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_vertices)==-1){
				return JS_EXCEPTION;
			}
			vertices =(float *)js_malloc(ctx,size_vertices*sizeof(float));
			int i;
			for(i=0;i<size_vertices;i++){
				JSValue js_vertices=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				double double_verticesi;
				int err_verticesi=JS_ToFloat64(ctx,&double_verticesi,js_vertices);
				if(err_verticesi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_vertices is not numeric");
					return JS_EXCEPTION;
				}
				vertices[i] =((float)double_verticesi);
				JS_FreeValue(ctx,js_vertices);
			}
		}else if(JS_IsArrayBuffer(argv[2])==1){
			vertices =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_vertices,argv[2]);
		}else{
			JSClassID classid_vertices=JS_GetClassID(argv[2]);
			if(classid_vertices==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_vertices;
				da_vertices =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_vertices,(size_t *)&size_vertices,NULL);
				vertices =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_vertices,da_vertices);
				vertices +=offset_vertices;
				size_vertices -=offset_vertices;
			}else{
				if(freesrc_vertices){
					JS_FreeValue(ctx,argv[2]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		float * texcoords;
		bool freesrc_texcoords=(bool)false;
		JSValue da_texcoords;
		int64_t size_texcoords;
		JSClassID texcoords_class=JS_GetClassID(argv[3]);
		if(texcoords_class==js_ArrayProxy_class_id){
			void * opaque_texcoords=JS_GetOpaque(argv[3],js_ArrayProxy_class_id);
			ArrayProxy_class AP_texcoords=((ArrayProxy_class *)opaque_texcoords)[0];
			argv[3] =AP_texcoords.values(ctx,AP_texcoords.opaque,(int)0,(bool)false);
			freesrc_texcoords =(bool)true;
		}
		if(JS_IsArray(argv[3])==1){
			if(JS_GetLength(ctx,argv[3],&size_texcoords)==-1){
				return JS_EXCEPTION;
			}
			texcoords =(float *)js_malloc(ctx,size_texcoords*sizeof(float));
			int i;
			for(i=0;i<size_texcoords;i++){
				JSValue js_texcoords=JS_GetPropertyUint32(ctx,argv[3],(uint32_t)i);
				double double_texcoordsi;
				int err_texcoordsi=JS_ToFloat64(ctx,&double_texcoordsi,js_texcoords);
				if(err_texcoordsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_texcoords is not numeric");
					return JS_EXCEPTION;
				}
				texcoords[i] =((float)double_texcoordsi);
				JS_FreeValue(ctx,js_texcoords);
			}
		}else if(JS_IsArrayBuffer(argv[3])==1){
			texcoords =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_texcoords,argv[3]);
		}else{
			JSClassID classid_texcoords=JS_GetClassID(argv[3]);
			if(classid_texcoords==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_texcoords;
				da_texcoords =JS_GetTypedArrayBuffer(ctx,argv[3],&offset_texcoords,(size_t *)&size_texcoords,NULL);
				texcoords =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_texcoords,da_texcoords);
				texcoords +=offset_texcoords;
				size_texcoords -=offset_texcoords;
			}else{
				if(freesrc_texcoords){
					JS_FreeValue(ctx,argv[3]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[3] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		float * texcoords2;
		bool freesrc_texcoords2=(bool)false;
		JSValue da_texcoords2;
		int64_t size_texcoords2;
		JSClassID texcoords2_class=JS_GetClassID(argv[4]);
		if(texcoords2_class==js_ArrayProxy_class_id){
			void * opaque_texcoords2=JS_GetOpaque(argv[4],js_ArrayProxy_class_id);
			ArrayProxy_class AP_texcoords2=((ArrayProxy_class *)opaque_texcoords2)[0];
			argv[4] =AP_texcoords2.values(ctx,AP_texcoords2.opaque,(int)0,(bool)false);
			freesrc_texcoords2 =(bool)true;
		}
		if(JS_IsArray(argv[4])==1){
			if(JS_GetLength(ctx,argv[4],&size_texcoords2)==-1){
				return JS_EXCEPTION;
			}
			texcoords2 =(float *)js_malloc(ctx,size_texcoords2*sizeof(float));
			int i;
			for(i=0;i<size_texcoords2;i++){
				JSValue js_texcoords2=JS_GetPropertyUint32(ctx,argv[4],(uint32_t)i);
				double double_texcoords2i;
				int err_texcoords2i=JS_ToFloat64(ctx,&double_texcoords2i,js_texcoords2);
				if(err_texcoords2i<0){
					JS_ThrowTypeError(ctx,(const char *)"js_texcoords2 is not numeric");
					return JS_EXCEPTION;
				}
				texcoords2[i] =((float)double_texcoords2i);
				JS_FreeValue(ctx,js_texcoords2);
			}
		}else if(JS_IsArrayBuffer(argv[4])==1){
			texcoords2 =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_texcoords2,argv[4]);
		}else{
			JSClassID classid_texcoords2=JS_GetClassID(argv[4]);
			if(classid_texcoords2==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_texcoords2;
				da_texcoords2 =JS_GetTypedArrayBuffer(ctx,argv[4],&offset_texcoords2,(size_t *)&size_texcoords2,NULL);
				texcoords2 =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_texcoords2,da_texcoords2);
				texcoords2 +=offset_texcoords2;
				size_texcoords2 -=offset_texcoords2;
			}else{
				if(freesrc_texcoords2){
					JS_FreeValue(ctx,argv[4]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[4] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		float * normals;
		bool freesrc_normals=(bool)false;
		JSValue da_normals;
		int64_t size_normals;
		JSClassID normals_class=JS_GetClassID(argv[5]);
		if(normals_class==js_ArrayProxy_class_id){
			void * opaque_normals=JS_GetOpaque(argv[5],js_ArrayProxy_class_id);
			ArrayProxy_class AP_normals=((ArrayProxy_class *)opaque_normals)[0];
			argv[5] =AP_normals.values(ctx,AP_normals.opaque,(int)0,(bool)false);
			freesrc_normals =(bool)true;
		}
		if(JS_IsArray(argv[5])==1){
			if(JS_GetLength(ctx,argv[5],&size_normals)==-1){
				return JS_EXCEPTION;
			}
			normals =(float *)js_malloc(ctx,size_normals*sizeof(float));
			int i;
			for(i=0;i<size_normals;i++){
				JSValue js_normals=JS_GetPropertyUint32(ctx,argv[5],(uint32_t)i);
				double double_normalsi;
				int err_normalsi=JS_ToFloat64(ctx,&double_normalsi,js_normals);
				if(err_normalsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_normals is not numeric");
					return JS_EXCEPTION;
				}
				normals[i] =((float)double_normalsi);
				JS_FreeValue(ctx,js_normals);
			}
		}else if(JS_IsArrayBuffer(argv[5])==1){
			normals =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_normals,argv[5]);
		}else{
			JSClassID classid_normals=JS_GetClassID(argv[5]);
			if(classid_normals==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_normals;
				da_normals =JS_GetTypedArrayBuffer(ctx,argv[5],&offset_normals,(size_t *)&size_normals,NULL);
				normals =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_normals,da_normals);
				normals +=offset_normals;
				size_normals -=offset_normals;
			}else{
				if(freesrc_normals){
					JS_FreeValue(ctx,argv[5]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[5] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		float * tangents;
		bool freesrc_tangents=(bool)false;
		JSValue da_tangents;
		int64_t size_tangents;
		JSClassID tangents_class=JS_GetClassID(argv[6]);
		if(tangents_class==js_ArrayProxy_class_id){
			void * opaque_tangents=JS_GetOpaque(argv[6],js_ArrayProxy_class_id);
			ArrayProxy_class AP_tangents=((ArrayProxy_class *)opaque_tangents)[0];
			argv[6] =AP_tangents.values(ctx,AP_tangents.opaque,(int)0,(bool)false);
			freesrc_tangents =(bool)true;
		}
		if(JS_IsArray(argv[6])==1){
			if(JS_GetLength(ctx,argv[6],&size_tangents)==-1){
				return JS_EXCEPTION;
			}
			tangents =(float *)js_malloc(ctx,size_tangents*sizeof(float));
			int i;
			for(i=0;i<size_tangents;i++){
				JSValue js_tangents=JS_GetPropertyUint32(ctx,argv[6],(uint32_t)i);
				double double_tangentsi;
				int err_tangentsi=JS_ToFloat64(ctx,&double_tangentsi,js_tangents);
				if(err_tangentsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_tangents is not numeric");
					return JS_EXCEPTION;
				}
				tangents[i] =((float)double_tangentsi);
				JS_FreeValue(ctx,js_tangents);
			}
		}else if(JS_IsArrayBuffer(argv[6])==1){
			tangents =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_tangents,argv[6]);
		}else{
			JSClassID classid_tangents=JS_GetClassID(argv[6]);
			if(classid_tangents==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_tangents;
				da_tangents =JS_GetTypedArrayBuffer(ctx,argv[6],&offset_tangents,(size_t *)&size_tangents,NULL);
				tangents =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_tangents,da_tangents);
				tangents +=offset_tangents;
				size_tangents -=offset_tangents;
			}else{
				if(freesrc_tangents){
					JS_FreeValue(ctx,argv[6]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[6] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		unsigned char * colors;
		bool freesrc_colors=(bool)false;
		JSValue da_colors;
		int64_t size_colors;
		JSClassID colors_class=JS_GetClassID(argv[7]);
		if(colors_class==js_ArrayProxy_class_id){
			void * opaque_colors=JS_GetOpaque(argv[7],js_ArrayProxy_class_id);
			ArrayProxy_class AP_colors=((ArrayProxy_class *)opaque_colors)[0];
			argv[7] =AP_colors.values(ctx,AP_colors.opaque,(int)0,(bool)false);
			freesrc_colors =(bool)true;
		}
		if(JS_IsArray(argv[7])==1){
			if(JS_GetLength(ctx,argv[7],&size_colors)==-1){
				return JS_EXCEPTION;
			}
			colors =(unsigned char *)js_malloc(ctx,size_colors*sizeof(unsigned char));
			int i;
			for(i=0;i<size_colors;i++){
				JSValue js_colors=JS_GetPropertyUint32(ctx,argv[7],(uint32_t)i);
				uint32_t long_colorsi;
				int err_colorsi=JS_ToUint32(ctx,&long_colorsi,js_colors);
				if(err_colorsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_colors is not numeric");
					return JS_EXCEPTION;
				}
				colors[i] =((unsigned char)long_colorsi);
				JS_FreeValue(ctx,js_colors);
			}
		}else if(JS_IsArrayBuffer(argv[7])==1){
			colors =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_colors,argv[7]);
		}else{
			JSClassID classid_colors=JS_GetClassID(argv[7]);
			if(classid_colors==JS_CLASS_UINT8_ARRAY||classid_colors==JS_CLASS_UINT8C_ARRAY){
				size_t offset_colors;
				da_colors =JS_GetTypedArrayBuffer(ctx,argv[7],&offset_colors,(size_t *)&size_colors,NULL);
				colors =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_colors,da_colors);
				colors +=offset_colors;
				size_colors -=offset_colors;
			}else{
				if(freesrc_colors){
					JS_FreeValue(ctx,argv[7]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[7] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		unsigned short * indices;
		bool freesrc_indices=(bool)false;
		JSValue da_indices;
		int64_t size_indices;
		JSClassID indices_class=JS_GetClassID(argv[8]);
		if(indices_class==js_ArrayProxy_class_id){
			void * opaque_indices=JS_GetOpaque(argv[8],js_ArrayProxy_class_id);
			ArrayProxy_class AP_indices=((ArrayProxy_class *)opaque_indices)[0];
			argv[8] =AP_indices.values(ctx,AP_indices.opaque,(int)0,(bool)false);
			freesrc_indices =(bool)true;
		}
		if(JS_IsArray(argv[8])==1){
			if(JS_GetLength(ctx,argv[8],&size_indices)==-1){
				return JS_EXCEPTION;
			}
			indices =(unsigned short *)js_malloc(ctx,size_indices*sizeof(unsigned short));
			int i;
			for(i=0;i<size_indices;i++){
				JSValue js_indices=JS_GetPropertyUint32(ctx,argv[8],(uint32_t)i);
				uint32_t long_indicesi;
				int err_indicesi=JS_ToUint32(ctx,&long_indicesi,js_indices);
				if(err_indicesi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_indices is not numeric");
					return JS_EXCEPTION;
				}
				indices[i] =((unsigned short)long_indicesi);
				JS_FreeValue(ctx,js_indices);
			}
		}else if(JS_IsArrayBuffer(argv[8])==1){
			indices =(unsigned short *)JS_GetArrayBuffer(ctx,(size_t *)&size_indices,argv[8]);
		}else{
			JSClassID classid_indices=JS_GetClassID(argv[8]);
			if(classid_indices==JS_CLASS_UINT16_ARRAY){
				size_t offset_indices;
				da_indices =JS_GetTypedArrayBuffer(ctx,argv[8],&offset_indices,(size_t *)&size_indices,NULL);
				indices =(unsigned short *)JS_GetArrayBuffer(ctx,(size_t *)&size_indices,da_indices);
				indices +=offset_indices;
				size_indices -=offset_indices;
			}else{
				if(freesrc_indices){
					JS_FreeValue(ctx,argv[8]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[8] does not match type unsigned short *");
				return JS_EXCEPTION;
			}
		}
		float * animVertices;
		bool freesrc_animVertices=(bool)false;
		JSValue da_animVertices;
		int64_t size_animVertices;
		JSClassID animVertices_class=JS_GetClassID(argv[9]);
		if(animVertices_class==js_ArrayProxy_class_id){
			void * opaque_animVertices=JS_GetOpaque(argv[9],js_ArrayProxy_class_id);
			ArrayProxy_class AP_animVertices=((ArrayProxy_class *)opaque_animVertices)[0];
			argv[9] =AP_animVertices.values(ctx,AP_animVertices.opaque,(int)0,(bool)false);
			freesrc_animVertices =(bool)true;
		}
		if(JS_IsArray(argv[9])==1){
			if(JS_GetLength(ctx,argv[9],&size_animVertices)==-1){
				return JS_EXCEPTION;
			}
			animVertices =(float *)js_malloc(ctx,size_animVertices*sizeof(float));
			int i;
			for(i=0;i<size_animVertices;i++){
				JSValue js_animVertices=JS_GetPropertyUint32(ctx,argv[9],(uint32_t)i);
				double double_animVerticesi;
				int err_animVerticesi=JS_ToFloat64(ctx,&double_animVerticesi,js_animVertices);
				if(err_animVerticesi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_animVertices is not numeric");
					return JS_EXCEPTION;
				}
				animVertices[i] =((float)double_animVerticesi);
				JS_FreeValue(ctx,js_animVertices);
			}
		}else if(JS_IsArrayBuffer(argv[9])==1){
			animVertices =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_animVertices,argv[9]);
		}else{
			JSClassID classid_animVertices=JS_GetClassID(argv[9]);
			if(classid_animVertices==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_animVertices;
				da_animVertices =JS_GetTypedArrayBuffer(ctx,argv[9],&offset_animVertices,(size_t *)&size_animVertices,NULL);
				animVertices =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_animVertices,da_animVertices);
				animVertices +=offset_animVertices;
				size_animVertices -=offset_animVertices;
			}else{
				if(freesrc_animVertices){
					JS_FreeValue(ctx,argv[9]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[9] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		float * animNormals;
		bool freesrc_animNormals=(bool)false;
		JSValue da_animNormals;
		int64_t size_animNormals;
		JSClassID animNormals_class=JS_GetClassID(argv[10]);
		if(animNormals_class==js_ArrayProxy_class_id){
			void * opaque_animNormals=JS_GetOpaque(argv[10],js_ArrayProxy_class_id);
			ArrayProxy_class AP_animNormals=((ArrayProxy_class *)opaque_animNormals)[0];
			argv[10] =AP_animNormals.values(ctx,AP_animNormals.opaque,(int)0,(bool)false);
			freesrc_animNormals =(bool)true;
		}
		if(JS_IsArray(argv[10])==1){
			if(JS_GetLength(ctx,argv[10],&size_animNormals)==-1){
				return JS_EXCEPTION;
			}
			animNormals =(float *)js_malloc(ctx,size_animNormals*sizeof(float));
			int i;
			for(i=0;i<size_animNormals;i++){
				JSValue js_animNormals=JS_GetPropertyUint32(ctx,argv[10],(uint32_t)i);
				double double_animNormalsi;
				int err_animNormalsi=JS_ToFloat64(ctx,&double_animNormalsi,js_animNormals);
				if(err_animNormalsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_animNormals is not numeric");
					return JS_EXCEPTION;
				}
				animNormals[i] =((float)double_animNormalsi);
				JS_FreeValue(ctx,js_animNormals);
			}
		}else if(JS_IsArrayBuffer(argv[10])==1){
			animNormals =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_animNormals,argv[10]);
		}else{
			JSClassID classid_animNormals=JS_GetClassID(argv[10]);
			if(classid_animNormals==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_animNormals;
				da_animNormals =JS_GetTypedArrayBuffer(ctx,argv[10],&offset_animNormals,(size_t *)&size_animNormals,NULL);
				animNormals =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_animNormals,da_animNormals);
				animNormals +=offset_animNormals;
				size_animNormals -=offset_animNormals;
			}else{
				if(freesrc_animNormals){
					JS_FreeValue(ctx,argv[10]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[10] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		unsigned char * boneIds;
		bool freesrc_boneIds=(bool)false;
		JSValue da_boneIds;
		int64_t size_boneIds;
		JSClassID boneIds_class=JS_GetClassID(argv[11]);
		if(boneIds_class==js_ArrayProxy_class_id){
			void * opaque_boneIds=JS_GetOpaque(argv[11],js_ArrayProxy_class_id);
			ArrayProxy_class AP_boneIds=((ArrayProxy_class *)opaque_boneIds)[0];
			argv[11] =AP_boneIds.values(ctx,AP_boneIds.opaque,(int)0,(bool)false);
			freesrc_boneIds =(bool)true;
		}
		if(JS_IsArray(argv[11])==1){
			if(JS_GetLength(ctx,argv[11],&size_boneIds)==-1){
				return JS_EXCEPTION;
			}
			boneIds =(unsigned char *)js_malloc(ctx,size_boneIds*sizeof(unsigned char));
			int i;
			for(i=0;i<size_boneIds;i++){
				JSValue js_boneIds=JS_GetPropertyUint32(ctx,argv[11],(uint32_t)i);
				uint32_t long_boneIdsi;
				int err_boneIdsi=JS_ToUint32(ctx,&long_boneIdsi,js_boneIds);
				if(err_boneIdsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_boneIds is not numeric");
					return JS_EXCEPTION;
				}
				boneIds[i] =((unsigned char)long_boneIdsi);
				JS_FreeValue(ctx,js_boneIds);
			}
		}else if(JS_IsArrayBuffer(argv[11])==1){
			boneIds =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_boneIds,argv[11]);
		}else{
			JSClassID classid_boneIds=JS_GetClassID(argv[11]);
			if(classid_boneIds==JS_CLASS_UINT8_ARRAY||classid_boneIds==JS_CLASS_UINT8C_ARRAY){
				size_t offset_boneIds;
				da_boneIds =JS_GetTypedArrayBuffer(ctx,argv[11],&offset_boneIds,(size_t *)&size_boneIds,NULL);
				boneIds =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_boneIds,da_boneIds);
				boneIds +=offset_boneIds;
				size_boneIds -=offset_boneIds;
			}else{
				if(freesrc_boneIds){
					JS_FreeValue(ctx,argv[11]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[11] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		float * boneWeights;
		bool freesrc_boneWeights=(bool)false;
		JSValue da_boneWeights;
		int64_t size_boneWeights;
		JSClassID boneWeights_class=JS_GetClassID(argv[12]);
		if(boneWeights_class==js_ArrayProxy_class_id){
			void * opaque_boneWeights=JS_GetOpaque(argv[12],js_ArrayProxy_class_id);
			ArrayProxy_class AP_boneWeights=((ArrayProxy_class *)opaque_boneWeights)[0];
			argv[12] =AP_boneWeights.values(ctx,AP_boneWeights.opaque,(int)0,(bool)false);
			freesrc_boneWeights =(bool)true;
		}
		if(JS_IsArray(argv[12])==1){
			if(JS_GetLength(ctx,argv[12],&size_boneWeights)==-1){
				return JS_EXCEPTION;
			}
			boneWeights =(float *)js_malloc(ctx,size_boneWeights*sizeof(float));
			int i;
			for(i=0;i<size_boneWeights;i++){
				JSValue js_boneWeights=JS_GetPropertyUint32(ctx,argv[12],(uint32_t)i);
				double double_boneWeightsi;
				int err_boneWeightsi=JS_ToFloat64(ctx,&double_boneWeightsi,js_boneWeights);
				if(err_boneWeightsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_boneWeights is not numeric");
					return JS_EXCEPTION;
				}
				boneWeights[i] =((float)double_boneWeightsi);
				JS_FreeValue(ctx,js_boneWeights);
			}
		}else if(JS_IsArrayBuffer(argv[12])==1){
			boneWeights =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_boneWeights,argv[12]);
		}else{
			JSClassID classid_boneWeights=JS_GetClassID(argv[12]);
			if(classid_boneWeights==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_boneWeights;
				da_boneWeights =JS_GetTypedArrayBuffer(ctx,argv[12],&offset_boneWeights,(size_t *)&size_boneWeights,NULL);
				boneWeights =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_boneWeights,da_boneWeights);
				boneWeights +=offset_boneWeights;
				size_boneWeights -=offset_boneWeights;
			}else{
				if(freesrc_boneWeights){
					JS_FreeValue(ctx,argv[12]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[12] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		Matrix * boneMatrices;
		bool freesrc_boneMatrices=(bool)false;
		int64_t size_boneMatrices;
		JSClassID boneMatrices_class=JS_GetClassID(argv[13]);
		if(boneMatrices_class==js_ArrayProxy_class_id){
			void * opaque_boneMatrices=JS_GetOpaque(argv[13],js_ArrayProxy_class_id);
			ArrayProxy_class AP_boneMatrices=((ArrayProxy_class *)opaque_boneMatrices)[0];
			argv[13] =AP_boneMatrices.values(ctx,AP_boneMatrices.opaque,(int)0,(bool)false);
			freesrc_boneMatrices =(bool)true;
		}
		if(JS_IsArray(argv[13])==1){
			if(JS_GetLength(ctx,argv[13],&size_boneMatrices)==-1){
				return JS_EXCEPTION;
			}
			boneMatrices =(Matrix *)js_malloc(ctx,size_boneMatrices*sizeof(Matrix));
			int i;
			for(i=0;i<size_boneMatrices;i++){
				JSValue js_boneMatrices=JS_GetPropertyUint32(ctx,argv[13],(uint32_t)i);
				Matrix * ptr_boneMatricesi=(Matrix *)JS_GetOpaque(js_boneMatrices,js_Matrix_class_id);
				if(ptr_boneMatricesi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_boneMatrices does not allow null");
					return JS_EXCEPTION;
				}
				boneMatrices[i] =*ptr_boneMatricesi;
				JS_FreeValue(ctx,js_boneMatrices);
			}
		}else if(JS_IsArrayBuffer(argv[13])==1){
			boneMatrices =(Matrix *)JS_GetArrayBuffer(ctx,(size_t *)&size_boneMatrices,argv[13]);
		}else{
			if(freesrc_boneMatrices){
				JS_FreeValue(ctx,argv[13]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[13] does not match type Matrix *");
			return JS_EXCEPTION;
		}
		int32_t long_boneCount;
		int err_boneCount=JS_ToInt32(ctx,&long_boneCount,argv[14]);
		if(err_boneCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[14] is not numeric");
			return JS_EXCEPTION;
		}
		int boneCount=((int)long_boneCount);
		uint32_t long_vaoId;
		int err_vaoId=JS_ToUint32(ctx,&long_vaoId,argv[15]);
		if(err_vaoId<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[15] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int vaoId=((unsigned int)long_vaoId);
		unsigned int * vboId;
		bool freesrc_vboId=(bool)false;
		JSValue da_vboId;
		int64_t size_vboId;
		JSClassID vboId_class=JS_GetClassID(argv[16]);
		if(vboId_class==js_ArrayProxy_class_id){
			void * opaque_vboId=JS_GetOpaque(argv[16],js_ArrayProxy_class_id);
			ArrayProxy_class AP_vboId=((ArrayProxy_class *)opaque_vboId)[0];
			argv[16] =AP_vboId.values(ctx,AP_vboId.opaque,(int)0,(bool)false);
			freesrc_vboId =(bool)true;
		}
		if(JS_IsArray(argv[16])==1){
			if(JS_GetLength(ctx,argv[16],&size_vboId)==-1){
				return JS_EXCEPTION;
			}
			vboId =(unsigned int *)js_malloc(ctx,size_vboId*sizeof(unsigned int));
			int i;
			for(i=0;i<size_vboId;i++){
				JSValue js_vboId=JS_GetPropertyUint32(ctx,argv[16],(uint32_t)i);
				uint32_t long_vboIdi;
				int err_vboIdi=JS_ToUint32(ctx,&long_vboIdi,js_vboId);
				if(err_vboIdi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_vboId is not numeric");
					return JS_EXCEPTION;
				}
				vboId[i] =((unsigned int)long_vboIdi);
				JS_FreeValue(ctx,js_vboId);
			}
		}else if(JS_IsArrayBuffer(argv[16])==1){
			vboId =(unsigned int *)JS_GetArrayBuffer(ctx,(size_t *)&size_vboId,argv[16]);
		}else{
			JSClassID classid_vboId=JS_GetClassID(argv[16]);
			if(classid_vboId==JS_CLASS_UINT16_ARRAY){
				size_t offset_vboId;
				da_vboId =JS_GetTypedArrayBuffer(ctx,argv[16],&offset_vboId,(size_t *)&size_vboId,NULL);
				vboId =(unsigned int *)JS_GetArrayBuffer(ctx,(size_t *)&size_vboId,da_vboId);
				vboId +=offset_vboId;
				size_vboId -=offset_vboId;
			}else{
				if(freesrc_vboId){
					JS_FreeValue(ctx,argv[16]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[16] does not match type unsigned int *");
				return JS_EXCEPTION;
			}
		}
		Mesh _struct={
			vertexCount,
			triangleCount,
			vertices,
			texcoords,
			texcoords2,
			normals,
			tangents,
			colors,
			indices,
			animVertices,
			animNormals,
			boneIds,
			boneWeights,
			boneMatrices,
			boneCount,
			vaoId,
			vboId
		};
		Mesh * ptr__return=(Mesh *)js_malloc(ctx,sizeof(Mesh));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Shader_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Shader * ptr__return=(Shader *)js_calloc(ctx,(size_t)1,sizeof(Shader));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Shader_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		uint32_t long_id;
		int err_id=JS_ToUint32(ctx,&long_id,argv[0]);
		if(err_id<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int id=((unsigned int)long_id);
		int * locs;
		bool freesrc_locs=(bool)false;
		JSValue da_locs;
		int64_t size_locs;
		JSClassID locs_class=JS_GetClassID(argv[1]);
		if(locs_class==js_ArrayProxy_class_id){
			void * opaque_locs=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_locs=((ArrayProxy_class *)opaque_locs)[0];
			argv[1] =AP_locs.values(ctx,AP_locs.opaque,(int)0,(bool)false);
			freesrc_locs =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_locs)==-1){
				return JS_EXCEPTION;
			}
			locs =(int *)js_malloc(ctx,size_locs*sizeof(int));
			int i;
			for(i=0;i<size_locs;i++){
				JSValue js_locs=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_locsi;
				int err_locsi=JS_ToInt32(ctx,&long_locsi,js_locs);
				if(err_locsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_locs is not numeric");
					return JS_EXCEPTION;
				}
				locs[i] =((int)long_locsi);
				JS_FreeValue(ctx,js_locs);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			locs =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_locs,argv[1]);
		}else{
			JSClassID classid_locs=JS_GetClassID(argv[1]);
			if(classid_locs==JS_CLASS_INT16_ARRAY){
				size_t offset_locs;
				da_locs =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_locs,(size_t *)&size_locs,NULL);
				locs =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_locs,da_locs);
				locs +=offset_locs;
				size_locs -=offset_locs;
			}else{
				if(freesrc_locs){
					JS_FreeValue(ctx,argv[1]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		Shader _struct={
			id,
			locs
		};
		Shader * ptr__return=(Shader *)js_malloc(ctx,sizeof(Shader));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Shader_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_MaterialMap_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			MaterialMap * ptr__return=(MaterialMap *)js_calloc(ctx,(size_t)1,sizeof(MaterialMap));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,argv[2]);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		MaterialMap _struct={
			texture,
			color,
			value
		};
		MaterialMap * ptr__return=(MaterialMap *)js_malloc(ctx,sizeof(MaterialMap));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_MaterialMap_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Material_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Material * ptr__return=(Material *)js_calloc(ctx,(size_t)1,sizeof(Material));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Material_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		Shader * ptr_shader=(Shader *)JS_GetOpaque(argv[0],js_Shader_class_id);
		if(ptr_shader==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Shader shader=*ptr_shader;
		MaterialMap * maps;
		bool freesrc_maps=(bool)false;
		int64_t size_maps;
		JSClassID maps_class=JS_GetClassID(argv[1]);
		if(maps_class==js_ArrayProxy_class_id){
			void * opaque_maps=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_maps=((ArrayProxy_class *)opaque_maps)[0];
			argv[1] =AP_maps.values(ctx,AP_maps.opaque,(int)0,(bool)false);
			freesrc_maps =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_maps)==-1){
				return JS_EXCEPTION;
			}
			maps =(MaterialMap *)js_malloc(ctx,size_maps*sizeof(MaterialMap));
			int i;
			for(i=0;i<size_maps;i++){
				JSValue js_maps=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				MaterialMap * ptr_mapsi=(MaterialMap *)JS_GetOpaque(js_maps,js_MaterialMap_class_id);
				if(ptr_mapsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_maps does not allow null");
					return JS_EXCEPTION;
				}
				maps[i] =*ptr_mapsi;
				JS_FreeValue(ctx,js_maps);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			maps =(MaterialMap *)JS_GetArrayBuffer(ctx,(size_t *)&size_maps,argv[1]);
		}else{
			if(freesrc_maps){
				JS_FreeValue(ctx,argv[1]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type MaterialMap *");
			return JS_EXCEPTION;
		}
		float * params;
		bool freesrc_params=(bool)false;
		JSValue da_params;
		int64_t size_params;
		JSClassID params_class=JS_GetClassID(argv[2]);
		if(params_class==js_ArrayProxy_class_id){
			void * opaque_params=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_params=((ArrayProxy_class *)opaque_params)[0];
			argv[2] =AP_params.values(ctx,AP_params.opaque,(int)0,(bool)false);
			freesrc_params =(bool)true;
		}
		if(JS_IsArray(argv[2])==1){
			params =(float *)js_malloc(ctx,4*sizeof(float));
			int i;
			for(i=0;i<4;i++){
				JSValue js_params=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				double double_paramsi;
				int err_paramsi=JS_ToFloat64(ctx,&double_paramsi,js_params);
				if(err_paramsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_params is not numeric");
					return JS_EXCEPTION;
				}
				params[i] =((float)double_paramsi);
				JS_FreeValue(ctx,js_params);
			}
		}else if(JS_IsArrayBuffer(argv[2])==1){
			params =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_params,argv[2]);
		}else{
			JSClassID classid_params=JS_GetClassID(argv[2]);
			if(classid_params==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_params;
				da_params =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_params,(size_t *)&size_params,NULL);
				params =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_params,da_params);
				params +=offset_params;
				size_params -=offset_params;
			}else{
				if(freesrc_params){
					JS_FreeValue(ctx,argv[2]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		Material _struct={
			shader,
			maps,
			{params[0],params[1],params[2],params[3]}
		};
		Material * ptr__return=(Material *)js_malloc(ctx,sizeof(Material));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Material_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Transform_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Transform * ptr__return=(Transform *)js_calloc(ctx,(size_t)1,sizeof(Transform));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Transform_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		Vector3 * ptr_translation=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_translation==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 translation=*ptr_translation;
		Quaternion * ptr_rotation=(Quaternion *)JS_GetOpaque(argv[1],js_Vector4_class_id);
		if(ptr_rotation==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Quaternion rotation=*ptr_rotation;
		Vector3 * ptr_scale=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_scale==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 scale=*ptr_scale;
		Transform _struct={
			translation,
			rotation,
			scale
		};
		Transform * ptr__return=(Transform *)js_malloc(ctx,sizeof(Transform));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Transform_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_BoneInfo_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			BoneInfo * ptr__return=(BoneInfo *)js_calloc(ctx,(size_t)1,sizeof(BoneInfo));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_BoneInfo_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		char * name;
		JSValue da_name;
		int64_t size_name;
		if(JS_IsString(argv[0])==1){
			name =(char *)JS_ToCStringLen(ctx,(size_t *)&size_name,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			name =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_name,argv[0]);
		}else{
			JSClassID classid_name=JS_GetClassID(argv[0]);
			if(classid_name==JS_CLASS_INT8_ARRAY){
				size_t offset_name;
				da_name =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_name,(size_t *)&size_name,NULL);
				name =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_name,da_name);
				name +=offset_name;
				size_name -=offset_name;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_parent;
		int err_parent=JS_ToInt32(ctx,&long_parent,argv[1]);
		if(err_parent<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int parent=((int)long_parent);
		BoneInfo _struct={
			{name[0],name[1],name[2],name[3],name[4],name[5],name[6],name[7],name[8],name[9],name[10],name[11],name[12],name[13],name[14],name[15],name[16],name[17],name[18],name[19],name[20],name[21],name[22],name[23],name[24],name[25],name[26],name[27],name[28],name[29],name[30],name[31]},
			parent
		};
		BoneInfo * ptr__return=(BoneInfo *)js_malloc(ctx,sizeof(BoneInfo));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_BoneInfo_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Model_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Model * ptr__return=(Model *)js_calloc(ctx,(size_t)1,sizeof(Model));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Model_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		Matrix * ptr_transform=(Matrix *)JS_GetOpaque(argv[0],js_Matrix_class_id);
		if(ptr_transform==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Matrix transform=*ptr_transform;
		int32_t long_meshCount;
		int err_meshCount=JS_ToInt32(ctx,&long_meshCount,argv[1]);
		if(err_meshCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int meshCount=((int)long_meshCount);
		int32_t long_materialCount;
		int err_materialCount=JS_ToInt32(ctx,&long_materialCount,argv[2]);
		if(err_materialCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int materialCount=((int)long_materialCount);
		Mesh * meshes;
		bool freesrc_meshes=(bool)false;
		int64_t size_meshes;
		JSClassID meshes_class=JS_GetClassID(argv[3]);
		if(meshes_class==js_ArrayProxy_class_id){
			void * opaque_meshes=JS_GetOpaque(argv[3],js_ArrayProxy_class_id);
			ArrayProxy_class AP_meshes=((ArrayProxy_class *)opaque_meshes)[0];
			argv[3] =AP_meshes.values(ctx,AP_meshes.opaque,(int)0,(bool)false);
			freesrc_meshes =(bool)true;
		}
		if(JS_IsArray(argv[3])==1){
			if(JS_GetLength(ctx,argv[3],&size_meshes)==-1){
				return JS_EXCEPTION;
			}
			meshes =(Mesh *)js_malloc(ctx,size_meshes*sizeof(Mesh));
			int i;
			for(i=0;i<size_meshes;i++){
				JSValue js_meshes=JS_GetPropertyUint32(ctx,argv[3],(uint32_t)i);
				Mesh * ptr_meshesi=(Mesh *)JS_GetOpaque(js_meshes,js_Mesh_class_id);
				if(ptr_meshesi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_meshes does not allow null");
					return JS_EXCEPTION;
				}
				meshes[i] =*ptr_meshesi;
				JS_FreeValue(ctx,js_meshes);
			}
		}else if(JS_IsArrayBuffer(argv[3])==1){
			meshes =(Mesh *)JS_GetArrayBuffer(ctx,(size_t *)&size_meshes,argv[3]);
		}else{
			if(freesrc_meshes){
				JS_FreeValue(ctx,argv[3]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not match type Mesh *");
			return JS_EXCEPTION;
		}
		Material * materials;
		bool freesrc_materials=(bool)false;
		int64_t size_materials;
		JSClassID materials_class=JS_GetClassID(argv[4]);
		if(materials_class==js_ArrayProxy_class_id){
			void * opaque_materials=JS_GetOpaque(argv[4],js_ArrayProxy_class_id);
			ArrayProxy_class AP_materials=((ArrayProxy_class *)opaque_materials)[0];
			argv[4] =AP_materials.values(ctx,AP_materials.opaque,(int)0,(bool)false);
			freesrc_materials =(bool)true;
		}
		if(JS_IsArray(argv[4])==1){
			if(JS_GetLength(ctx,argv[4],&size_materials)==-1){
				return JS_EXCEPTION;
			}
			materials =(Material *)js_malloc(ctx,size_materials*sizeof(Material));
			int i;
			for(i=0;i<size_materials;i++){
				JSValue js_materials=JS_GetPropertyUint32(ctx,argv[4],(uint32_t)i);
				Material * ptr_materialsi=(Material *)JS_GetOpaque(js_materials,js_Material_class_id);
				if(ptr_materialsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_materials does not allow null");
					return JS_EXCEPTION;
				}
				materials[i] =*ptr_materialsi;
				JS_FreeValue(ctx,js_materials);
			}
		}else if(JS_IsArrayBuffer(argv[4])==1){
			materials =(Material *)JS_GetArrayBuffer(ctx,(size_t *)&size_materials,argv[4]);
		}else{
			if(freesrc_materials){
				JS_FreeValue(ctx,argv[4]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not match type Material *");
			return JS_EXCEPTION;
		}
		int * meshMaterial;
		bool freesrc_meshMaterial=(bool)false;
		JSValue da_meshMaterial;
		int64_t size_meshMaterial;
		JSClassID meshMaterial_class=JS_GetClassID(argv[5]);
		if(meshMaterial_class==js_ArrayProxy_class_id){
			void * opaque_meshMaterial=JS_GetOpaque(argv[5],js_ArrayProxy_class_id);
			ArrayProxy_class AP_meshMaterial=((ArrayProxy_class *)opaque_meshMaterial)[0];
			argv[5] =AP_meshMaterial.values(ctx,AP_meshMaterial.opaque,(int)0,(bool)false);
			freesrc_meshMaterial =(bool)true;
		}
		if(JS_IsArray(argv[5])==1){
			if(JS_GetLength(ctx,argv[5],&size_meshMaterial)==-1){
				return JS_EXCEPTION;
			}
			meshMaterial =(int *)js_malloc(ctx,size_meshMaterial*sizeof(int));
			int i;
			for(i=0;i<size_meshMaterial;i++){
				JSValue js_meshMaterial=JS_GetPropertyUint32(ctx,argv[5],(uint32_t)i);
				int32_t long_meshMateriali;
				int err_meshMateriali=JS_ToInt32(ctx,&long_meshMateriali,js_meshMaterial);
				if(err_meshMateriali<0){
					JS_ThrowTypeError(ctx,(const char *)"js_meshMaterial is not numeric");
					return JS_EXCEPTION;
				}
				meshMaterial[i] =((int)long_meshMateriali);
				JS_FreeValue(ctx,js_meshMaterial);
			}
		}else if(JS_IsArrayBuffer(argv[5])==1){
			meshMaterial =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_meshMaterial,argv[5]);
		}else{
			JSClassID classid_meshMaterial=JS_GetClassID(argv[5]);
			if(classid_meshMaterial==JS_CLASS_INT16_ARRAY){
				size_t offset_meshMaterial;
				da_meshMaterial =JS_GetTypedArrayBuffer(ctx,argv[5],&offset_meshMaterial,(size_t *)&size_meshMaterial,NULL);
				meshMaterial =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_meshMaterial,da_meshMaterial);
				meshMaterial +=offset_meshMaterial;
				size_meshMaterial -=offset_meshMaterial;
			}else{
				if(freesrc_meshMaterial){
					JS_FreeValue(ctx,argv[5]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[5] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_boneCount;
		int err_boneCount=JS_ToInt32(ctx,&long_boneCount,argv[6]);
		if(err_boneCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[6] is not numeric");
			return JS_EXCEPTION;
		}
		int boneCount=((int)long_boneCount);
		BoneInfo * bones;
		bool freesrc_bones=(bool)false;
		int64_t size_bones;
		JSClassID bones_class=JS_GetClassID(argv[7]);
		if(bones_class==js_ArrayProxy_class_id){
			void * opaque_bones=JS_GetOpaque(argv[7],js_ArrayProxy_class_id);
			ArrayProxy_class AP_bones=((ArrayProxy_class *)opaque_bones)[0];
			argv[7] =AP_bones.values(ctx,AP_bones.opaque,(int)0,(bool)false);
			freesrc_bones =(bool)true;
		}
		if(JS_IsArray(argv[7])==1){
			if(JS_GetLength(ctx,argv[7],&size_bones)==-1){
				return JS_EXCEPTION;
			}
			bones =(BoneInfo *)js_malloc(ctx,size_bones*sizeof(BoneInfo));
			int i;
			for(i=0;i<size_bones;i++){
				JSValue js_bones=JS_GetPropertyUint32(ctx,argv[7],(uint32_t)i);
				BoneInfo * ptr_bonesi=(BoneInfo *)JS_GetOpaque(js_bones,js_BoneInfo_class_id);
				if(ptr_bonesi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_bones does not allow null");
					return JS_EXCEPTION;
				}
				bones[i] =*ptr_bonesi;
				JS_FreeValue(ctx,js_bones);
			}
		}else if(JS_IsArrayBuffer(argv[7])==1){
			bones =(BoneInfo *)JS_GetArrayBuffer(ctx,(size_t *)&size_bones,argv[7]);
		}else{
			if(freesrc_bones){
				JS_FreeValue(ctx,argv[7]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[7] does not match type BoneInfo *");
			return JS_EXCEPTION;
		}
		Transform * bindPose;
		bool freesrc_bindPose=(bool)false;
		int64_t size_bindPose;
		JSClassID bindPose_class=JS_GetClassID(argv[8]);
		if(bindPose_class==js_ArrayProxy_class_id){
			void * opaque_bindPose=JS_GetOpaque(argv[8],js_ArrayProxy_class_id);
			ArrayProxy_class AP_bindPose=((ArrayProxy_class *)opaque_bindPose)[0];
			argv[8] =AP_bindPose.values(ctx,AP_bindPose.opaque,(int)0,(bool)false);
			freesrc_bindPose =(bool)true;
		}
		if(JS_IsArray(argv[8])==1){
			if(JS_GetLength(ctx,argv[8],&size_bindPose)==-1){
				return JS_EXCEPTION;
			}
			bindPose =(Transform *)js_malloc(ctx,size_bindPose*sizeof(Transform));
			int i;
			for(i=0;i<size_bindPose;i++){
				JSValue js_bindPose=JS_GetPropertyUint32(ctx,argv[8],(uint32_t)i);
				Transform * ptr_bindPosei=(Transform *)JS_GetOpaque(js_bindPose,js_Transform_class_id);
				if(ptr_bindPosei==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_bindPose does not allow null");
					return JS_EXCEPTION;
				}
				bindPose[i] =*ptr_bindPosei;
				JS_FreeValue(ctx,js_bindPose);
			}
		}else if(JS_IsArrayBuffer(argv[8])==1){
			bindPose =(Transform *)JS_GetArrayBuffer(ctx,(size_t *)&size_bindPose,argv[8]);
		}else{
			if(freesrc_bindPose){
				JS_FreeValue(ctx,argv[8]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[8] does not match type Transform *");
			return JS_EXCEPTION;
		}
		Model _struct={
			transform,
			meshCount,
			materialCount,
			meshes,
			materials,
			meshMaterial,
			boneCount,
			bones,
			bindPose
		};
		Model * ptr__return=(Model *)js_malloc(ctx,sizeof(Model));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Model_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_ModelAnimation_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			ModelAnimation * ptr__return=(ModelAnimation *)js_calloc(ctx,(size_t)1,sizeof(ModelAnimation));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_ModelAnimation_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		int32_t long_boneCount;
		int err_boneCount=JS_ToInt32(ctx,&long_boneCount,argv[0]);
		if(err_boneCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int boneCount=((int)long_boneCount);
		int32_t long_frameCount;
		int err_frameCount=JS_ToInt32(ctx,&long_frameCount,argv[1]);
		if(err_frameCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int frameCount=((int)long_frameCount);
		BoneInfo * bones;
		int64_t size_bones;
		JSClassID bones_class=JS_GetClassID(argv[2]);
		if(bones_class==js_ArrayProxy_class_id){
			void * opaque_bones=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_bones=((ArrayProxy_class *)opaque_bones)[0];
			argv[2] =AP_bones.values(ctx,AP_bones.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[2]);
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_bones)==-1){
				return JS_EXCEPTION;
			}
			bones =(BoneInfo *)js_malloc(ctx,size_bones*sizeof(BoneInfo));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)bones);
			int i;
			for(i=0;i<size_bones;i++){
				JSValue js_bones=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				BoneInfo * ptr_bonesi=(BoneInfo *)JS_GetOpaque(js_bones,js_BoneInfo_class_id);
				if(ptr_bonesi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_bones does not allow null");
					return JS_EXCEPTION;
				}
				bones[i] =*ptr_bonesi;
				JS_FreeValue(ctx,js_bones);
			}
		}else if(JS_IsArrayBuffer(argv[2])==1){
			bones =(BoneInfo *)JS_GetArrayBuffer(ctx,(size_t *)&size_bones,argv[2]);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type BoneInfo *");
			return JS_EXCEPTION;
		}
		Transform * * framePoses;
		int64_t size_framePoses;
		JSClassID framePoses_class=JS_GetClassID(argv[3]);
		if(framePoses_class==js_ArrayProxy_class_id){
			void * opaque_framePoses=JS_GetOpaque(argv[3],js_ArrayProxy_class_id);
			ArrayProxy_class AP_framePoses=((ArrayProxy_class *)opaque_framePoses)[0];
			argv[3] =AP_framePoses.values(ctx,AP_framePoses.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[3]);
		}
		if(JS_IsArray(argv[3])==1){
			if(JS_GetLength(ctx,argv[3],&size_framePoses)==-1){
				return JS_EXCEPTION;
			}
			framePoses =(Transform * *)js_malloc(ctx,size_framePoses*sizeof(Transform *));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)*framePoses);
			int i;
			for(i=0;i<size_framePoses;i++){
				JSValue js_framePoses=JS_GetPropertyUint32(ctx,argv[3],(uint32_t)i);
				int64_t size_framePosesi;
				JSClassID framePosesi_class=JS_GetClassID(js_framePoses);
				if(framePosesi_class==js_ArrayProxy_class_id){
					void * opaque_framePosesi=JS_GetOpaque(js_framePoses,js_ArrayProxy_class_id);
					ArrayProxy_class AP_framePosesi=((ArrayProxy_class *)opaque_framePosesi)[0];
					js_framePoses =AP_framePosesi.values(ctx,AP_framePosesi.opaque,(int)0,(bool)false);
					memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&js_framePoses);
				}
				if(JS_IsArray(js_framePoses)==1){
					if(JS_GetLength(ctx,js_framePoses,&size_framePosesi)==-1){
						return JS_EXCEPTION;
					}
					framePoses[i] =(Transform *)js_malloc(ctx,size_framePosesi*sizeof(Transform));
					memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)framePoses[i]);
					int i0;
					for(i0=0;i0<size_framePosesi;i0++){
						JSValue js_framePosesi=JS_GetPropertyUint32(ctx,js_framePoses,(uint32_t)i0);
						Transform * ptr_framePosesii0=(Transform *)JS_GetOpaque(js_framePosesi,js_Transform_class_id);
						if(ptr_framePosesii0==NULL){
							JS_ThrowTypeError(ctx,(const char *)"js_framePosesi does not allow null");
							return JS_EXCEPTION;
						}
						framePoses[i][i0] =*ptr_framePosesii0;
						JS_FreeValue(ctx,js_framePosesi);
					}
				}else if(JS_IsArrayBuffer(js_framePoses)==1){
					framePoses[i] =(Transform *)JS_GetArrayBuffer(ctx,(size_t *)&size_framePosesi,js_framePoses);
				}else{
					JS_ThrowTypeError(ctx,(const char *)"js_framePoses does not match type Transform *");
					return JS_EXCEPTION;
				}
				JS_FreeValue(ctx,js_framePoses);
			}
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not match type Transform * *");
			return JS_EXCEPTION;
		}
		char * name;
		int64_t size_name;
		if(JS_IsString(argv[4])==1){
			name =(char *)JS_ToCStringLen(ctx,(size_t *)&size_name,argv[4]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)name);
		}else if(JS_IsArrayBuffer(argv[4])==1){
			name =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_name,argv[4]);
		}else{
			JSClassID classid_name=JS_GetClassID(argv[4]);
			if(classid_name==JS_CLASS_INT8_ARRAY){
				size_t offset_name;
				JSValue da_name=JS_GetTypedArrayBuffer(ctx,argv[4],&offset_name,(size_t *)&size_name,NULL);
				name =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_name,da_name);
				name +=offset_name;
				size_name -=offset_name;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_name);
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[4] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		ModelAnimation _struct={
			boneCount,
			frameCount,
			bones,
			framePoses,
			{name[0],name[1],name[2],name[3],name[4],name[5],name[6],name[7],name[8],name[9],name[10],name[11],name[12],name[13],name[14],name[15],name[16],name[17],name[18],name[19],name[20],name[21],name[22],name[23],name[24],name[25],name[26],name[27],name[28],name[29],name[30],name[31]}
		};
		ModelAnimation * ptr__return=(ModelAnimation *)js_malloc(ctx,sizeof(ModelAnimation));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_ModelAnimation_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Ray_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Ray * ptr__return=(Ray *)js_calloc(ctx,(size_t)1,sizeof(Ray));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Ray_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		Vector3 * ptr_direction=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_direction==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 direction=*ptr_direction;
		Ray _struct={
			position,
			direction
		};
		Ray * ptr__return=(Ray *)js_malloc(ctx,sizeof(Ray));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Ray_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_RayCollision_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			RayCollision * ptr__return=(RayCollision *)js_calloc(ctx,(size_t)1,sizeof(RayCollision));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_RayCollision_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		int js_hit=JS_ToBool(ctx,argv[0]);
		if(js_hit<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not a bool");
			return JS_EXCEPTION;
		}
		bool hit=(bool)js_hit;
		double double_distance;
		int err_distance=JS_ToFloat64(ctx,&double_distance,argv[1]);
		if(err_distance<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float distance=((float)double_distance);
		Vector3 * ptr_point=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_point==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 point=*ptr_point;
		Vector3 * ptr_normal=(Vector3 *)JS_GetOpaque(argv[3],js_Vector3_class_id);
		if(ptr_normal==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 normal=*ptr_normal;
		RayCollision _struct={
			hit,
			distance,
			point,
			normal
		};
		RayCollision * ptr__return=(RayCollision *)js_malloc(ctx,sizeof(RayCollision));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_RayCollision_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_BoundingBox_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			BoundingBox * ptr__return=(BoundingBox *)js_calloc(ctx,(size_t)1,sizeof(BoundingBox));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_BoundingBox_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		Vector3 * ptr_min=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_min==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 min=*ptr_min;
		Vector3 * ptr_max=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_max==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 max=*ptr_max;
		BoundingBox _struct={
			min,
			max
		};
		BoundingBox * ptr__return=(BoundingBox *)js_malloc(ctx,sizeof(BoundingBox));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_BoundingBox_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Wave_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Wave * ptr__return=(Wave *)js_calloc(ctx,(size_t)1,sizeof(Wave));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Wave_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		uint32_t long_frameCount;
		int err_frameCount=JS_ToUint32(ctx,&long_frameCount,argv[0]);
		if(err_frameCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int frameCount=((unsigned int)long_frameCount);
		uint32_t long_sampleRate;
		int err_sampleRate=JS_ToUint32(ctx,&long_sampleRate,argv[1]);
		if(err_sampleRate<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int sampleRate=((unsigned int)long_sampleRate);
		uint32_t long_sampleSize;
		int err_sampleSize=JS_ToUint32(ctx,&long_sampleSize,argv[2]);
		if(err_sampleSize<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int sampleSize=((unsigned int)long_sampleSize);
		uint32_t long_channels;
		int err_channels=JS_ToUint32(ctx,&long_channels,argv[3]);
		if(err_channels<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int channels=((unsigned int)long_channels);
		void * data;
		int64_t size_data;
		if(JS_IsArrayBuffer(argv[4])==1){
			data =(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[4]);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not match type void *");
			return JS_EXCEPTION;
		}
		Wave _struct={
			frameCount,
			sampleRate,
			sampleSize,
			channels,
			data
		};
		Wave * ptr__return=(Wave *)js_malloc(ctx,sizeof(Wave));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Wave_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_AudioStream_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			AudioStream * ptr__return=(AudioStream *)js_calloc(ctx,(size_t)1,sizeof(AudioStream));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_AudioStream_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		rAudioBuffer * buffer=(rAudioBuffer *)JS_GetOpaque(argv[0],js_rAudioBuffer_class_id);
		if(buffer==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type rAudioBuffer");
			return JS_EXCEPTION;
		}
		rAudioProcessor * processor=(rAudioProcessor *)JS_GetOpaque(argv[1],js_rAudioProcessor_class_id);
		if(processor==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type rAudioProcessor");
			return JS_EXCEPTION;
		}
		uint32_t long_sampleRate;
		int err_sampleRate=JS_ToUint32(ctx,&long_sampleRate,argv[2]);
		if(err_sampleRate<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int sampleRate=((unsigned int)long_sampleRate);
		uint32_t long_sampleSize;
		int err_sampleSize=JS_ToUint32(ctx,&long_sampleSize,argv[3]);
		if(err_sampleSize<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int sampleSize=((unsigned int)long_sampleSize);
		uint32_t long_channels;
		int err_channels=JS_ToUint32(ctx,&long_channels,argv[4]);
		if(err_channels<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int channels=((unsigned int)long_channels);
		AudioStream _struct={
			buffer,
			processor,
			sampleRate,
			sampleSize,
			channels
		};
		AudioStream * ptr__return=(AudioStream *)js_malloc(ctx,sizeof(AudioStream));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_AudioStream_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Sound_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Sound * ptr__return=(Sound *)js_calloc(ctx,(size_t)1,sizeof(Sound));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Sound_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		uint32_t long_frameCount;
		int err_frameCount=JS_ToUint32(ctx,&long_frameCount,argv[1]);
		if(err_frameCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int frameCount=((unsigned int)long_frameCount);
		Sound _struct={
			stream,
			frameCount
		};
		Sound * ptr__return=(Sound *)js_malloc(ctx,sizeof(Sound));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Sound_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_Music_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			Music * ptr__return=(Music *)js_calloc(ctx,(size_t)1,sizeof(Music));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_Music_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		uint32_t long_frameCount;
		int err_frameCount=JS_ToUint32(ctx,&long_frameCount,argv[1]);
		if(err_frameCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int frameCount=((unsigned int)long_frameCount);
		int js_looping=JS_ToBool(ctx,argv[2]);
		if(js_looping<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not a bool");
			return JS_EXCEPTION;
		}
		bool looping=(bool)js_looping;
		int32_t long_ctxType;
		int err_ctxType=JS_ToInt32(ctx,&long_ctxType,argv[3]);
		if(err_ctxType<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int ctxType=((int)long_ctxType);
		void * ctxData;
		int64_t size_ctxData;
		if(JS_IsArrayBuffer(argv[4])==1){
			ctxData =(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_ctxData,argv[4]);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not match type void *");
			return JS_EXCEPTION;
		}
		Music _struct={
			stream,
			frameCount,
			looping,
			ctxType,
			ctxData
		};
		Music * ptr__return=(Music *)js_malloc(ctx,sizeof(Music));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_Music_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_VrDeviceInfo_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			VrDeviceInfo * ptr__return=(VrDeviceInfo *)js_calloc(ctx,(size_t)1,sizeof(VrDeviceInfo));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_VrDeviceInfo_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		int32_t long_hResolution;
		int err_hResolution=JS_ToInt32(ctx,&long_hResolution,argv[0]);
		if(err_hResolution<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int hResolution=((int)long_hResolution);
		int32_t long_vResolution;
		int err_vResolution=JS_ToInt32(ctx,&long_vResolution,argv[1]);
		if(err_vResolution<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int vResolution=((int)long_vResolution);
		double double_hScreenSize;
		int err_hScreenSize=JS_ToFloat64(ctx,&double_hScreenSize,argv[2]);
		if(err_hScreenSize<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float hScreenSize=((float)double_hScreenSize);
		double double_vScreenSize;
		int err_vScreenSize=JS_ToFloat64(ctx,&double_vScreenSize,argv[3]);
		if(err_vScreenSize<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float vScreenSize=((float)double_vScreenSize);
		double double_eyeToScreenDistance;
		int err_eyeToScreenDistance=JS_ToFloat64(ctx,&double_eyeToScreenDistance,argv[4]);
		if(err_eyeToScreenDistance<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float eyeToScreenDistance=((float)double_eyeToScreenDistance);
		double double_lensSeparationDistance;
		int err_lensSeparationDistance=JS_ToFloat64(ctx,&double_lensSeparationDistance,argv[5]);
		if(err_lensSeparationDistance<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] is not numeric");
			return JS_EXCEPTION;
		}
		float lensSeparationDistance=((float)double_lensSeparationDistance);
		double double_interpupillaryDistance;
		int err_interpupillaryDistance=JS_ToFloat64(ctx,&double_interpupillaryDistance,argv[6]);
		if(err_interpupillaryDistance<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[6] is not numeric");
			return JS_EXCEPTION;
		}
		float interpupillaryDistance=((float)double_interpupillaryDistance);
		float * lensDistortionValues;
		bool freesrc_lensDistortionValues=(bool)false;
		JSValue da_lensDistortionValues;
		int64_t size_lensDistortionValues;
		JSClassID lensDistortionValues_class=JS_GetClassID(argv[7]);
		if(lensDistortionValues_class==js_ArrayProxy_class_id){
			void * opaque_lensDistortionValues=JS_GetOpaque(argv[7],js_ArrayProxy_class_id);
			ArrayProxy_class AP_lensDistortionValues=((ArrayProxy_class *)opaque_lensDistortionValues)[0];
			argv[7] =AP_lensDistortionValues.values(ctx,AP_lensDistortionValues.opaque,(int)0,(bool)false);
			freesrc_lensDistortionValues =(bool)true;
		}
		if(JS_IsArray(argv[7])==1){
			lensDistortionValues =(float *)js_malloc(ctx,4*sizeof(float));
			int i;
			for(i=0;i<4;i++){
				JSValue js_lensDistortionValues=JS_GetPropertyUint32(ctx,argv[7],(uint32_t)i);
				double double_lensDistortionValuesi;
				int err_lensDistortionValuesi=JS_ToFloat64(ctx,&double_lensDistortionValuesi,js_lensDistortionValues);
				if(err_lensDistortionValuesi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_lensDistortionValues is not numeric");
					return JS_EXCEPTION;
				}
				lensDistortionValues[i] =((float)double_lensDistortionValuesi);
				JS_FreeValue(ctx,js_lensDistortionValues);
			}
		}else if(JS_IsArrayBuffer(argv[7])==1){
			lensDistortionValues =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_lensDistortionValues,argv[7]);
		}else{
			JSClassID classid_lensDistortionValues=JS_GetClassID(argv[7]);
			if(classid_lensDistortionValues==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_lensDistortionValues;
				da_lensDistortionValues =JS_GetTypedArrayBuffer(ctx,argv[7],&offset_lensDistortionValues,(size_t *)&size_lensDistortionValues,NULL);
				lensDistortionValues =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_lensDistortionValues,da_lensDistortionValues);
				lensDistortionValues +=offset_lensDistortionValues;
				size_lensDistortionValues -=offset_lensDistortionValues;
			}else{
				if(freesrc_lensDistortionValues){
					JS_FreeValue(ctx,argv[7]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[7] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		float * chromaAbCorrection;
		bool freesrc_chromaAbCorrection=(bool)false;
		JSValue da_chromaAbCorrection;
		int64_t size_chromaAbCorrection;
		JSClassID chromaAbCorrection_class=JS_GetClassID(argv[8]);
		if(chromaAbCorrection_class==js_ArrayProxy_class_id){
			void * opaque_chromaAbCorrection=JS_GetOpaque(argv[8],js_ArrayProxy_class_id);
			ArrayProxy_class AP_chromaAbCorrection=((ArrayProxy_class *)opaque_chromaAbCorrection)[0];
			argv[8] =AP_chromaAbCorrection.values(ctx,AP_chromaAbCorrection.opaque,(int)0,(bool)false);
			freesrc_chromaAbCorrection =(bool)true;
		}
		if(JS_IsArray(argv[8])==1){
			chromaAbCorrection =(float *)js_malloc(ctx,4*sizeof(float));
			int i;
			for(i=0;i<4;i++){
				JSValue js_chromaAbCorrection=JS_GetPropertyUint32(ctx,argv[8],(uint32_t)i);
				double double_chromaAbCorrectioni;
				int err_chromaAbCorrectioni=JS_ToFloat64(ctx,&double_chromaAbCorrectioni,js_chromaAbCorrection);
				if(err_chromaAbCorrectioni<0){
					JS_ThrowTypeError(ctx,(const char *)"js_chromaAbCorrection is not numeric");
					return JS_EXCEPTION;
				}
				chromaAbCorrection[i] =((float)double_chromaAbCorrectioni);
				JS_FreeValue(ctx,js_chromaAbCorrection);
			}
		}else if(JS_IsArrayBuffer(argv[8])==1){
			chromaAbCorrection =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_chromaAbCorrection,argv[8]);
		}else{
			JSClassID classid_chromaAbCorrection=JS_GetClassID(argv[8]);
			if(classid_chromaAbCorrection==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_chromaAbCorrection;
				da_chromaAbCorrection =JS_GetTypedArrayBuffer(ctx,argv[8],&offset_chromaAbCorrection,(size_t *)&size_chromaAbCorrection,NULL);
				chromaAbCorrection =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_chromaAbCorrection,da_chromaAbCorrection);
				chromaAbCorrection +=offset_chromaAbCorrection;
				size_chromaAbCorrection -=offset_chromaAbCorrection;
			}else{
				if(freesrc_chromaAbCorrection){
					JS_FreeValue(ctx,argv[8]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[8] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		VrDeviceInfo _struct={
			hResolution,
			vResolution,
			hScreenSize,
			vScreenSize,
			eyeToScreenDistance,
			lensSeparationDistance,
			interpupillaryDistance,
			{lensDistortionValues[0],lensDistortionValues[1],lensDistortionValues[2],lensDistortionValues[3]},
			{chromaAbCorrection[0],chromaAbCorrection[1],chromaAbCorrection[2],chromaAbCorrection[3]}
		};
		VrDeviceInfo * ptr__return=(VrDeviceInfo *)js_malloc(ctx,sizeof(VrDeviceInfo));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_VrDeviceInfo_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_VrStereoConfig_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			VrStereoConfig * ptr__return=(VrStereoConfig *)js_calloc(ctx,(size_t)1,sizeof(VrStereoConfig));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_VrStereoConfig_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		Matrix * projection;
		bool freesrc_projection=(bool)false;
		int64_t size_projection;
		JSClassID projection_class=JS_GetClassID(argv[0]);
		if(projection_class==js_ArrayProxy_class_id){
			void * opaque_projection=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_projection=((ArrayProxy_class *)opaque_projection)[0];
			argv[0] =AP_projection.values(ctx,AP_projection.opaque,(int)0,(bool)false);
			freesrc_projection =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			projection =(Matrix *)js_malloc(ctx,2*sizeof(Matrix));
			int i;
			for(i=0;i<2;i++){
				JSValue js_projection=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				Matrix * ptr_projectioni=(Matrix *)JS_GetOpaque(js_projection,js_Matrix_class_id);
				if(ptr_projectioni==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_projection does not allow null");
					return JS_EXCEPTION;
				}
				projection[i] =*ptr_projectioni;
				JS_FreeValue(ctx,js_projection);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			projection =(Matrix *)JS_GetArrayBuffer(ctx,(size_t *)&size_projection,argv[0]);
		}else{
			if(freesrc_projection){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Matrix *");
			return JS_EXCEPTION;
		}
		Matrix * viewOffset;
		bool freesrc_viewOffset=(bool)false;
		int64_t size_viewOffset;
		JSClassID viewOffset_class=JS_GetClassID(argv[1]);
		if(viewOffset_class==js_ArrayProxy_class_id){
			void * opaque_viewOffset=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_viewOffset=((ArrayProxy_class *)opaque_viewOffset)[0];
			argv[1] =AP_viewOffset.values(ctx,AP_viewOffset.opaque,(int)0,(bool)false);
			freesrc_viewOffset =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			viewOffset =(Matrix *)js_malloc(ctx,2*sizeof(Matrix));
			int i;
			for(i=0;i<2;i++){
				JSValue js_viewOffset=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				Matrix * ptr_viewOffseti=(Matrix *)JS_GetOpaque(js_viewOffset,js_Matrix_class_id);
				if(ptr_viewOffseti==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_viewOffset does not allow null");
					return JS_EXCEPTION;
				}
				viewOffset[i] =*ptr_viewOffseti;
				JS_FreeValue(ctx,js_viewOffset);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			viewOffset =(Matrix *)JS_GetArrayBuffer(ctx,(size_t *)&size_viewOffset,argv[1]);
		}else{
			if(freesrc_viewOffset){
				JS_FreeValue(ctx,argv[1]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type Matrix *");
			return JS_EXCEPTION;
		}
		float * leftLensCenter;
		bool freesrc_leftLensCenter=(bool)false;
		JSValue da_leftLensCenter;
		int64_t size_leftLensCenter;
		JSClassID leftLensCenter_class=JS_GetClassID(argv[2]);
		if(leftLensCenter_class==js_ArrayProxy_class_id){
			void * opaque_leftLensCenter=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_leftLensCenter=((ArrayProxy_class *)opaque_leftLensCenter)[0];
			argv[2] =AP_leftLensCenter.values(ctx,AP_leftLensCenter.opaque,(int)0,(bool)false);
			freesrc_leftLensCenter =(bool)true;
		}
		if(JS_IsArray(argv[2])==1){
			leftLensCenter =(float *)js_malloc(ctx,2*sizeof(float));
			int i;
			for(i=0;i<2;i++){
				JSValue js_leftLensCenter=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				double double_leftLensCenteri;
				int err_leftLensCenteri=JS_ToFloat64(ctx,&double_leftLensCenteri,js_leftLensCenter);
				if(err_leftLensCenteri<0){
					JS_ThrowTypeError(ctx,(const char *)"js_leftLensCenter is not numeric");
					return JS_EXCEPTION;
				}
				leftLensCenter[i] =((float)double_leftLensCenteri);
				JS_FreeValue(ctx,js_leftLensCenter);
			}
		}else if(JS_IsArrayBuffer(argv[2])==1){
			leftLensCenter =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_leftLensCenter,argv[2]);
		}else{
			JSClassID classid_leftLensCenter=JS_GetClassID(argv[2]);
			if(classid_leftLensCenter==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_leftLensCenter;
				da_leftLensCenter =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_leftLensCenter,(size_t *)&size_leftLensCenter,NULL);
				leftLensCenter =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_leftLensCenter,da_leftLensCenter);
				leftLensCenter +=offset_leftLensCenter;
				size_leftLensCenter -=offset_leftLensCenter;
			}else{
				if(freesrc_leftLensCenter){
					JS_FreeValue(ctx,argv[2]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		float * rightLensCenter;
		bool freesrc_rightLensCenter=(bool)false;
		JSValue da_rightLensCenter;
		int64_t size_rightLensCenter;
		JSClassID rightLensCenter_class=JS_GetClassID(argv[3]);
		if(rightLensCenter_class==js_ArrayProxy_class_id){
			void * opaque_rightLensCenter=JS_GetOpaque(argv[3],js_ArrayProxy_class_id);
			ArrayProxy_class AP_rightLensCenter=((ArrayProxy_class *)opaque_rightLensCenter)[0];
			argv[3] =AP_rightLensCenter.values(ctx,AP_rightLensCenter.opaque,(int)0,(bool)false);
			freesrc_rightLensCenter =(bool)true;
		}
		if(JS_IsArray(argv[3])==1){
			rightLensCenter =(float *)js_malloc(ctx,2*sizeof(float));
			int i;
			for(i=0;i<2;i++){
				JSValue js_rightLensCenter=JS_GetPropertyUint32(ctx,argv[3],(uint32_t)i);
				double double_rightLensCenteri;
				int err_rightLensCenteri=JS_ToFloat64(ctx,&double_rightLensCenteri,js_rightLensCenter);
				if(err_rightLensCenteri<0){
					JS_ThrowTypeError(ctx,(const char *)"js_rightLensCenter is not numeric");
					return JS_EXCEPTION;
				}
				rightLensCenter[i] =((float)double_rightLensCenteri);
				JS_FreeValue(ctx,js_rightLensCenter);
			}
		}else if(JS_IsArrayBuffer(argv[3])==1){
			rightLensCenter =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_rightLensCenter,argv[3]);
		}else{
			JSClassID classid_rightLensCenter=JS_GetClassID(argv[3]);
			if(classid_rightLensCenter==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_rightLensCenter;
				da_rightLensCenter =JS_GetTypedArrayBuffer(ctx,argv[3],&offset_rightLensCenter,(size_t *)&size_rightLensCenter,NULL);
				rightLensCenter =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_rightLensCenter,da_rightLensCenter);
				rightLensCenter +=offset_rightLensCenter;
				size_rightLensCenter -=offset_rightLensCenter;
			}else{
				if(freesrc_rightLensCenter){
					JS_FreeValue(ctx,argv[3]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[3] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		float * leftScreenCenter;
		bool freesrc_leftScreenCenter=(bool)false;
		JSValue da_leftScreenCenter;
		int64_t size_leftScreenCenter;
		JSClassID leftScreenCenter_class=JS_GetClassID(argv[4]);
		if(leftScreenCenter_class==js_ArrayProxy_class_id){
			void * opaque_leftScreenCenter=JS_GetOpaque(argv[4],js_ArrayProxy_class_id);
			ArrayProxy_class AP_leftScreenCenter=((ArrayProxy_class *)opaque_leftScreenCenter)[0];
			argv[4] =AP_leftScreenCenter.values(ctx,AP_leftScreenCenter.opaque,(int)0,(bool)false);
			freesrc_leftScreenCenter =(bool)true;
		}
		if(JS_IsArray(argv[4])==1){
			leftScreenCenter =(float *)js_malloc(ctx,2*sizeof(float));
			int i;
			for(i=0;i<2;i++){
				JSValue js_leftScreenCenter=JS_GetPropertyUint32(ctx,argv[4],(uint32_t)i);
				double double_leftScreenCenteri;
				int err_leftScreenCenteri=JS_ToFloat64(ctx,&double_leftScreenCenteri,js_leftScreenCenter);
				if(err_leftScreenCenteri<0){
					JS_ThrowTypeError(ctx,(const char *)"js_leftScreenCenter is not numeric");
					return JS_EXCEPTION;
				}
				leftScreenCenter[i] =((float)double_leftScreenCenteri);
				JS_FreeValue(ctx,js_leftScreenCenter);
			}
		}else if(JS_IsArrayBuffer(argv[4])==1){
			leftScreenCenter =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_leftScreenCenter,argv[4]);
		}else{
			JSClassID classid_leftScreenCenter=JS_GetClassID(argv[4]);
			if(classid_leftScreenCenter==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_leftScreenCenter;
				da_leftScreenCenter =JS_GetTypedArrayBuffer(ctx,argv[4],&offset_leftScreenCenter,(size_t *)&size_leftScreenCenter,NULL);
				leftScreenCenter =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_leftScreenCenter,da_leftScreenCenter);
				leftScreenCenter +=offset_leftScreenCenter;
				size_leftScreenCenter -=offset_leftScreenCenter;
			}else{
				if(freesrc_leftScreenCenter){
					JS_FreeValue(ctx,argv[4]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[4] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		float * rightScreenCenter;
		bool freesrc_rightScreenCenter=(bool)false;
		JSValue da_rightScreenCenter;
		int64_t size_rightScreenCenter;
		JSClassID rightScreenCenter_class=JS_GetClassID(argv[5]);
		if(rightScreenCenter_class==js_ArrayProxy_class_id){
			void * opaque_rightScreenCenter=JS_GetOpaque(argv[5],js_ArrayProxy_class_id);
			ArrayProxy_class AP_rightScreenCenter=((ArrayProxy_class *)opaque_rightScreenCenter)[0];
			argv[5] =AP_rightScreenCenter.values(ctx,AP_rightScreenCenter.opaque,(int)0,(bool)false);
			freesrc_rightScreenCenter =(bool)true;
		}
		if(JS_IsArray(argv[5])==1){
			rightScreenCenter =(float *)js_malloc(ctx,2*sizeof(float));
			int i;
			for(i=0;i<2;i++){
				JSValue js_rightScreenCenter=JS_GetPropertyUint32(ctx,argv[5],(uint32_t)i);
				double double_rightScreenCenteri;
				int err_rightScreenCenteri=JS_ToFloat64(ctx,&double_rightScreenCenteri,js_rightScreenCenter);
				if(err_rightScreenCenteri<0){
					JS_ThrowTypeError(ctx,(const char *)"js_rightScreenCenter is not numeric");
					return JS_EXCEPTION;
				}
				rightScreenCenter[i] =((float)double_rightScreenCenteri);
				JS_FreeValue(ctx,js_rightScreenCenter);
			}
		}else if(JS_IsArrayBuffer(argv[5])==1){
			rightScreenCenter =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_rightScreenCenter,argv[5]);
		}else{
			JSClassID classid_rightScreenCenter=JS_GetClassID(argv[5]);
			if(classid_rightScreenCenter==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_rightScreenCenter;
				da_rightScreenCenter =JS_GetTypedArrayBuffer(ctx,argv[5],&offset_rightScreenCenter,(size_t *)&size_rightScreenCenter,NULL);
				rightScreenCenter =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_rightScreenCenter,da_rightScreenCenter);
				rightScreenCenter +=offset_rightScreenCenter;
				size_rightScreenCenter -=offset_rightScreenCenter;
			}else{
				if(freesrc_rightScreenCenter){
					JS_FreeValue(ctx,argv[5]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[5] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		float * scale;
		bool freesrc_scale=(bool)false;
		JSValue da_scale;
		int64_t size_scale;
		JSClassID scale_class=JS_GetClassID(argv[6]);
		if(scale_class==js_ArrayProxy_class_id){
			void * opaque_scale=JS_GetOpaque(argv[6],js_ArrayProxy_class_id);
			ArrayProxy_class AP_scale=((ArrayProxy_class *)opaque_scale)[0];
			argv[6] =AP_scale.values(ctx,AP_scale.opaque,(int)0,(bool)false);
			freesrc_scale =(bool)true;
		}
		if(JS_IsArray(argv[6])==1){
			scale =(float *)js_malloc(ctx,2*sizeof(float));
			int i;
			for(i=0;i<2;i++){
				JSValue js_scale=JS_GetPropertyUint32(ctx,argv[6],(uint32_t)i);
				double double_scalei;
				int err_scalei=JS_ToFloat64(ctx,&double_scalei,js_scale);
				if(err_scalei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_scale is not numeric");
					return JS_EXCEPTION;
				}
				scale[i] =((float)double_scalei);
				JS_FreeValue(ctx,js_scale);
			}
		}else if(JS_IsArrayBuffer(argv[6])==1){
			scale =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_scale,argv[6]);
		}else{
			JSClassID classid_scale=JS_GetClassID(argv[6]);
			if(classid_scale==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_scale;
				da_scale =JS_GetTypedArrayBuffer(ctx,argv[6],&offset_scale,(size_t *)&size_scale,NULL);
				scale =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_scale,da_scale);
				scale +=offset_scale;
				size_scale -=offset_scale;
			}else{
				if(freesrc_scale){
					JS_FreeValue(ctx,argv[6]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[6] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		float * scaleIn;
		bool freesrc_scaleIn=(bool)false;
		JSValue da_scaleIn;
		int64_t size_scaleIn;
		JSClassID scaleIn_class=JS_GetClassID(argv[7]);
		if(scaleIn_class==js_ArrayProxy_class_id){
			void * opaque_scaleIn=JS_GetOpaque(argv[7],js_ArrayProxy_class_id);
			ArrayProxy_class AP_scaleIn=((ArrayProxy_class *)opaque_scaleIn)[0];
			argv[7] =AP_scaleIn.values(ctx,AP_scaleIn.opaque,(int)0,(bool)false);
			freesrc_scaleIn =(bool)true;
		}
		if(JS_IsArray(argv[7])==1){
			scaleIn =(float *)js_malloc(ctx,2*sizeof(float));
			int i;
			for(i=0;i<2;i++){
				JSValue js_scaleIn=JS_GetPropertyUint32(ctx,argv[7],(uint32_t)i);
				double double_scaleIni;
				int err_scaleIni=JS_ToFloat64(ctx,&double_scaleIni,js_scaleIn);
				if(err_scaleIni<0){
					JS_ThrowTypeError(ctx,(const char *)"js_scaleIn is not numeric");
					return JS_EXCEPTION;
				}
				scaleIn[i] =((float)double_scaleIni);
				JS_FreeValue(ctx,js_scaleIn);
			}
		}else if(JS_IsArrayBuffer(argv[7])==1){
			scaleIn =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_scaleIn,argv[7]);
		}else{
			JSClassID classid_scaleIn=JS_GetClassID(argv[7]);
			if(classid_scaleIn==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_scaleIn;
				da_scaleIn =JS_GetTypedArrayBuffer(ctx,argv[7],&offset_scaleIn,(size_t *)&size_scaleIn,NULL);
				scaleIn =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_scaleIn,da_scaleIn);
				scaleIn +=offset_scaleIn;
				size_scaleIn -=offset_scaleIn;
			}else{
				if(freesrc_scaleIn){
					JS_FreeValue(ctx,argv[7]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[7] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		VrStereoConfig _struct={
			{projection[0],projection[1]},
			{viewOffset[0],viewOffset[1]},
			{leftLensCenter[0],leftLensCenter[1]},
			{rightLensCenter[0],rightLensCenter[1]},
			{leftScreenCenter[0],leftScreenCenter[1]},
			{rightScreenCenter[0],rightScreenCenter[1]},
			{scale[0],scale[1]},
			{scaleIn[0],scaleIn[1]}
		};
		VrStereoConfig * ptr__return=(VrStereoConfig *)js_malloc(ctx,sizeof(VrStereoConfig));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_VrStereoConfig_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_FilePathList_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			FilePathList * ptr__return=(FilePathList *)js_calloc(ctx,(size_t)1,sizeof(FilePathList));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_FilePathList_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		uint32_t long_capacity;
		int err_capacity=JS_ToUint32(ctx,&long_capacity,argv[0]);
		if(err_capacity<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int capacity=((unsigned int)long_capacity);
		uint32_t long_count;
		int err_count=JS_ToUint32(ctx,&long_count,argv[1]);
		if(err_count<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int count=((unsigned int)long_count);
		char * * paths;
		int64_t size_paths;
		JSClassID paths_class=JS_GetClassID(argv[2]);
		if(paths_class==js_ArrayProxy_class_id){
			void * opaque_paths=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_paths=((ArrayProxy_class *)opaque_paths)[0];
			argv[2] =AP_paths.values(ctx,AP_paths.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[2]);
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_paths)==-1){
				return JS_EXCEPTION;
			}
			paths =(char * *)js_malloc(ctx,size_paths*sizeof(char *));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)*paths);
			int i;
			for(i=0;i<size_paths;i++){
				JSValue js_paths=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				int64_t size_pathsi;
				if(JS_IsString(js_paths)==1){
					paths[i] =(char *)JS_ToCStringLen(ctx,(size_t *)&size_pathsi,js_paths);
					memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)paths[i]);
				}else if(JS_IsArrayBuffer(js_paths)==1){
					paths[i] =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_pathsi,js_paths);
				}else{
					JSClassID classid_pathsi=JS_GetClassID(js_paths);
					if(classid_pathsi==JS_CLASS_INT8_ARRAY){
						size_t offset_pathsi;
						JSValue da_pathsi=JS_GetTypedArrayBuffer(ctx,js_paths,&offset_pathsi,(size_t *)&size_pathsi,NULL);
						paths[i] =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_pathsi,da_pathsi);
						paths[i] +=offset_pathsi;
						size_pathsi -=offset_pathsi;
						memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_pathsi);
					}else{
						JS_ThrowTypeError(ctx,(const char *)"js_paths does not match type char *");
						return JS_EXCEPTION;
					}
				}
				JS_FreeValue(ctx,js_paths);
			}
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type char * *");
			return JS_EXCEPTION;
		}
		FilePathList _struct={
			capacity,
			count,
			paths
		};
		FilePathList * ptr__return=(FilePathList *)js_malloc(ctx,sizeof(FilePathList));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_FilePathList_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_AutomationEvent_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			AutomationEvent * ptr__return=(AutomationEvent *)js_calloc(ctx,(size_t)1,sizeof(AutomationEvent));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_AutomationEvent_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		uint32_t long_frame;
		int err_frame=JS_ToUint32(ctx,&long_frame,argv[0]);
		if(err_frame<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int frame=((unsigned int)long_frame);
		uint32_t long_type;
		int err_type=JS_ToUint32(ctx,&long_type,argv[1]);
		if(err_type<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int type=((unsigned int)long_type);
		int * params;
		bool freesrc_params=(bool)false;
		JSValue da_params;
		int64_t size_params;
		JSClassID params_class=JS_GetClassID(argv[2]);
		if(params_class==js_ArrayProxy_class_id){
			void * opaque_params=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_params=((ArrayProxy_class *)opaque_params)[0];
			argv[2] =AP_params.values(ctx,AP_params.opaque,(int)0,(bool)false);
			freesrc_params =(bool)true;
		}
		if(JS_IsArray(argv[2])==1){
			params =(int *)js_malloc(ctx,4*sizeof(int));
			int i;
			for(i=0;i<4;i++){
				JSValue js_params=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				int32_t long_paramsi;
				int err_paramsi=JS_ToInt32(ctx,&long_paramsi,js_params);
				if(err_paramsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_params is not numeric");
					return JS_EXCEPTION;
				}
				params[i] =((int)long_paramsi);
				JS_FreeValue(ctx,js_params);
			}
		}else if(JS_IsArrayBuffer(argv[2])==1){
			params =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_params,argv[2]);
		}else{
			JSClassID classid_params=JS_GetClassID(argv[2]);
			if(classid_params==JS_CLASS_INT16_ARRAY){
				size_t offset_params;
				da_params =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_params,(size_t *)&size_params,NULL);
				params =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_params,da_params);
				params +=offset_params;
				size_params -=offset_params;
			}else{
				if(freesrc_params){
					JS_FreeValue(ctx,argv[2]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		AutomationEvent _struct={
			frame,
			type,
			{params[0],params[1],params[2],params[3]}
		};
		AutomationEvent * ptr__return=(AutomationEvent *)js_malloc(ctx,sizeof(AutomationEvent));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_AutomationEvent_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_AutomationEventList_constructor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		if(argc==0){
			AutomationEventList * ptr__return=(AutomationEventList *)js_calloc(ctx,(size_t)1,sizeof(AutomationEventList));
			JSValue _return=JS_NewObjectClass(ctx,(int)js_AutomationEventList_class_id);
			JS_SetOpaque(_return,(void *)ptr__return);
			return _return;
		}
		uint32_t long_capacity;
		int err_capacity=JS_ToUint32(ctx,&long_capacity,argv[0]);
		if(err_capacity<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int capacity=((unsigned int)long_capacity);
		uint32_t long_count;
		int err_count=JS_ToUint32(ctx,&long_count,argv[1]);
		if(err_count<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int count=((unsigned int)long_count);
		AutomationEvent * events;
		bool freesrc_events=(bool)false;
		int64_t size_events;
		JSClassID events_class=JS_GetClassID(argv[2]);
		if(events_class==js_ArrayProxy_class_id){
			void * opaque_events=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_events=((ArrayProxy_class *)opaque_events)[0];
			argv[2] =AP_events.values(ctx,AP_events.opaque,(int)0,(bool)false);
			freesrc_events =(bool)true;
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_events)==-1){
				return JS_EXCEPTION;
			}
			events =(AutomationEvent *)js_malloc(ctx,size_events*sizeof(AutomationEvent));
			int i;
			for(i=0;i<size_events;i++){
				JSValue js_events=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				AutomationEvent * ptr_eventsi=(AutomationEvent *)JS_GetOpaque(js_events,js_AutomationEvent_class_id);
				if(ptr_eventsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_events does not allow null");
					return JS_EXCEPTION;
				}
				events[i] =*ptr_eventsi;
				JS_FreeValue(ctx,js_events);
			}
		}else if(JS_IsArrayBuffer(argv[2])==1){
			events =(AutomationEvent *)JS_GetArrayBuffer(ctx,(size_t *)&size_events,argv[2]);
		}else{
			if(freesrc_events){
				JS_FreeValue(ctx,argv[2]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type AutomationEvent *");
			return JS_EXCEPTION;
		}
		AutomationEventList _struct={
			capacity,
			count,
			events
		};
		AutomationEventList * ptr__return=(AutomationEventList *)js_malloc(ctx,sizeof(AutomationEventList));
		ptr__return[0]=_struct;
		JSValue _return=JS_NewObjectClass(ctx,(int)js_AutomationEventList_class_id);
		JS_SetOpaque(_return,(void *)ptr__return);
		return _return;
	}
	
	static JSValue js_InitWindow(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		char * title;
		JSValue da_title;
		int64_t size_title;
		if(JS_IsString(argv[2])==1){
			title =(char *)JS_ToCStringLen(ctx,(size_t *)&size_title,argv[2]);
		}else if(JS_IsArrayBuffer(argv[2])==1){
			title =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_title,argv[2]);
		}else{
			JSClassID classid_title=JS_GetClassID(argv[2]);
			if(classid_title==JS_CLASS_INT8_ARRAY){
				size_t offset_title;
				da_title =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_title,(size_t *)&size_title,NULL);
				title =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_title,da_title);
				title +=offset_title;
				size_title -=offset_title;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		InitWindow(width,height,(const char *)title);
		if(JS_IsArray(argv[2])==1){
			js_free(ctx,(void *)title);
		}else if(JS_IsString(argv[2])==1){
			JS_FreeCString(ctx,(const char *)title);
		}else{
			JSClassID classid_title=JS_GetClassID(argv[2]);
			if(classid_title==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_title);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_CloseWindow(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		CloseWindow();
		return JS_UNDEFINED;
	}
	
	static JSValue js_WindowShouldClose(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		bool returnVal=WindowShouldClose();
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsWindowReady(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		bool returnVal=IsWindowReady();
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsWindowFullscreen(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		bool returnVal=IsWindowFullscreen();
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsWindowHidden(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		bool returnVal=IsWindowHidden();
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsWindowMinimized(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		bool returnVal=IsWindowMinimized();
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsWindowMaximized(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		bool returnVal=IsWindowMaximized();
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsWindowFocused(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		bool returnVal=IsWindowFocused();
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsWindowResized(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		bool returnVal=IsWindowResized();
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsWindowState(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		uint32_t long_flag;
		int err_flag=JS_ToUint32(ctx,&long_flag,argv[0]);
		if(err_flag<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int flag=((unsigned int)long_flag);
		bool returnVal=IsWindowState(flag);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_SetWindowState(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		uint32_t long_flags;
		int err_flags=JS_ToUint32(ctx,&long_flags,argv[0]);
		if(err_flags<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int flags=((unsigned int)long_flags);
		SetWindowState(flags);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ClearWindowState(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		uint32_t long_flags;
		int err_flags=JS_ToUint32(ctx,&long_flags,argv[0]);
		if(err_flags<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int flags=((unsigned int)long_flags);
		ClearWindowState(flags);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ToggleFullscreen(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		ToggleFullscreen();
		return JS_UNDEFINED;
	}
	
	static JSValue js_ToggleBorderlessWindowed(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		ToggleBorderlessWindowed();
		return JS_UNDEFINED;
	}
	
	static JSValue js_MaximizeWindow(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		MaximizeWindow();
		return JS_UNDEFINED;
	}
	
	static JSValue js_MinimizeWindow(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		MinimizeWindow();
		return JS_UNDEFINED;
	}
	
	static JSValue js_RestoreWindow(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		RestoreWindow();
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetWindowIcon(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		SetWindowIcon(image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetWindowIcons(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * images;
		bool freesrc_images=(bool)false;
		int64_t size_images;
		JSClassID images_class=JS_GetClassID(argv[0]);
		if(images_class==js_ArrayProxy_class_id){
			void * opaque_images=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_images=((ArrayProxy_class *)opaque_images)[0];
			argv[0] =AP_images.values(ctx,AP_images.opaque,(int)0,(bool)false);
			freesrc_images =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_images)==-1){
				return JS_EXCEPTION;
			}
			images =(Image *)js_malloc(ctx,size_images*sizeof(Image));
			int i;
			for(i=0;i<size_images;i++){
				JSValue js_images=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				Image * ptr_imagesi=(Image *)JS_GetOpaque(js_images,js_Image_class_id);
				if(ptr_imagesi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_images does not allow null");
					return JS_EXCEPTION;
				}
				images[i] =*ptr_imagesi;
				JS_FreeValue(ctx,js_images);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			images =(Image *)JS_GetArrayBuffer(ctx,(size_t *)&size_images,argv[0]);
		}else{
			if(freesrc_images){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image *");
			return JS_EXCEPTION;
		}
		int32_t long_count;
		int err_count=JS_ToInt32(ctx,&long_count,argv[1]);
		if(err_count<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)images);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int count=((int)long_count);
		SetWindowIcons(images,count);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)images);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetWindowTitle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * title;
		JSValue da_title;
		int64_t size_title;
		if(JS_IsString(argv[0])==1){
			title =(char *)JS_ToCStringLen(ctx,(size_t *)&size_title,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			title =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_title,argv[0]);
		}else{
			JSClassID classid_title=JS_GetClassID(argv[0]);
			if(classid_title==JS_CLASS_INT8_ARRAY){
				size_t offset_title;
				da_title =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_title,(size_t *)&size_title,NULL);
				title =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_title,da_title);
				title +=offset_title;
				size_title -=offset_title;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		SetWindowTitle((const char *)title);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)title);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)title);
		}else{
			JSClassID classid_title=JS_GetClassID(argv[0]);
			if(classid_title==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_title);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetWindowPosition(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_x;
		int err_x=JS_ToInt32(ctx,&long_x,argv[0]);
		if(err_x<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int x=((int)long_x);
		int32_t long_y;
		int err_y=JS_ToInt32(ctx,&long_y,argv[1]);
		if(err_y<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int y=((int)long_y);
		SetWindowPosition(x,y);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetWindowMonitor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_monitor;
		int err_monitor=JS_ToInt32(ctx,&long_monitor,argv[0]);
		if(err_monitor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int monitor=((int)long_monitor);
		SetWindowMonitor(monitor);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetWindowMinSize(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		SetWindowMinSize(width,height);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetWindowMaxSize(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		SetWindowMaxSize(width,height);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetWindowSize(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		SetWindowSize(width,height);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetWindowOpacity(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double double_opacity;
		int err_opacity=JS_ToFloat64(ctx,&double_opacity,argv[0]);
		if(err_opacity<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float opacity=((float)double_opacity);
		SetWindowOpacity(opacity);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetWindowFocused(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		SetWindowFocused();
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetScreenWidth(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetScreenWidth();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetScreenHeight(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetScreenHeight();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetRenderWidth(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetRenderWidth();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetRenderHeight(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetRenderHeight();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetMonitorCount(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetMonitorCount();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetCurrentMonitor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetCurrentMonitor();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetMonitorPosition(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_monitor;
		int err_monitor=JS_ToInt32(ctx,&long_monitor,argv[0]);
		if(err_monitor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int monitor=((int)long_monitor);
		Vector2 returnVal=GetMonitorPosition(monitor);
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetMonitorWidth(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_monitor;
		int err_monitor=JS_ToInt32(ctx,&long_monitor,argv[0]);
		if(err_monitor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int monitor=((int)long_monitor);
		int returnVal=GetMonitorWidth(monitor);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetMonitorHeight(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_monitor;
		int err_monitor=JS_ToInt32(ctx,&long_monitor,argv[0]);
		if(err_monitor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int monitor=((int)long_monitor);
		int returnVal=GetMonitorHeight(monitor);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetMonitorPhysicalWidth(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_monitor;
		int err_monitor=JS_ToInt32(ctx,&long_monitor,argv[0]);
		if(err_monitor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int monitor=((int)long_monitor);
		int returnVal=GetMonitorPhysicalWidth(monitor);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetMonitorPhysicalHeight(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_monitor;
		int err_monitor=JS_ToInt32(ctx,&long_monitor,argv[0]);
		if(err_monitor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int monitor=((int)long_monitor);
		int returnVal=GetMonitorPhysicalHeight(monitor);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetMonitorRefreshRate(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_monitor;
		int err_monitor=JS_ToInt32(ctx,&long_monitor,argv[0]);
		if(err_monitor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int monitor=((int)long_monitor);
		int returnVal=GetMonitorRefreshRate(monitor);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetWindowPosition(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 returnVal=GetWindowPosition();
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetWindowScaleDPI(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 returnVal=GetWindowScaleDPI();
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetMonitorName(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_monitor;
		int err_monitor=JS_ToInt32(ctx,&long_monitor,argv[0]);
		if(err_monitor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int monitor=((int)long_monitor);
		char * returnVal=(char *)GetMonitorName(monitor);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		return ret;
	}
	
	static JSValue js_SetClipboardText(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		SetClipboardText((const char *)text);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetClipboardText(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * returnVal=(char *)GetClipboardText();
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		return ret;
	}
	
	static JSValue js_GetClipboardImage(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image returnVal=GetClipboardImage();
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_EnableEventWaiting(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		EnableEventWaiting();
		return JS_UNDEFINED;
	}
	
	static JSValue js_DisableEventWaiting(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		DisableEventWaiting();
		return JS_UNDEFINED;
	}
	
	static JSValue js_ShowCursor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		ShowCursor();
		return JS_UNDEFINED;
	}
	
	static JSValue js_HideCursor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		HideCursor();
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsCursorHidden(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		bool returnVal=IsCursorHidden();
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_EnableCursor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		EnableCursor();
		return JS_UNDEFINED;
	}
	
	static JSValue js_DisableCursor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		DisableCursor();
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsCursorOnScreen(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		bool returnVal=IsCursorOnScreen();
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_ClearBackground(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * ptr_color=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ClearBackground(color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_BeginDrawing(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		BeginDrawing();
		return JS_UNDEFINED;
	}
	
	static JSValue js_EndDrawing(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		EndDrawing();
		app_update_quickjs(ctx);
		return JS_UNDEFINED;
	}
	
	static JSValue js_BeginMode2D(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Camera2D * ptr_camera=(Camera2D *)JS_GetOpaque(argv[0],js_Camera2D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Camera2D camera=*ptr_camera;
		BeginMode2D(camera);
		return JS_UNDEFINED;
	}
	
	static JSValue js_EndMode2D(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		EndMode2D();
		return JS_UNDEFINED;
	}
	
	static JSValue js_BeginMode3D(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Camera3D * ptr_camera=(Camera3D *)JS_GetOpaque(argv[0],js_Camera3D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Camera3D camera=*ptr_camera;
		BeginMode3D(camera);
		return JS_UNDEFINED;
	}
	
	static JSValue js_EndMode3D(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		EndMode3D();
		return JS_UNDEFINED;
	}
	
	static JSValue js_BeginTextureMode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		RenderTexture2D * ptr_target=(RenderTexture2D *)JS_GetOpaque(argv[0],js_RenderTexture_class_id);
		if(ptr_target==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		RenderTexture2D target=*ptr_target;
		BeginTextureMode(target);
		return JS_UNDEFINED;
	}
	
	static JSValue js_EndTextureMode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		EndTextureMode();
		return JS_UNDEFINED;
	}
	
	static JSValue js_BeginShaderMode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Shader * ptr_shader=(Shader *)JS_GetOpaque(argv[0],js_Shader_class_id);
		if(ptr_shader==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Shader shader=*ptr_shader;
		BeginShaderMode(shader);
		return JS_UNDEFINED;
	}
	
	static JSValue js_EndShaderMode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		EndShaderMode();
		return JS_UNDEFINED;
	}
	
	static JSValue js_BeginBlendMode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_mode;
		int err_mode=JS_ToInt32(ctx,&long_mode,argv[0]);
		if(err_mode<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int mode=((int)long_mode);
		BeginBlendMode(mode);
		return JS_UNDEFINED;
	}
	
	static JSValue js_EndBlendMode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		EndBlendMode();
		return JS_UNDEFINED;
	}
	
	static JSValue js_BeginScissorMode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_x;
		int err_x=JS_ToInt32(ctx,&long_x,argv[0]);
		if(err_x<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int x=((int)long_x);
		int32_t long_y;
		int err_y=JS_ToInt32(ctx,&long_y,argv[1]);
		if(err_y<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int y=((int)long_y);
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[2]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[3]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		BeginScissorMode(x,y,width,height);
		return JS_UNDEFINED;
	}
	
	static JSValue js_EndScissorMode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		EndScissorMode();
		return JS_UNDEFINED;
	}
	
	static JSValue js_BeginVrStereoMode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		VrStereoConfig * ptr_config=(VrStereoConfig *)JS_GetOpaque(argv[0],js_VrStereoConfig_class_id);
		if(ptr_config==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		VrStereoConfig config=*ptr_config;
		BeginVrStereoMode(config);
		return JS_UNDEFINED;
	}
	
	static JSValue js_EndVrStereoMode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		EndVrStereoMode();
		return JS_UNDEFINED;
	}
	
	static JSValue js_LoadVrStereoConfig(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		VrDeviceInfo * ptr_device=(VrDeviceInfo *)JS_GetOpaque(argv[0],js_VrDeviceInfo_class_id);
		if(ptr_device==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		VrDeviceInfo device=*ptr_device;
		VrStereoConfig returnVal=LoadVrStereoConfig(device);
		VrStereoConfig * ptr_ret=(VrStereoConfig *)js_malloc(ctx,sizeof(VrStereoConfig));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_VrStereoConfig_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_UnloadVrStereoConfig(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		VrStereoConfig * ptr_config=(VrStereoConfig *)JS_GetOpaque(argv[0],js_VrStereoConfig_class_id);
		if(ptr_config==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		VrStereoConfig config=*ptr_config;
		UnloadVrStereoConfig(config);
		return JS_UNDEFINED;
	}
	
	static JSValue js_LoadShader(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * vsFileName;
		int64_t size_vsFileName;
		if(JS_IsNull(argv[0])||JS_IsUndefined(argv[0])){
			vsFileName =NULL;
		}else if(JS_IsString(argv[0])==1){
			vsFileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_vsFileName,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)vsFileName);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			vsFileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_vsFileName,argv[0]);
		}else{
			JSClassID classid_vsFileName=JS_GetClassID(argv[0]);
			if(classid_vsFileName==JS_CLASS_INT8_ARRAY){
				size_t offset_vsFileName;
				JSValue da_vsFileName=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_vsFileName,(size_t *)&size_vsFileName,NULL);
				vsFileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_vsFileName,da_vsFileName);
				vsFileName +=offset_vsFileName;
				size_vsFileName -=offset_vsFileName;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_vsFileName);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * fsFileName;
		int64_t size_fsFileName;
		if(JS_IsString(argv[1])==1){
			fsFileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fsFileName,argv[1]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fsFileName);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fsFileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fsFileName,argv[1]);
		}else{
			JSClassID classid_fsFileName=JS_GetClassID(argv[1]);
			if(classid_fsFileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fsFileName;
				JSValue da_fsFileName=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fsFileName,(size_t *)&size_fsFileName,NULL);
				fsFileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fsFileName,da_fsFileName);
				fsFileName +=offset_fsFileName;
				size_fsFileName -=offset_fsFileName;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fsFileName);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Shader returnVal=LoadShader((const char *)vsFileName,(const char *)fsFileName);
		Shader * ptr_ret=(Shader *)js_malloc(ctx,sizeof(Shader));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Shader_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_LoadShaderFromMemory(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * vsCode;
		int64_t size_vsCode;
		if(JS_IsString(argv[0])==1){
			vsCode =(char *)JS_ToCStringLen(ctx,(size_t *)&size_vsCode,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)vsCode);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			vsCode =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_vsCode,argv[0]);
		}else{
			JSClassID classid_vsCode=JS_GetClassID(argv[0]);
			if(classid_vsCode==JS_CLASS_INT8_ARRAY){
				size_t offset_vsCode;
				JSValue da_vsCode=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_vsCode,(size_t *)&size_vsCode,NULL);
				vsCode =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_vsCode,da_vsCode);
				vsCode +=offset_vsCode;
				size_vsCode -=offset_vsCode;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_vsCode);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * fsCode;
		int64_t size_fsCode;
		if(JS_IsString(argv[1])==1){
			fsCode =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fsCode,argv[1]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fsCode);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fsCode =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fsCode,argv[1]);
		}else{
			JSClassID classid_fsCode=JS_GetClassID(argv[1]);
			if(classid_fsCode==JS_CLASS_INT8_ARRAY){
				size_t offset_fsCode;
				JSValue da_fsCode=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fsCode,(size_t *)&size_fsCode,NULL);
				fsCode =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fsCode,da_fsCode);
				fsCode +=offset_fsCode;
				size_fsCode -=offset_fsCode;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fsCode);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Shader returnVal=LoadShaderFromMemory((const char *)vsCode,(const char *)fsCode);
		Shader * ptr_ret=(Shader *)js_malloc(ctx,sizeof(Shader));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Shader_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_IsShaderValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Shader * ptr_shader=(Shader *)JS_GetOpaque(argv[0],js_Shader_class_id);
		if(ptr_shader==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Shader shader=*ptr_shader;
		bool returnVal=IsShaderValid(shader);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_GetShaderLocation(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Shader * ptr_shader=(Shader *)JS_GetOpaque(argv[0],js_Shader_class_id);
		if(ptr_shader==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Shader shader=*ptr_shader;
		char * uniformName;
		JSValue da_uniformName;
		int64_t size_uniformName;
		if(JS_IsString(argv[1])==1){
			uniformName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_uniformName,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			uniformName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_uniformName,argv[1]);
		}else{
			JSClassID classid_uniformName=JS_GetClassID(argv[1]);
			if(classid_uniformName==JS_CLASS_INT8_ARRAY){
				size_t offset_uniformName;
				da_uniformName =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_uniformName,(size_t *)&size_uniformName,NULL);
				uniformName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_uniformName,da_uniformName);
				uniformName +=offset_uniformName;
				size_uniformName -=offset_uniformName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int returnVal=GetShaderLocation(shader,(const char *)uniformName);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)uniformName);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)uniformName);
		}else{
			JSClassID classid_uniformName=JS_GetClassID(argv[1]);
			if(classid_uniformName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_uniformName);
			}
		}
		return ret;
	}
	
	static JSValue js_GetShaderLocationAttrib(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Shader * ptr_shader=(Shader *)JS_GetOpaque(argv[0],js_Shader_class_id);
		if(ptr_shader==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Shader shader=*ptr_shader;
		char * attribName;
		JSValue da_attribName;
		int64_t size_attribName;
		if(JS_IsString(argv[1])==1){
			attribName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_attribName,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			attribName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_attribName,argv[1]);
		}else{
			JSClassID classid_attribName=JS_GetClassID(argv[1]);
			if(classid_attribName==JS_CLASS_INT8_ARRAY){
				size_t offset_attribName;
				da_attribName =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_attribName,(size_t *)&size_attribName,NULL);
				attribName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_attribName,da_attribName);
				attribName +=offset_attribName;
				size_attribName -=offset_attribName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int returnVal=GetShaderLocationAttrib(shader,(const char *)attribName);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)attribName);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)attribName);
		}else{
			JSClassID classid_attribName=JS_GetClassID(argv[1]);
			if(classid_attribName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_attribName);
			}
		}
		return ret;
	}
	
	static JSValue js_SetShaderValue(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Shader * ptr_shader=(Shader *)JS_GetOpaque(argv[0],js_Shader_class_id);
		if(ptr_shader==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Shader shader=*ptr_shader;
		int32_t long_locIndex;
		int err_locIndex=JS_ToInt32(ctx,&long_locIndex,argv[1]);
		if(err_locIndex<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int locIndex=((int)long_locIndex);
		void * value=NULL;
		JSValue da_value;
		int32_t long_uniformType;
		int err_uniformType=JS_ToInt32(ctx,&long_uniformType,argv[3]);
		if(err_uniformType<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int uniformType=((int)long_uniformType);
		if(uniformType==SHADER_UNIFORM_FLOAT){
			float * val;
			bool freesrc_val=(bool)false;
			JSValue da_val;
			int64_t size_val;
			JSClassID val_class=JS_GetClassID(argv[2]);
			if(val_class==js_ArrayProxy_class_id){
				void * opaque_val=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
				ArrayProxy_class AP_val=((ArrayProxy_class *)opaque_val)[0];
				argv[2] =AP_val.values(ctx,AP_val.opaque,(int)0,(bool)false);
				freesrc_val =(bool)true;
			}
			if(JS_IsArray(argv[2])==1){
				val =(float *)js_malloc(ctx,1*sizeof(float));
				JSValue js_val=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)0);
				double double_val0;
				int err_val0=JS_ToFloat64(ctx,&double_val0,js_val);
				if(err_val0<0){
					JS_ThrowTypeError(ctx,(const char *)"js_val is not numeric");
					return JS_EXCEPTION;
				}
				val[0] =((float)double_val0);
				JS_FreeValue(ctx,js_val);
			}else if(JS_IsArrayBuffer(argv[2])==1){
				val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,argv[2]);
			}else{
				JSClassID classid_val=JS_GetClassID(argv[2]);
				if(classid_val==JS_CLASS_FLOAT32_ARRAY){
					size_t offset_val;
					da_val =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_val,(size_t *)&size_val,NULL);
					val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,da_val);
					val +=offset_val;
					size_val -=offset_val;
				}else{
					if(freesrc_val){
						JS_FreeValue(ctx,argv[2]);
					}
					JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type float *");
					return JS_EXCEPTION;
				}
			}
			value=((void *)val);
			da_value=da_val;
		}else if(uniformType==SHADER_UNIFORM_VEC2){
			float * val;
			bool freesrc_val=(bool)false;
			JSValue da_val;
			int64_t size_val;
			JSClassID val_class=JS_GetClassID(argv[2]);
			if(val_class==js_ArrayProxy_class_id){
				void * opaque_val=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
				ArrayProxy_class AP_val=((ArrayProxy_class *)opaque_val)[0];
				argv[2] =AP_val.values(ctx,AP_val.opaque,(int)0,(bool)false);
				freesrc_val =(bool)true;
			}
			if(JS_IsArray(argv[2])==1){
				val =(float *)js_malloc(ctx,2*sizeof(float));
				int i;
				for(i=0;i<2;i++){
					JSValue js_val=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
					double double_vali;
					int err_vali=JS_ToFloat64(ctx,&double_vali,js_val);
					if(err_vali<0){
						JS_ThrowTypeError(ctx,(const char *)"js_val is not numeric");
						return JS_EXCEPTION;
					}
					val[i] =((float)double_vali);
					JS_FreeValue(ctx,js_val);
				}
			}else if(JS_IsArrayBuffer(argv[2])==1){
				val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,argv[2]);
			}else{
				JSClassID classid_val=JS_GetClassID(argv[2]);
				if(classid_val==JS_CLASS_FLOAT32_ARRAY){
					size_t offset_val;
					da_val =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_val,(size_t *)&size_val,NULL);
					val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,da_val);
					val +=offset_val;
					size_val -=offset_val;
				}else{
					if(freesrc_val){
						JS_FreeValue(ctx,argv[2]);
					}
					JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type float *");
					return JS_EXCEPTION;
				}
			}
			value=((void *)val);
			da_value=da_val;
		}else if(uniformType==SHADER_UNIFORM_VEC3){
			float * val;
			bool freesrc_val=(bool)false;
			JSValue da_val;
			int64_t size_val;
			JSClassID val_class=JS_GetClassID(argv[2]);
			if(val_class==js_ArrayProxy_class_id){
				void * opaque_val=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
				ArrayProxy_class AP_val=((ArrayProxy_class *)opaque_val)[0];
				argv[2] =AP_val.values(ctx,AP_val.opaque,(int)0,(bool)false);
				freesrc_val =(bool)true;
			}
			if(JS_IsArray(argv[2])==1){
				val =(float *)js_malloc(ctx,3*sizeof(float));
				int i;
				for(i=0;i<3;i++){
					JSValue js_val=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
					double double_vali;
					int err_vali=JS_ToFloat64(ctx,&double_vali,js_val);
					if(err_vali<0){
						JS_ThrowTypeError(ctx,(const char *)"js_val is not numeric");
						return JS_EXCEPTION;
					}
					val[i] =((float)double_vali);
					JS_FreeValue(ctx,js_val);
				}
			}else if(JS_IsArrayBuffer(argv[2])==1){
				val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,argv[2]);
			}else{
				JSClassID classid_val=JS_GetClassID(argv[2]);
				if(classid_val==JS_CLASS_FLOAT32_ARRAY){
					size_t offset_val;
					da_val =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_val,(size_t *)&size_val,NULL);
					val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,da_val);
					val +=offset_val;
					size_val -=offset_val;
				}else{
					if(freesrc_val){
						JS_FreeValue(ctx,argv[2]);
					}
					JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type float *");
					return JS_EXCEPTION;
				}
			}
			value=((void *)val);
			da_value=da_val;
		}else if(uniformType==SHADER_UNIFORM_VEC4){
			float * val;
			bool freesrc_val=(bool)false;
			JSValue da_val;
			int64_t size_val;
			JSClassID val_class=JS_GetClassID(argv[2]);
			if(val_class==js_ArrayProxy_class_id){
				void * opaque_val=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
				ArrayProxy_class AP_val=((ArrayProxy_class *)opaque_val)[0];
				argv[2] =AP_val.values(ctx,AP_val.opaque,(int)0,(bool)false);
				freesrc_val =(bool)true;
			}
			if(JS_IsArray(argv[2])==1){
				val =(float *)js_malloc(ctx,4*sizeof(float));
				int i;
				for(i=0;i<4;i++){
					JSValue js_val=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
					double double_vali;
					int err_vali=JS_ToFloat64(ctx,&double_vali,js_val);
					if(err_vali<0){
						JS_ThrowTypeError(ctx,(const char *)"js_val is not numeric");
						return JS_EXCEPTION;
					}
					val[i] =((float)double_vali);
					JS_FreeValue(ctx,js_val);
				}
			}else if(JS_IsArrayBuffer(argv[2])==1){
				val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,argv[2]);
			}else{
				JSClassID classid_val=JS_GetClassID(argv[2]);
				if(classid_val==JS_CLASS_FLOAT32_ARRAY){
					size_t offset_val;
					da_val =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_val,(size_t *)&size_val,NULL);
					val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,da_val);
					val +=offset_val;
					size_val -=offset_val;
				}else{
					if(freesrc_val){
						JS_FreeValue(ctx,argv[2]);
					}
					JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type float *");
					return JS_EXCEPTION;
				}
			}
			value=((void *)val);
			da_value=da_val;
		}else if(uniformType==SHADER_UNIFORM_INT||uniformType==SHADER_UNIFORM_SAMPLER2D){
			int * val;
			bool freesrc_val=(bool)false;
			JSValue da_val;
			int64_t size_val;
			JSClassID val_class=JS_GetClassID(argv[2]);
			if(val_class==js_ArrayProxy_class_id){
				void * opaque_val=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
				ArrayProxy_class AP_val=((ArrayProxy_class *)opaque_val)[0];
				argv[2] =AP_val.values(ctx,AP_val.opaque,(int)0,(bool)false);
				freesrc_val =(bool)true;
			}
			if(JS_IsArray(argv[2])==1){
				val =(int *)js_malloc(ctx,1*sizeof(int));
				JSValue js_val=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)0);
				int32_t long_val0;
				int err_val0=JS_ToInt32(ctx,&long_val0,js_val);
				if(err_val0<0){
					JS_ThrowTypeError(ctx,(const char *)"js_val is not numeric");
					return JS_EXCEPTION;
				}
				val[0] =((int)long_val0);
				JS_FreeValue(ctx,js_val);
			}else if(JS_IsArrayBuffer(argv[2])==1){
				val =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,argv[2]);
			}else{
				JSClassID classid_val=JS_GetClassID(argv[2]);
				if(classid_val==JS_CLASS_INT16_ARRAY){
					size_t offset_val;
					da_val =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_val,(size_t *)&size_val,NULL);
					val =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,da_val);
					val +=offset_val;
					size_val -=offset_val;
				}else{
					if(freesrc_val){
						JS_FreeValue(ctx,argv[2]);
					}
					JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type int *");
					return JS_EXCEPTION;
				}
			}
			value=((void *)val);
			da_value=da_val;
		}else if(uniformType==SHADER_UNIFORM_IVEC2){
			float * val;
			bool freesrc_val=(bool)false;
			JSValue da_val;
			int64_t size_val;
			JSClassID val_class=JS_GetClassID(argv[2]);
			if(val_class==js_ArrayProxy_class_id){
				void * opaque_val=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
				ArrayProxy_class AP_val=((ArrayProxy_class *)opaque_val)[0];
				argv[2] =AP_val.values(ctx,AP_val.opaque,(int)0,(bool)false);
				freesrc_val =(bool)true;
			}
			if(JS_IsArray(argv[2])==1){
				val =(float *)js_malloc(ctx,2*sizeof(float));
				int i;
				for(i=0;i<2;i++){
					JSValue js_val=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
					double double_vali;
					int err_vali=JS_ToFloat64(ctx,&double_vali,js_val);
					if(err_vali<0){
						JS_ThrowTypeError(ctx,(const char *)"js_val is not numeric");
						return JS_EXCEPTION;
					}
					val[i] =((float)double_vali);
					JS_FreeValue(ctx,js_val);
				}
			}else if(JS_IsArrayBuffer(argv[2])==1){
				val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,argv[2]);
			}else{
				JSClassID classid_val=JS_GetClassID(argv[2]);
				if(classid_val==JS_CLASS_FLOAT32_ARRAY){
					size_t offset_val;
					da_val =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_val,(size_t *)&size_val,NULL);
					val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,da_val);
					val +=offset_val;
					size_val -=offset_val;
				}else{
					if(freesrc_val){
						JS_FreeValue(ctx,argv[2]);
					}
					JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type float *");
					return JS_EXCEPTION;
				}
			}
			value=((void *)val);
			da_value=da_val;
		}else if(uniformType==SHADER_UNIFORM_IVEC3){
			float * val;
			bool freesrc_val=(bool)false;
			JSValue da_val;
			int64_t size_val;
			JSClassID val_class=JS_GetClassID(argv[2]);
			if(val_class==js_ArrayProxy_class_id){
				void * opaque_val=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
				ArrayProxy_class AP_val=((ArrayProxy_class *)opaque_val)[0];
				argv[2] =AP_val.values(ctx,AP_val.opaque,(int)0,(bool)false);
				freesrc_val =(bool)true;
			}
			if(JS_IsArray(argv[2])==1){
				val =(float *)js_malloc(ctx,3*sizeof(float));
				int i;
				for(i=0;i<3;i++){
					JSValue js_val=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
					double double_vali;
					int err_vali=JS_ToFloat64(ctx,&double_vali,js_val);
					if(err_vali<0){
						JS_ThrowTypeError(ctx,(const char *)"js_val is not numeric");
						return JS_EXCEPTION;
					}
					val[i] =((float)double_vali);
					JS_FreeValue(ctx,js_val);
				}
			}else if(JS_IsArrayBuffer(argv[2])==1){
				val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,argv[2]);
			}else{
				JSClassID classid_val=JS_GetClassID(argv[2]);
				if(classid_val==JS_CLASS_FLOAT32_ARRAY){
					size_t offset_val;
					da_val =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_val,(size_t *)&size_val,NULL);
					val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,da_val);
					val +=offset_val;
					size_val -=offset_val;
				}else{
					if(freesrc_val){
						JS_FreeValue(ctx,argv[2]);
					}
					JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type float *");
					return JS_EXCEPTION;
				}
			}
			value=((void *)val);
			da_value=da_val;
		}else if(uniformType==SHADER_UNIFORM_IVEC4){
			float * val;
			bool freesrc_val=(bool)false;
			JSValue da_val;
			int64_t size_val;
			JSClassID val_class=JS_GetClassID(argv[2]);
			if(val_class==js_ArrayProxy_class_id){
				void * opaque_val=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
				ArrayProxy_class AP_val=((ArrayProxy_class *)opaque_val)[0];
				argv[2] =AP_val.values(ctx,AP_val.opaque,(int)0,(bool)false);
				freesrc_val =(bool)true;
			}
			if(JS_IsArray(argv[2])==1){
				val =(float *)js_malloc(ctx,4*sizeof(float));
				int i;
				for(i=0;i<4;i++){
					JSValue js_val=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
					double double_vali;
					int err_vali=JS_ToFloat64(ctx,&double_vali,js_val);
					if(err_vali<0){
						JS_ThrowTypeError(ctx,(const char *)"js_val is not numeric");
						return JS_EXCEPTION;
					}
					val[i] =((float)double_vali);
					JS_FreeValue(ctx,js_val);
				}
			}else if(JS_IsArrayBuffer(argv[2])==1){
				val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,argv[2]);
			}else{
				JSClassID classid_val=JS_GetClassID(argv[2]);
				if(classid_val==JS_CLASS_FLOAT32_ARRAY){
					size_t offset_val;
					da_val =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_val,(size_t *)&size_val,NULL);
					val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,da_val);
					val +=offset_val;
					size_val -=offset_val;
				}else{
					if(freesrc_val){
						JS_FreeValue(ctx,argv[2]);
					}
					JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type float *");
					return JS_EXCEPTION;
				}
			}
			value=((void *)val);
			da_value=da_val;
		}else{
			JS_ThrowTypeError(ctx,(const char *)"unknown uniformType");
			return JS_EXCEPTION;
		}
		SetShaderValue(shader,locIndex,(const void *)value,uniformType);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetShaderValueV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Shader * ptr_shader=(Shader *)JS_GetOpaque(argv[0],js_Shader_class_id);
		if(ptr_shader==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Shader shader=*ptr_shader;
		int32_t long_locIndex;
		int err_locIndex=JS_ToInt32(ctx,&long_locIndex,argv[1]);
		if(err_locIndex<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int locIndex=((int)long_locIndex);
		int32_t long_uniformType;
		int err_uniformType=JS_ToInt32(ctx,&long_uniformType,argv[3]);
		if(err_uniformType<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int uniformType=((int)long_uniformType);
		int32_t long_count;
		int err_count=JS_ToInt32(ctx,&long_count,argv[4]);
		if(err_count<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int count=((int)long_count);
		void * value=NULL;
		JSValue da_value;
		if(uniformType==SHADER_UNIFORM_FLOAT||uniformType==SHADER_UNIFORM_VEC2||uniformType==SHADER_UNIFORM_VEC3){
			int * val;
			bool freesrc_val=(bool)false;
			JSValue da_val;
			int64_t size_val;
			JSClassID val_class=JS_GetClassID(argv[2]);
			if(val_class==js_ArrayProxy_class_id){
				void * opaque_val=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
				ArrayProxy_class AP_val=((ArrayProxy_class *)opaque_val)[0];
				argv[2] =AP_val.values(ctx,AP_val.opaque,(int)0,(bool)false);
				freesrc_val =(bool)true;
			}
			if(JS_IsArray(argv[2])==1){
				if(JS_GetLength(ctx,argv[2],&size_val)==-1){
					return JS_EXCEPTION;
				}
				val =(int *)js_malloc(ctx,size_val*sizeof(int));
				int i;
				for(i=0;i<size_val;i++){
					JSValue js_val=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
					int32_t long_vali;
					int err_vali=JS_ToInt32(ctx,&long_vali,js_val);
					if(err_vali<0){
						JS_ThrowTypeError(ctx,(const char *)"js_val is not numeric");
						return JS_EXCEPTION;
					}
					val[i] =((int)long_vali);
					JS_FreeValue(ctx,js_val);
				}
			}else if(JS_IsArrayBuffer(argv[2])==1){
				val =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,argv[2]);
			}else{
				JSClassID classid_val=JS_GetClassID(argv[2]);
				if(classid_val==JS_CLASS_INT16_ARRAY){
					size_t offset_val;
					da_val =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_val,(size_t *)&size_val,NULL);
					val =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,da_val);
					val +=offset_val;
					size_val -=offset_val;
				}else{
					if(freesrc_val){
						JS_FreeValue(ctx,argv[2]);
					}
					JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type int *");
					return JS_EXCEPTION;
				}
			}
			value=((void *)val);
			da_value=da_val;
		}else if(uniformType==SHADER_UNIFORM_INT||uniformType==SHADER_UNIFORM_SAMPLER2D||uniformType==SHADER_UNIFORM_IVEC2||uniformType==SHADER_UNIFORM_IVEC3||uniformType==SHADER_UNIFORM_IVEC4){
			float * val;
			bool freesrc_val=(bool)false;
			JSValue da_val;
			int64_t size_val;
			JSClassID val_class=JS_GetClassID(argv[2]);
			if(val_class==js_ArrayProxy_class_id){
				void * opaque_val=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
				ArrayProxy_class AP_val=((ArrayProxy_class *)opaque_val)[0];
				argv[2] =AP_val.values(ctx,AP_val.opaque,(int)0,(bool)false);
				freesrc_val =(bool)true;
			}
			if(JS_IsArray(argv[2])==1){
				if(JS_GetLength(ctx,argv[2],&size_val)==-1){
					return JS_EXCEPTION;
				}
				val =(float *)js_malloc(ctx,size_val*sizeof(float));
				int i;
				for(i=0;i<size_val;i++){
					JSValue js_val=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
					double double_vali;
					int err_vali=JS_ToFloat64(ctx,&double_vali,js_val);
					if(err_vali<0){
						JS_ThrowTypeError(ctx,(const char *)"js_val is not numeric");
						return JS_EXCEPTION;
					}
					val[i] =((float)double_vali);
					JS_FreeValue(ctx,js_val);
				}
			}else if(JS_IsArrayBuffer(argv[2])==1){
				val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,argv[2]);
			}else{
				JSClassID classid_val=JS_GetClassID(argv[2]);
				if(classid_val==JS_CLASS_FLOAT32_ARRAY){
					size_t offset_val;
					da_val =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_val,(size_t *)&size_val,NULL);
					val =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_val,da_val);
					val +=offset_val;
					size_val -=offset_val;
				}else{
					if(freesrc_val){
						JS_FreeValue(ctx,argv[2]);
					}
					JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type float *");
					return JS_EXCEPTION;
				}
			}
			value=((void *)val);
			da_value=da_val;
		}else{
			JS_ThrowTypeError(ctx,(const char *)"unknown uniformType");
			return JS_EXCEPTION;
		}
		SetShaderValueV(shader,locIndex,(const void *)value,uniformType,count);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetShaderValueMatrix(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Shader * ptr_shader=(Shader *)JS_GetOpaque(argv[0],js_Shader_class_id);
		if(ptr_shader==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Shader shader=*ptr_shader;
		int32_t long_locIndex;
		int err_locIndex=JS_ToInt32(ctx,&long_locIndex,argv[1]);
		if(err_locIndex<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int locIndex=((int)long_locIndex);
		Matrix * ptr_mat=(Matrix *)JS_GetOpaque(argv[2],js_Matrix_class_id);
		if(ptr_mat==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Matrix mat=*ptr_mat;
		SetShaderValueMatrix(shader,locIndex,mat);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetShaderValueTexture(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Shader * ptr_shader=(Shader *)JS_GetOpaque(argv[0],js_Shader_class_id);
		if(ptr_shader==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Shader shader=*ptr_shader;
		int32_t long_locIndex;
		int err_locIndex=JS_ToInt32(ctx,&long_locIndex,argv[1]);
		if(err_locIndex<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int locIndex=((int)long_locIndex);
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[2],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		SetShaderValueTexture(shader,locIndex,texture);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UnloadShader(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Shader * ptr_shader=(Shader *)JS_GetOpaque(argv[0],js_Shader_class_id);
		if(ptr_shader==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Shader shader=*ptr_shader;
		UnloadShader(shader);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetScreenToWorldRay(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		Camera * ptr_camera=(Camera *)JS_GetOpaque(argv[1],js_Camera3D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Camera camera=*ptr_camera;
		Ray returnVal=GetScreenToWorldRay(position,camera);
		Ray * ptr_ret=(Ray *)js_malloc(ctx,sizeof(Ray));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Ray_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetScreenToWorldRayEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		Camera * ptr_camera=(Camera *)JS_GetOpaque(argv[1],js_Camera3D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Camera camera=*ptr_camera;
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[2]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[3]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		Ray returnVal=GetScreenToWorldRayEx(position,camera,width,height);
		Ray * ptr_ret=(Ray *)js_malloc(ctx,sizeof(Ray));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Ray_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetWorldToScreen(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		Camera * ptr_camera=(Camera *)JS_GetOpaque(argv[1],js_Camera3D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Camera camera=*ptr_camera;
		Vector2 returnVal=GetWorldToScreen(position,camera);
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetWorldToScreenEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		Camera * ptr_camera=(Camera *)JS_GetOpaque(argv[1],js_Camera3D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Camera camera=*ptr_camera;
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[2]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[3]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		Vector2 returnVal=GetWorldToScreenEx(position,camera,width,height);
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetWorldToScreen2D(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		Camera2D * ptr_camera=(Camera2D *)JS_GetOpaque(argv[1],js_Camera2D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Camera2D camera=*ptr_camera;
		Vector2 returnVal=GetWorldToScreen2D(position,camera);
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetScreenToWorld2D(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		Camera2D * ptr_camera=(Camera2D *)JS_GetOpaque(argv[1],js_Camera2D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Camera2D camera=*ptr_camera;
		Vector2 returnVal=GetScreenToWorld2D(position,camera);
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetCameraMatrix(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Camera * ptr_camera=(Camera *)JS_GetOpaque(argv[0],js_Camera3D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Camera camera=*ptr_camera;
		Matrix returnVal=GetCameraMatrix(camera);
		Matrix * ptr_ret=(Matrix *)js_malloc(ctx,sizeof(Matrix));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Matrix_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetCameraMatrix2D(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Camera2D * ptr_camera=(Camera2D *)JS_GetOpaque(argv[0],js_Camera2D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Camera2D camera=*ptr_camera;
		Matrix returnVal=GetCameraMatrix2D(camera);
		Matrix * ptr_ret=(Matrix *)js_malloc(ctx,sizeof(Matrix));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Matrix_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_SetTargetFPS(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_fps;
		int err_fps=JS_ToInt32(ctx,&long_fps,argv[0]);
		if(err_fps<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int fps=((int)long_fps);
		SetTargetFPS(fps);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetFrameTime(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		float returnVal=GetFrameTime();
		JSValue ret=JS_NewFloat64(ctx,((double)returnVal));
		return ret;
	}
	
	static JSValue js_GetTime(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double returnVal=GetTime();
		JSValue ret=JS_NewFloat64(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_GetFPS(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetFPS();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_SetRandomSeed(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		uint32_t long_seed;
		int err_seed=JS_ToUint32(ctx,&long_seed,argv[0]);
		if(err_seed<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int seed=((unsigned int)long_seed);
		SetRandomSeed(seed);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetRandomValue(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_min;
		int err_min=JS_ToInt32(ctx,&long_min,argv[0]);
		if(err_min<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int min=((int)long_min);
		int32_t long_max;
		int err_max=JS_ToInt32(ctx,&long_max,argv[1]);
		if(err_max<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int max=((int)long_max);
		int returnVal=GetRandomValue(min,max);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_LoadRandomSequence(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		uint32_t long_count;
		int err_count=JS_ToUint32(ctx,&long_count,argv[0]);
		if(err_count<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int count=((unsigned int)long_count);
		int32_t long_min;
		int err_min=JS_ToInt32(ctx,&long_min,argv[1]);
		if(err_min<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int min=((int)long_min);
		int32_t long_max;
		int err_max=JS_ToInt32(ctx,&long_max,argv[2]);
		if(err_max<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int max=((int)long_max);
		int * returnVal=LoadRandomSequence(count,min,max);
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<count;i++){
			JSValue js_ret=JS_NewInt32(ctx,(int32_t)((long)returnVal[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		UnloadRandomSequence(returnVal);
		return ret;
	}
	
	static JSValue js_UnloadRandomSequence(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int * sequence;
		bool freesrc_sequence=(bool)false;
		int64_t size_sequence;
		JSClassID sequence_class=JS_GetClassID(argv[0]);
		if(sequence_class==js_ArrayProxy_class_id){
			void * opaque_sequence=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_sequence=((ArrayProxy_class *)opaque_sequence)[0];
			argv[0] =AP_sequence.values(ctx,AP_sequence.opaque,(int)0,(bool)false);
			freesrc_sequence =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_sequence)==-1){
				return JS_EXCEPTION;
			}
			sequence =(int *)js_malloc(ctx,size_sequence*sizeof(int));
			int i;
			for(i=0;i<size_sequence;i++){
				JSValue js_sequence=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				int32_t long_sequencei;
				int err_sequencei=JS_ToInt32(ctx,&long_sequencei,js_sequence);
				if(err_sequencei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_sequence is not numeric");
					return JS_EXCEPTION;
				}
				sequence[i] =((int)long_sequencei);
				JS_FreeValue(ctx,js_sequence);
			}
		}else{
			int32_t long_js_sequence;
			int err_js_sequence=JS_ToInt32(ctx,&long_js_sequence,argv[0]);
			if(err_js_sequence<0){
				JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
				return JS_EXCEPTION;
			}
			int js_sequence=((int)long_js_sequence);
			sequence =&js_sequence;
		}
		UnloadRandomSequence(sequence);
		if(JS_IsArray(argv[0])==1){
			JSValue js_argv0=JS_NewInt32(ctx,(int32_t)((long)sequence[0]));
			JS_DefinePropertyValueUint32(ctx,argv[0],(uint32_t)0,js_argv0,JS_PROP_C_W_E);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_TakeScreenshot(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		TakeScreenshot((const char *)fileName);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetConfigFlags(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		uint32_t long_flags;
		int err_flags=JS_ToUint32(ctx,&long_flags,argv[0]);
		if(err_flags<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int flags=((unsigned int)long_flags);
		SetConfigFlags(flags);
		return JS_UNDEFINED;
	}
	
	static JSValue js_OpenURL(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * url;
		JSValue da_url;
		int64_t size_url;
		if(JS_IsString(argv[0])==1){
			url =(char *)JS_ToCStringLen(ctx,(size_t *)&size_url,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			url =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_url,argv[0]);
		}else{
			JSClassID classid_url=JS_GetClassID(argv[0]);
			if(classid_url==JS_CLASS_INT8_ARRAY){
				size_t offset_url;
				da_url =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_url,(size_t *)&size_url,NULL);
				url =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_url,da_url);
				url +=offset_url;
				size_url -=offset_url;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		OpenURL((const char *)url);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)url);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)url);
		}else{
			JSClassID classid_url=JS_GetClassID(argv[0]);
			if(classid_url==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_url);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_TraceLog(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		int32_t long_logLevel;
		int err_logLevel=JS_ToInt32(ctx,&long_logLevel,argv[0]);
		if(err_logLevel<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int logLevel=((int)long_logLevel);
		size_t size_text=argc-1;
		if(size_text>4){
			size_text=(size_t)4;
		}
		char * * text=(char * *)js_malloc(ctx,size_text*sizeof(char *));
		memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)*text);
		int i;
		for(i=0;i<size_text;i++){
			int64_t size_texti;
			if(JS_IsString(argv[i+1])==1){
				text[i] =(char *)JS_ToCStringLen(ctx,(size_t *)&size_texti,argv[i+1]);
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)text[i]);
			}else if(JS_IsArrayBuffer(argv[i+1])==1){
				text[i] =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_texti,argv[i+1]);
			}else{
				JSClassID classid_texti=JS_GetClassID(argv[i+1]);
				if(classid_texti==JS_CLASS_INT8_ARRAY){
					size_t offset_texti;
					JSValue da_texti=JS_GetTypedArrayBuffer(ctx,argv[i+1],&offset_texti,(size_t *)&size_texti,NULL);
					text[i] =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_texti,da_texti);
					text[i] +=offset_texti;
					size_texti -=offset_texti;
					memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_texti);
				}else{
					JS_ThrowTypeError(ctx,(const char *)"argv[i+1] does not match type char *");
					return JS_EXCEPTION;
				}
			}
		}
		if(size_text==0){
			return JS_EXCEPTION;
		}else if(size_text==1){
			TraceLog(logLevel,(const char *)text[1],text[2],text[3]);
		}else if(size_text==2){
			TraceLog(logLevel,(const char *)text[1],text[2],text[3]);
		}else if(size_text==3){
			TraceLog(logLevel,(const char *)text[1],text[2],text[3]);
		}
		memoryClear(ctx,memoryHead);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetTraceLogLevel(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_logLevel;
		int err_logLevel=JS_ToInt32(ctx,&long_logLevel,argv[0]);
		if(err_logLevel<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int logLevel=((int)long_logLevel);
		SetTraceLogLevel(logLevel);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetLoadFileDataCallback(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		trampolineContext ctx_callback;
		ctx_callback.ctx=ctx;
		ctx_callback.func_obj=argv[0];
		if(JS_IsUndefined(argv[0])||JS_IsNull(argv[0])){
			JS_FreeValue(LoadFileDataCallback_arr[0].ctx,LoadFileDataCallback_arr[0].func_obj);
			JS_FreeContext(LoadFileDataCallback_arr[0].ctx);
			LoadFileDataCallback_arr =NULL;
		}else if(JS_IsFunction(ctx,argv[0])==1){
			if(LoadFileDataCallback_arr!=NULL){
				JS_FreeValue(LoadFileDataCallback_arr[0].ctx,LoadFileDataCallback_arr[0].func_obj);
				JS_FreeContext(LoadFileDataCallback_arr[0].ctx);
			}
			LoadFileDataCallback_arr =&ctx_callback;
		}else{
			return JS_EXCEPTION;
		}
		void * callback;
		if(LoadFileDataCallback_arr==NULL){
			callback =NULL;
		}else{
			callback =callback_LoadFileDataCallback;
		}
		JS_DupValue(ctx,argv[0]);
		SetLoadFileDataCallback(callback);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetSaveFileDataCallback(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		trampolineContext ctx_callback;
		ctx_callback.ctx=ctx;
		ctx_callback.func_obj=argv[0];
		if(JS_IsUndefined(argv[0])||JS_IsNull(argv[0])){
			JS_FreeValue(SaveFileDataCallback_arr[0].ctx,SaveFileDataCallback_arr[0].func_obj);
			JS_FreeContext(SaveFileDataCallback_arr[0].ctx);
			SaveFileDataCallback_arr =NULL;
		}else if(JS_IsFunction(ctx,argv[0])==1){
			if(SaveFileDataCallback_arr!=NULL){
				JS_FreeValue(SaveFileDataCallback_arr[0].ctx,SaveFileDataCallback_arr[0].func_obj);
				JS_FreeContext(SaveFileDataCallback_arr[0].ctx);
			}
			SaveFileDataCallback_arr =&ctx_callback;
		}else{
			return JS_EXCEPTION;
		}
		void * callback;
		if(SaveFileDataCallback_arr==NULL){
			callback =NULL;
		}else{
			callback =callback_SaveFileDataCallback;
		}
		JS_DupValue(ctx,argv[0]);
		SetSaveFileDataCallback(callback);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetLoadFileTextCallback(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		trampolineContext ctx_callback;
		ctx_callback.ctx=ctx;
		ctx_callback.func_obj=argv[0];
		if(JS_IsUndefined(argv[0])||JS_IsNull(argv[0])){
			JS_FreeValue(LoadFileTextCallback_arr[0].ctx,LoadFileTextCallback_arr[0].func_obj);
			JS_FreeContext(LoadFileTextCallback_arr[0].ctx);
			LoadFileTextCallback_arr =NULL;
		}else if(JS_IsFunction(ctx,argv[0])==1){
			if(LoadFileTextCallback_arr!=NULL){
				JS_FreeValue(LoadFileTextCallback_arr[0].ctx,LoadFileTextCallback_arr[0].func_obj);
				JS_FreeContext(LoadFileTextCallback_arr[0].ctx);
			}
			LoadFileTextCallback_arr =&ctx_callback;
		}else{
			return JS_EXCEPTION;
		}
		void * callback;
		if(LoadFileTextCallback_arr==NULL){
			callback =NULL;
		}else{
			callback =callback_LoadFileTextCallback;
		}
		JS_DupValue(ctx,argv[0]);
		SetLoadFileTextCallback(callback);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetSaveFileTextCallback(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		trampolineContext ctx_callback;
		ctx_callback.ctx=ctx;
		ctx_callback.func_obj=argv[0];
		if(JS_IsUndefined(argv[0])||JS_IsNull(argv[0])){
			JS_FreeValue(SaveFileTextCallback_arr[0].ctx,SaveFileTextCallback_arr[0].func_obj);
			JS_FreeContext(SaveFileTextCallback_arr[0].ctx);
			SaveFileTextCallback_arr =NULL;
		}else if(JS_IsFunction(ctx,argv[0])==1){
			if(SaveFileTextCallback_arr!=NULL){
				JS_FreeValue(SaveFileTextCallback_arr[0].ctx,SaveFileTextCallback_arr[0].func_obj);
				JS_FreeContext(SaveFileTextCallback_arr[0].ctx);
			}
			SaveFileTextCallback_arr =&ctx_callback;
		}else{
			return JS_EXCEPTION;
		}
		void * callback;
		if(SaveFileTextCallback_arr==NULL){
			callback =NULL;
		}else{
			callback =callback_SaveFileTextCallback;
		}
		JS_DupValue(ctx,argv[0]);
		SetSaveFileTextCallback(callback);
		return JS_UNDEFINED;
	}
	
	static JSValue js_LoadFileData(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int * dataSize;
		bool freesrc_dataSize=(bool)false;
		int64_t size_dataSize;
		JSClassID dataSize_class=JS_GetClassID(argv[1]);
		if(dataSize_class==js_ArrayProxy_class_id){
			void * opaque_dataSize=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_dataSize=((ArrayProxy_class *)opaque_dataSize)[0];
			argv[1] =AP_dataSize.values(ctx,AP_dataSize.opaque,(int)0,(bool)false);
			freesrc_dataSize =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_dataSize)==-1){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)fileName);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)fileName);
				}else{
					JSClassID classid_fileName=JS_GetClassID(argv[0]);
					if(classid_fileName==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_fileName);
					}
				}
				return JS_EXCEPTION;
			}
			dataSize =(int *)js_malloc(ctx,size_dataSize*sizeof(int));
			int i;
			for(i=0;i<size_dataSize;i++){
				JSValue js_dataSize=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_dataSizei;
				int err_dataSizei=JS_ToInt32(ctx,&long_dataSizei,js_dataSize);
				if(err_dataSizei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_dataSize is not numeric");
					return JS_EXCEPTION;
				}
				dataSize[i] =((int)long_dataSizei);
				JS_FreeValue(ctx,js_dataSize);
			}
		}else{
			int32_t long_js_dataSize;
			int err_js_dataSize=JS_ToInt32(ctx,&long_js_dataSize,argv[1]);
			if(err_js_dataSize<0){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)fileName);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)fileName);
				}else{
					JSClassID classid_fileName=JS_GetClassID(argv[0]);
					if(classid_fileName==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_fileName);
					}
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
				return JS_EXCEPTION;
			}
			int js_dataSize=((int)long_js_dataSize);
			dataSize =&js_dataSize;
		}
		void * returnVal=(void *)LoadFileData((const char *)fileName,dataSize);
		if(JS_IsArray(argv[1])==1){
			JSValue js_argv1=JS_NewInt32(ctx,(int32_t)((long)dataSize[0]));
			JS_DefinePropertyValueUint32(ctx,argv[1],(uint32_t)0,js_argv1,JS_PROP_C_W_E);
		}
		JSValue ret;
		ret =JS_NewArrayBufferCopy(ctx,(const uint8_t *)returnVal,(size_t)dataSize[0]);
		UnloadFileData((unsigned char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)dataSize);
		}
		return ret;
	}
	
	static JSValue js_SaveFileData(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fileName);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				JSValue da_fileName=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileName);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		void * data;
		int64_t size_data;
		if(JS_IsArrayBuffer(argv[1])==1){
			data =(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[1]);
		}else{
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type void *");
			return JS_EXCEPTION;
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[2]);
		if(err_dataSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		bool returnVal=SaveFileData((const char *)fileName,data,dataSize);
		JSValue ret=JS_NewBool(ctx,returnVal);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_ExportDataAsCode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		unsigned char * data;
		int64_t size_data;
		JSClassID data_class=JS_GetClassID(argv[0]);
		if(data_class==js_ArrayProxy_class_id){
			void * opaque_data=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_data=((ArrayProxy_class *)opaque_data)[0];
			argv[0] =AP_data.values(ctx,AP_data.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[0]);
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_data)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			data =(unsigned char *)js_malloc(ctx,size_data*sizeof(unsigned char));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)data);
			int i;
			for(i=0;i<size_data;i++){
				JSValue js_data=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				uint32_t long_datai;
				int err_datai=JS_ToUint32(ctx,&long_datai,js_data);
				if(err_datai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_data is not numeric");
					return JS_EXCEPTION;
				}
				data[i] =((unsigned char)long_datai);
				JS_FreeValue(ctx,js_data);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[0]);
		}else{
			JSClassID classid_data=JS_GetClassID(argv[0]);
			if(classid_data==JS_CLASS_UINT8_ARRAY||classid_data==JS_CLASS_UINT8C_ARRAY){
				size_t offset_data;
				JSValue da_data=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_data,(size_t *)&size_data,NULL);
				data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,da_data);
				data +=offset_data;
				size_data -=offset_data;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_data);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[1]);
		if(err_dataSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		char * fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[2])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[2]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fileName);
		}else if(JS_IsArrayBuffer(argv[2])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[2]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[2]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				JSValue da_fileName=JS_GetTypedArrayBuffer(ctx,argv[2],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileName);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=ExportDataAsCode((const unsigned char *)data,dataSize,(const char *)fileName);
		JSValue ret=JS_NewBool(ctx,returnVal);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_LoadFileText(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=LoadFileText((const char *)fileName);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		UnloadFileText(returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_SaveFileText(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fileName);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				JSValue da_fileName=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileName);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * text;
		int64_t size_text;
		if(JS_IsString(argv[1])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[1]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)text);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[1]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[1]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				JSValue da_text=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_text);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=SaveFileText((const char *)fileName,(const char *)text);
		JSValue ret=JS_NewBool(ctx,returnVal);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_FileExists(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=FileExists((const char *)fileName);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_DirectoryExists(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * dirPath;
		JSValue da_dirPath;
		int64_t size_dirPath;
		if(JS_IsString(argv[0])==1){
			dirPath =(char *)JS_ToCStringLen(ctx,(size_t *)&size_dirPath,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			dirPath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_dirPath,argv[0]);
		}else{
			JSClassID classid_dirPath=JS_GetClassID(argv[0]);
			if(classid_dirPath==JS_CLASS_INT8_ARRAY){
				size_t offset_dirPath;
				da_dirPath =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_dirPath,(size_t *)&size_dirPath,NULL);
				dirPath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_dirPath,da_dirPath);
				dirPath +=offset_dirPath;
				size_dirPath -=offset_dirPath;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=DirectoryExists((const char *)dirPath);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)dirPath);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)dirPath);
		}else{
			JSClassID classid_dirPath=JS_GetClassID(argv[0]);
			if(classid_dirPath==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_dirPath);
			}
		}
		return ret;
	}
	
	static JSValue js_IsFileExtension(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fileName);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				JSValue da_fileName=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileName);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * ext;
		int64_t size_ext;
		if(JS_IsString(argv[1])==1){
			ext =(char *)JS_ToCStringLen(ctx,(size_t *)&size_ext,argv[1]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)ext);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			ext =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_ext,argv[1]);
		}else{
			JSClassID classid_ext=JS_GetClassID(argv[1]);
			if(classid_ext==JS_CLASS_INT8_ARRAY){
				size_t offset_ext;
				JSValue da_ext=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_ext,(size_t *)&size_ext,NULL);
				ext =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_ext,da_ext);
				ext +=offset_ext;
				size_ext -=offset_ext;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_ext);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=IsFileExtension((const char *)fileName,(const char *)ext);
		JSValue ret=JS_NewBool(ctx,returnVal);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_GetFileLength(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int returnVal=GetFileLength((const char *)fileName);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_GetFileExtension(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=(char *)GetFileExtension((const char *)fileName);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_GetFileName(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * filePath;
		JSValue da_filePath;
		int64_t size_filePath;
		if(JS_IsString(argv[0])==1){
			filePath =(char *)JS_ToCStringLen(ctx,(size_t *)&size_filePath,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			filePath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_filePath,argv[0]);
		}else{
			JSClassID classid_filePath=JS_GetClassID(argv[0]);
			if(classid_filePath==JS_CLASS_INT8_ARRAY){
				size_t offset_filePath;
				da_filePath =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_filePath,(size_t *)&size_filePath,NULL);
				filePath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_filePath,da_filePath);
				filePath +=offset_filePath;
				size_filePath -=offset_filePath;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=(char *)GetFileName((const char *)filePath);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)filePath);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)filePath);
		}else{
			JSClassID classid_filePath=JS_GetClassID(argv[0]);
			if(classid_filePath==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_filePath);
			}
		}
		return ret;
	}
	
	static JSValue js_GetFileNameWithoutExt(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * filePath;
		JSValue da_filePath;
		int64_t size_filePath;
		if(JS_IsString(argv[0])==1){
			filePath =(char *)JS_ToCStringLen(ctx,(size_t *)&size_filePath,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			filePath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_filePath,argv[0]);
		}else{
			JSClassID classid_filePath=JS_GetClassID(argv[0]);
			if(classid_filePath==JS_CLASS_INT8_ARRAY){
				size_t offset_filePath;
				da_filePath =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_filePath,(size_t *)&size_filePath,NULL);
				filePath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_filePath,da_filePath);
				filePath +=offset_filePath;
				size_filePath -=offset_filePath;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=(char *)GetFileNameWithoutExt((const char *)filePath);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)filePath);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)filePath);
		}else{
			JSClassID classid_filePath=JS_GetClassID(argv[0]);
			if(classid_filePath==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_filePath);
			}
		}
		return ret;
	}
	
	static JSValue js_GetDirectoryPath(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * filePath;
		JSValue da_filePath;
		int64_t size_filePath;
		if(JS_IsString(argv[0])==1){
			filePath =(char *)JS_ToCStringLen(ctx,(size_t *)&size_filePath,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			filePath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_filePath,argv[0]);
		}else{
			JSClassID classid_filePath=JS_GetClassID(argv[0]);
			if(classid_filePath==JS_CLASS_INT8_ARRAY){
				size_t offset_filePath;
				da_filePath =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_filePath,(size_t *)&size_filePath,NULL);
				filePath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_filePath,da_filePath);
				filePath +=offset_filePath;
				size_filePath -=offset_filePath;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=(char *)GetDirectoryPath((const char *)filePath);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)filePath);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)filePath);
		}else{
			JSClassID classid_filePath=JS_GetClassID(argv[0]);
			if(classid_filePath==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_filePath);
			}
		}
		return ret;
	}
	
	static JSValue js_GetPrevDirectoryPath(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * dirPath;
		JSValue da_dirPath;
		int64_t size_dirPath;
		if(JS_IsString(argv[0])==1){
			dirPath =(char *)JS_ToCStringLen(ctx,(size_t *)&size_dirPath,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			dirPath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_dirPath,argv[0]);
		}else{
			JSClassID classid_dirPath=JS_GetClassID(argv[0]);
			if(classid_dirPath==JS_CLASS_INT8_ARRAY){
				size_t offset_dirPath;
				da_dirPath =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_dirPath,(size_t *)&size_dirPath,NULL);
				dirPath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_dirPath,da_dirPath);
				dirPath +=offset_dirPath;
				size_dirPath -=offset_dirPath;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=(char *)GetPrevDirectoryPath((const char *)dirPath);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)dirPath);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)dirPath);
		}else{
			JSClassID classid_dirPath=JS_GetClassID(argv[0]);
			if(classid_dirPath==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_dirPath);
			}
		}
		return ret;
	}
	
	static JSValue js_GetWorkingDirectory(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * returnVal=(char *)GetWorkingDirectory();
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		return ret;
	}
	
	static JSValue js_GetApplicationDirectory(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * returnVal=(char *)GetApplicationDirectory();
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		return ret;
	}
	
	static JSValue js_MakeDirectory(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * dirPath;
		JSValue da_dirPath;
		int64_t size_dirPath;
		if(JS_IsString(argv[0])==1){
			dirPath =(char *)JS_ToCStringLen(ctx,(size_t *)&size_dirPath,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			dirPath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_dirPath,argv[0]);
		}else{
			JSClassID classid_dirPath=JS_GetClassID(argv[0]);
			if(classid_dirPath==JS_CLASS_INT8_ARRAY){
				size_t offset_dirPath;
				da_dirPath =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_dirPath,(size_t *)&size_dirPath,NULL);
				dirPath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_dirPath,da_dirPath);
				dirPath +=offset_dirPath;
				size_dirPath -=offset_dirPath;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int returnVal=MakeDirectory((const char *)dirPath);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)dirPath);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)dirPath);
		}else{
			JSClassID classid_dirPath=JS_GetClassID(argv[0]);
			if(classid_dirPath==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_dirPath);
			}
		}
		return ret;
	}
	
	static JSValue js_ChangeDirectory(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * dir;
		JSValue da_dir;
		int64_t size_dir;
		if(JS_IsString(argv[0])==1){
			dir =(char *)JS_ToCStringLen(ctx,(size_t *)&size_dir,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			dir =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_dir,argv[0]);
		}else{
			JSClassID classid_dir=JS_GetClassID(argv[0]);
			if(classid_dir==JS_CLASS_INT8_ARRAY){
				size_t offset_dir;
				da_dir =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_dir,(size_t *)&size_dir,NULL);
				dir =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_dir,da_dir);
				dir +=offset_dir;
				size_dir -=offset_dir;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=ChangeDirectory((const char *)dir);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)dir);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)dir);
		}else{
			JSClassID classid_dir=JS_GetClassID(argv[0]);
			if(classid_dir==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_dir);
			}
		}
		return ret;
	}
	
	static JSValue js_IsPathFile(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * path;
		JSValue da_path;
		int64_t size_path;
		if(JS_IsString(argv[0])==1){
			path =(char *)JS_ToCStringLen(ctx,(size_t *)&size_path,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			path =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_path,argv[0]);
		}else{
			JSClassID classid_path=JS_GetClassID(argv[0]);
			if(classid_path==JS_CLASS_INT8_ARRAY){
				size_t offset_path;
				da_path =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_path,(size_t *)&size_path,NULL);
				path =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_path,da_path);
				path +=offset_path;
				size_path -=offset_path;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=IsPathFile((const char *)path);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)path);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)path);
		}else{
			JSClassID classid_path=JS_GetClassID(argv[0]);
			if(classid_path==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_path);
			}
		}
		return ret;
	}
	
	static JSValue js_IsFileNameValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=IsFileNameValid((const char *)fileName);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_LoadDirectoryFiles(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * dirPath;
		JSValue da_dirPath;
		int64_t size_dirPath;
		if(JS_IsString(argv[0])==1){
			dirPath =(char *)JS_ToCStringLen(ctx,(size_t *)&size_dirPath,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			dirPath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_dirPath,argv[0]);
		}else{
			JSClassID classid_dirPath=JS_GetClassID(argv[0]);
			if(classid_dirPath==JS_CLASS_INT8_ARRAY){
				size_t offset_dirPath;
				da_dirPath =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_dirPath,(size_t *)&size_dirPath,NULL);
				dirPath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_dirPath,da_dirPath);
				dirPath +=offset_dirPath;
				size_dirPath -=offset_dirPath;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		FilePathList files=LoadDirectoryFiles((const char *)dirPath);
		JSValue ret=JS_NewArray(ctx);
		int i;
		for(i=0;i<files.count;i++){
			JSValue str=JS_NewString(ctx,(const char *)files.paths[i]);
			JS_SetPropertyUint32(ctx,ret,(uint32_t)i,str);
		}
		UnloadDirectoryFiles(files);
		JS_FreeCString(ctx,(const char *)dirPath);
		return ret;
	}
	
	static JSValue js_LoadDirectoryFilesEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * basePath;
		JSValue da_basePath;
		int64_t size_basePath;
		if(JS_IsString(argv[0])==1){
			basePath =(char *)JS_ToCStringLen(ctx,(size_t *)&size_basePath,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			basePath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_basePath,argv[0]);
		}else{
			JSClassID classid_basePath=JS_GetClassID(argv[0]);
			if(classid_basePath==JS_CLASS_INT8_ARRAY){
				size_t offset_basePath;
				da_basePath =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_basePath,(size_t *)&size_basePath,NULL);
				basePath =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_basePath,da_basePath);
				basePath +=offset_basePath;
				size_basePath -=offset_basePath;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * filter;
		JSValue da_filter;
		int64_t size_filter;
		if(JS_IsString(argv[1])==1){
			filter =(char *)JS_ToCStringLen(ctx,(size_t *)&size_filter,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			filter =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_filter,argv[1]);
		}else{
			JSClassID classid_filter=JS_GetClassID(argv[1]);
			if(classid_filter==JS_CLASS_INT8_ARRAY){
				size_t offset_filter;
				da_filter =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_filter,(size_t *)&size_filter,NULL);
				filter =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_filter,da_filter);
				filter +=offset_filter;
				size_filter -=offset_filter;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int js_scanSubdirs=JS_ToBool(ctx,argv[2]);
		if(js_scanSubdirs<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not a bool");
			return JS_EXCEPTION;
		}
		bool scanSubdirs=(bool)js_scanSubdirs;
		FilePathList files=LoadDirectoryFilesEx((const char *)basePath,(const char *)filter,scanSubdirs);
		JSValue ret=JS_NewArray(ctx);
		int i;
		for(i=0;i<files.count;i++){
			JSValue str=JS_NewString(ctx,(const char *)files.paths[i]);
			JS_SetPropertyUint32(ctx,ret,(uint32_t)i,str);
		}
		UnloadDirectoryFiles(files);
		JS_FreeCString(ctx,(const char *)basePath);
		JS_FreeCString(ctx,(const char *)filter);
		return ret;
	}
	
	static JSValue js_IsFileDropped(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		bool returnVal=IsFileDropped();
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_LoadDroppedFiles(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		FilePathList files=LoadDroppedFiles();
		JSValue ret=JS_NewArray(ctx);
		int i;
		for(i=0;i<files.count;i++){
			JSValue str=JS_NewString(ctx,(const char *)files.paths[i]);
			JS_SetPropertyUint32(ctx,ret,(uint32_t)i,str);
		}
		UnloadDroppedFiles(files);
		return ret;
	}
	
	static JSValue js_GetFileModTime(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		long returnVal=GetFileModTime((const char *)fileName);
		JSValue ret=JS_NewInt32(ctx,(int32_t)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_CompressData(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		unsigned char * data;
		int64_t size_data;
		JSClassID data_class=JS_GetClassID(argv[0]);
		if(data_class==js_ArrayProxy_class_id){
			void * opaque_data=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_data=((ArrayProxy_class *)opaque_data)[0];
			argv[0] =AP_data.values(ctx,AP_data.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[0]);
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_data)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			data =(unsigned char *)js_malloc(ctx,size_data*sizeof(unsigned char));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)data);
			int i;
			for(i=0;i<size_data;i++){
				JSValue js_data=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				uint32_t long_datai;
				int err_datai=JS_ToUint32(ctx,&long_datai,js_data);
				if(err_datai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_data is not numeric");
					return JS_EXCEPTION;
				}
				data[i] =((unsigned char)long_datai);
				JS_FreeValue(ctx,js_data);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[0]);
		}else{
			JSClassID classid_data=JS_GetClassID(argv[0]);
			if(classid_data==JS_CLASS_UINT8_ARRAY||classid_data==JS_CLASS_UINT8C_ARRAY){
				size_t offset_data;
				JSValue da_data=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_data,(size_t *)&size_data,NULL);
				data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,da_data);
				data +=offset_data;
				size_data -=offset_data;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_data);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[1]);
		if(err_dataSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		int * compDataSize;
		int64_t size_compDataSize;
		JSClassID compDataSize_class=JS_GetClassID(argv[2]);
		if(compDataSize_class==js_ArrayProxy_class_id){
			void * opaque_compDataSize=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_compDataSize=((ArrayProxy_class *)opaque_compDataSize)[0];
			argv[2] =AP_compDataSize.values(ctx,AP_compDataSize.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[2]);
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_compDataSize)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			compDataSize =(int *)js_malloc(ctx,size_compDataSize*sizeof(int));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)compDataSize);
			int i;
			for(i=0;i<size_compDataSize;i++){
				JSValue js_compDataSize=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				int32_t long_compDataSizei;
				int err_compDataSizei=JS_ToInt32(ctx,&long_compDataSizei,js_compDataSize);
				if(err_compDataSizei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_compDataSize is not numeric");
					return JS_EXCEPTION;
				}
				compDataSize[i] =((int)long_compDataSizei);
				JS_FreeValue(ctx,js_compDataSize);
			}
		}else if(JS_IsArrayBuffer(argv[2])==1){
			compDataSize =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_compDataSize,argv[2]);
		}else{
			JSClassID classid_compDataSize=JS_GetClassID(argv[2]);
			if(classid_compDataSize==JS_CLASS_INT16_ARRAY){
				size_t offset_compDataSize;
				JSValue da_compDataSize=JS_GetTypedArrayBuffer(ctx,argv[2],&offset_compDataSize,(size_t *)&size_compDataSize,NULL);
				compDataSize =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_compDataSize,da_compDataSize);
				compDataSize +=offset_compDataSize;
				size_compDataSize -=offset_compDataSize;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_compDataSize);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=CompressData((const unsigned char *)data,dataSize,compDataSize);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_DecompressData(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		unsigned char * compData;
		bool freesrc_compData=(bool)false;
		JSValue da_compData;
		int64_t size_compData;
		JSClassID compData_class=JS_GetClassID(argv[0]);
		if(compData_class==js_ArrayProxy_class_id){
			void * opaque_compData=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_compData=((ArrayProxy_class *)opaque_compData)[0];
			argv[0] =AP_compData.values(ctx,AP_compData.opaque,(int)0,(bool)false);
			freesrc_compData =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_compData)==-1){
				return JS_EXCEPTION;
			}
			compData =(unsigned char *)js_malloc(ctx,size_compData*sizeof(unsigned char));
			int i;
			for(i=0;i<size_compData;i++){
				JSValue js_compData=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				uint32_t long_compDatai;
				int err_compDatai=JS_ToUint32(ctx,&long_compDatai,js_compData);
				if(err_compDatai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_compData is not numeric");
					return JS_EXCEPTION;
				}
				compData[i] =((unsigned char)long_compDatai);
				JS_FreeValue(ctx,js_compData);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			compData =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_compData,argv[0]);
		}else{
			JSClassID classid_compData=JS_GetClassID(argv[0]);
			if(classid_compData==JS_CLASS_UINT8_ARRAY||classid_compData==JS_CLASS_UINT8C_ARRAY){
				size_t offset_compData;
				da_compData =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_compData,(size_t *)&size_compData,NULL);
				compData =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_compData,da_compData);
				compData +=offset_compData;
				size_compData -=offset_compData;
			}else{
				if(freesrc_compData){
					JS_FreeValue(ctx,argv[0]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_compDataSize;
		int err_compDataSize=JS_ToInt32(ctx,&long_compDataSize,argv[1]);
		if(err_compDataSize<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)compData);
			}else{
				JSClassID classid_compData=JS_GetClassID(argv[0]);
				if(classid_compData==JS_CLASS_UINT8_ARRAY&&classid_compData==JS_CLASS_UINT8C_ARRAY){
					js_free(ctx,(void *)&da_compData);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int compDataSize=((int)long_compDataSize);
		int * dataSize;
		bool freesrc_dataSize=(bool)false;
		int64_t size_dataSize;
		JSClassID dataSize_class=JS_GetClassID(argv[2]);
		if(dataSize_class==js_ArrayProxy_class_id){
			void * opaque_dataSize=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_dataSize=((ArrayProxy_class *)opaque_dataSize)[0];
			argv[2] =AP_dataSize.values(ctx,AP_dataSize.opaque,(int)0,(bool)false);
			freesrc_dataSize =(bool)true;
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_dataSize)==-1){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)compData);
				}else{
					JSClassID classid_compData=JS_GetClassID(argv[0]);
					if(classid_compData==JS_CLASS_UINT8_ARRAY&&classid_compData==JS_CLASS_UINT8C_ARRAY){
						js_free(ctx,(void *)&da_compData);
					}
				}
				return JS_EXCEPTION;
			}
			dataSize =(int *)js_malloc(ctx,size_dataSize*sizeof(int));
			int i;
			for(i=0;i<size_dataSize;i++){
				JSValue js_dataSize=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				int32_t long_dataSizei;
				int err_dataSizei=JS_ToInt32(ctx,&long_dataSizei,js_dataSize);
				if(err_dataSizei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_dataSize is not numeric");
					return JS_EXCEPTION;
				}
				dataSize[i] =((int)long_dataSizei);
				JS_FreeValue(ctx,js_dataSize);
			}
		}else{
			int32_t long_js_dataSize;
			int err_js_dataSize=JS_ToInt32(ctx,&long_js_dataSize,argv[2]);
			if(err_js_dataSize<0){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)compData);
				}else{
					JSClassID classid_compData=JS_GetClassID(argv[0]);
					if(classid_compData==JS_CLASS_UINT8_ARRAY&&classid_compData==JS_CLASS_UINT8C_ARRAY){
						js_free(ctx,(void *)&da_compData);
					}
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
				return JS_EXCEPTION;
			}
			int js_dataSize=((int)long_js_dataSize);
			dataSize =&js_dataSize;
		}
		char * returnVal=DecompressData((const unsigned char *)compData,compDataSize,dataSize);
		if(JS_IsArray(argv[2])==1){
			JSValue js_argv2=JS_NewInt32(ctx,(int32_t)((long)dataSize[0]));
			JS_DefinePropertyValueUint32(ctx,argv[2],(uint32_t)0,js_argv2,JS_PROP_C_W_E);
		}
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)compData);
		}else{
			JSClassID classid_compData=JS_GetClassID(argv[0]);
			if(classid_compData==JS_CLASS_UINT8_ARRAY&&classid_compData==JS_CLASS_UINT8C_ARRAY){
				js_free(ctx,(void *)&da_compData);
			}
		}
		if(JS_IsArray(argv[2])==1){
			js_free(ctx,(void *)dataSize);
		}
		return ret;
	}
	
	static JSValue js_EncodeDataBase64(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		unsigned char * data;
		int64_t size_data;
		JSClassID data_class=JS_GetClassID(argv[0]);
		if(data_class==js_ArrayProxy_class_id){
			void * opaque_data=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_data=((ArrayProxy_class *)opaque_data)[0];
			argv[0] =AP_data.values(ctx,AP_data.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[0]);
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_data)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			data =(unsigned char *)js_malloc(ctx,size_data*sizeof(unsigned char));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)data);
			int i;
			for(i=0;i<size_data;i++){
				JSValue js_data=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				uint32_t long_datai;
				int err_datai=JS_ToUint32(ctx,&long_datai,js_data);
				if(err_datai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_data is not numeric");
					return JS_EXCEPTION;
				}
				data[i] =((unsigned char)long_datai);
				JS_FreeValue(ctx,js_data);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[0]);
		}else{
			JSClassID classid_data=JS_GetClassID(argv[0]);
			if(classid_data==JS_CLASS_UINT8_ARRAY||classid_data==JS_CLASS_UINT8C_ARRAY){
				size_t offset_data;
				JSValue da_data=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_data,(size_t *)&size_data,NULL);
				data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,da_data);
				data +=offset_data;
				size_data -=offset_data;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_data);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[1]);
		if(err_dataSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		int * outputSize;
		int64_t size_outputSize;
		JSClassID outputSize_class=JS_GetClassID(argv[2]);
		if(outputSize_class==js_ArrayProxy_class_id){
			void * opaque_outputSize=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_outputSize=((ArrayProxy_class *)opaque_outputSize)[0];
			argv[2] =AP_outputSize.values(ctx,AP_outputSize.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[2]);
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_outputSize)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			outputSize =(int *)js_malloc(ctx,size_outputSize*sizeof(int));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)outputSize);
			int i;
			for(i=0;i<size_outputSize;i++){
				JSValue js_outputSize=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				int32_t long_outputSizei;
				int err_outputSizei=JS_ToInt32(ctx,&long_outputSizei,js_outputSize);
				if(err_outputSizei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_outputSize is not numeric");
					return JS_EXCEPTION;
				}
				outputSize[i] =((int)long_outputSizei);
				JS_FreeValue(ctx,js_outputSize);
			}
		}else if(JS_IsArrayBuffer(argv[2])==1){
			outputSize =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_outputSize,argv[2]);
		}else{
			JSClassID classid_outputSize=JS_GetClassID(argv[2]);
			if(classid_outputSize==JS_CLASS_INT16_ARRAY){
				size_t offset_outputSize;
				JSValue da_outputSize=JS_GetTypedArrayBuffer(ctx,argv[2],&offset_outputSize,(size_t *)&size_outputSize,NULL);
				outputSize =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_outputSize,da_outputSize);
				outputSize +=offset_outputSize;
				size_outputSize -=offset_outputSize;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_outputSize);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=EncodeDataBase64((const unsigned char *)data,dataSize,outputSize);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_DecodeDataBase64(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)text);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				JSValue da_text=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_text);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int * outputSize;
		int64_t size_outputSize;
		JSClassID outputSize_class=JS_GetClassID(argv[1]);
		if(outputSize_class==js_ArrayProxy_class_id){
			void * opaque_outputSize=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_outputSize=((ArrayProxy_class *)opaque_outputSize)[0];
			argv[1] =AP_outputSize.values(ctx,AP_outputSize.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[1]);
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_outputSize)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			outputSize =(int *)js_malloc(ctx,size_outputSize*sizeof(int));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)outputSize);
			int i;
			for(i=0;i<size_outputSize;i++){
				JSValue js_outputSize=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_outputSizei;
				int err_outputSizei=JS_ToInt32(ctx,&long_outputSizei,js_outputSize);
				if(err_outputSizei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_outputSize is not numeric");
					return JS_EXCEPTION;
				}
				outputSize[i] =((int)long_outputSizei);
				JS_FreeValue(ctx,js_outputSize);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			outputSize =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_outputSize,argv[1]);
		}else{
			JSClassID classid_outputSize=JS_GetClassID(argv[1]);
			if(classid_outputSize==JS_CLASS_INT16_ARRAY){
				size_t offset_outputSize;
				JSValue da_outputSize=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_outputSize,(size_t *)&size_outputSize,NULL);
				outputSize =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_outputSize,da_outputSize);
				outputSize +=offset_outputSize;
				size_outputSize -=offset_outputSize;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_outputSize);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=DecodeDataBase64((const char *)text,outputSize);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_ComputeCRC32(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		unsigned char * data;
		bool freesrc_data=(bool)false;
		JSValue da_data;
		int64_t size_data;
		JSClassID data_class=JS_GetClassID(argv[0]);
		if(data_class==js_ArrayProxy_class_id){
			void * opaque_data=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_data=((ArrayProxy_class *)opaque_data)[0];
			argv[0] =AP_data.values(ctx,AP_data.opaque,(int)0,(bool)false);
			freesrc_data =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_data)==-1){
				return JS_EXCEPTION;
			}
			data =(unsigned char *)js_malloc(ctx,size_data*sizeof(unsigned char));
			int i;
			for(i=0;i<size_data;i++){
				JSValue js_data=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				uint32_t long_datai;
				int err_datai=JS_ToUint32(ctx,&long_datai,js_data);
				if(err_datai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_data is not numeric");
					return JS_EXCEPTION;
				}
				data[i] =((unsigned char)long_datai);
				JS_FreeValue(ctx,js_data);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[0]);
		}else{
			JSClassID classid_data=JS_GetClassID(argv[0]);
			if(classid_data==JS_CLASS_UINT8_ARRAY||classid_data==JS_CLASS_UINT8C_ARRAY){
				size_t offset_data;
				da_data =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_data,(size_t *)&size_data,NULL);
				data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,da_data);
				data +=offset_data;
				size_data -=offset_data;
			}else{
				if(freesrc_data){
					JS_FreeValue(ctx,argv[0]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[1]);
		if(err_dataSize<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)data);
			}else{
				JSClassID classid_data=JS_GetClassID(argv[0]);
				if(classid_data==JS_CLASS_UINT8_ARRAY&&classid_data==JS_CLASS_UINT8C_ARRAY){
					js_free(ctx,(void *)&da_data);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		int returnVal=ComputeCRC32(data,dataSize);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)data);
		}else{
			JSClassID classid_data=JS_GetClassID(argv[0]);
			if(classid_data==JS_CLASS_UINT8_ARRAY&&classid_data==JS_CLASS_UINT8C_ARRAY){
				js_free(ctx,(void *)&da_data);
			}
		}
		return ret;
	}
	
	static JSValue js_ComputeMD5(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		unsigned char * data;
		bool freesrc_data=(bool)false;
		JSValue da_data;
		int64_t size_data;
		JSClassID data_class=JS_GetClassID(argv[0]);
		if(data_class==js_ArrayProxy_class_id){
			void * opaque_data=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_data=((ArrayProxy_class *)opaque_data)[0];
			argv[0] =AP_data.values(ctx,AP_data.opaque,(int)0,(bool)false);
			freesrc_data =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_data)==-1){
				return JS_EXCEPTION;
			}
			data =(unsigned char *)js_malloc(ctx,size_data*sizeof(unsigned char));
			int i;
			for(i=0;i<size_data;i++){
				JSValue js_data=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				uint32_t long_datai;
				int err_datai=JS_ToUint32(ctx,&long_datai,js_data);
				if(err_datai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_data is not numeric");
					return JS_EXCEPTION;
				}
				data[i] =((unsigned char)long_datai);
				JS_FreeValue(ctx,js_data);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[0]);
		}else{
			JSClassID classid_data=JS_GetClassID(argv[0]);
			if(classid_data==JS_CLASS_UINT8_ARRAY||classid_data==JS_CLASS_UINT8C_ARRAY){
				size_t offset_data;
				da_data =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_data,(size_t *)&size_data,NULL);
				data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,da_data);
				data +=offset_data;
				size_data -=offset_data;
			}else{
				if(freesrc_data){
					JS_FreeValue(ctx,argv[0]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[1]);
		if(err_dataSize<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)data);
			}else{
				JSClassID classid_data=JS_GetClassID(argv[0]);
				if(classid_data==JS_CLASS_UINT8_ARRAY&&classid_data==JS_CLASS_UINT8C_ARRAY){
					js_free(ctx,(void *)&da_data);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		int * returnVal=ComputeMD5(data,dataSize);
		JSValue ret;
		ret =JS_NewArray(ctx);
		JSValue js_ret0=JS_NewInt32(ctx,(int32_t)((long)returnVal[0]));
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)0,js_ret0,JS_PROP_C_W_E);
		JSValue js_ret1=JS_NewInt32(ctx,(int32_t)((long)returnVal[1]));
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)1,js_ret1,JS_PROP_C_W_E);
		JSValue js_ret2=JS_NewInt32(ctx,(int32_t)((long)returnVal[2]));
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)2,js_ret2,JS_PROP_C_W_E);
		JSValue js_ret3=JS_NewInt32(ctx,(int32_t)((long)returnVal[3]));
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)3,js_ret3,JS_PROP_C_W_E);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)data);
		}else{
			JSClassID classid_data=JS_GetClassID(argv[0]);
			if(classid_data==JS_CLASS_UINT8_ARRAY&&classid_data==JS_CLASS_UINT8C_ARRAY){
				js_free(ctx,(void *)&da_data);
			}
		}
		return ret;
	}
	
	static JSValue js_ComputeSHA1(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		unsigned char * data;
		bool freesrc_data=(bool)false;
		JSValue da_data;
		int64_t size_data;
		JSClassID data_class=JS_GetClassID(argv[0]);
		if(data_class==js_ArrayProxy_class_id){
			void * opaque_data=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_data=((ArrayProxy_class *)opaque_data)[0];
			argv[0] =AP_data.values(ctx,AP_data.opaque,(int)0,(bool)false);
			freesrc_data =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_data)==-1){
				return JS_EXCEPTION;
			}
			data =(unsigned char *)js_malloc(ctx,size_data*sizeof(unsigned char));
			int i;
			for(i=0;i<size_data;i++){
				JSValue js_data=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				uint32_t long_datai;
				int err_datai=JS_ToUint32(ctx,&long_datai,js_data);
				if(err_datai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_data is not numeric");
					return JS_EXCEPTION;
				}
				data[i] =((unsigned char)long_datai);
				JS_FreeValue(ctx,js_data);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[0]);
		}else{
			JSClassID classid_data=JS_GetClassID(argv[0]);
			if(classid_data==JS_CLASS_UINT8_ARRAY||classid_data==JS_CLASS_UINT8C_ARRAY){
				size_t offset_data;
				da_data =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_data,(size_t *)&size_data,NULL);
				data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,da_data);
				data +=offset_data;
				size_data -=offset_data;
			}else{
				if(freesrc_data){
					JS_FreeValue(ctx,argv[0]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[1]);
		if(err_dataSize<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)data);
			}else{
				JSClassID classid_data=JS_GetClassID(argv[0]);
				if(classid_data==JS_CLASS_UINT8_ARRAY&&classid_data==JS_CLASS_UINT8C_ARRAY){
					js_free(ctx,(void *)&da_data);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		int * returnVal=ComputeSHA1(data,dataSize);
		JSValue ret;
		ret =JS_NewArray(ctx);
		JSValue js_ret0=JS_NewInt32(ctx,(int32_t)((long)returnVal[0]));
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)0,js_ret0,JS_PROP_C_W_E);
		JSValue js_ret1=JS_NewInt32(ctx,(int32_t)((long)returnVal[1]));
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)1,js_ret1,JS_PROP_C_W_E);
		JSValue js_ret2=JS_NewInt32(ctx,(int32_t)((long)returnVal[2]));
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)2,js_ret2,JS_PROP_C_W_E);
		JSValue js_ret3=JS_NewInt32(ctx,(int32_t)((long)returnVal[3]));
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)3,js_ret3,JS_PROP_C_W_E);
		JSValue js_ret4=JS_NewInt32(ctx,(int32_t)((long)returnVal[4]));
		JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)4,js_ret4,JS_PROP_C_W_E);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)data);
		}else{
			JSClassID classid_data=JS_GetClassID(argv[0]);
			if(classid_data==JS_CLASS_UINT8_ARRAY&&classid_data==JS_CLASS_UINT8C_ARRAY){
				js_free(ctx,(void *)&da_data);
			}
		}
		return ret;
	}
	
	static JSValue js_LoadAutomationEventList(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsNull(argv[0])||JS_IsUndefined(argv[0])){
			fileName =NULL;
		}else if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		AutomationEventList returnVal=LoadAutomationEventList((const char *)fileName);
		AutomationEventList * ptr_ret=(AutomationEventList *)js_malloc(ctx,sizeof(AutomationEventList));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_AutomationEventList_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsNull(argv[0])||JS_IsUndefined(argv[0])){
		}
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_UnloadAutomationEventList(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AutomationEventList * ptr_list=(AutomationEventList *)JS_GetOpaque(argv[0],js_AutomationEventList_class_id);
		if(ptr_list==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AutomationEventList list=*ptr_list;
		UnloadAutomationEventList(list);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ExportAutomationEventList(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AutomationEventList * ptr_list=(AutomationEventList *)JS_GetOpaque(argv[0],js_AutomationEventList_class_id);
		if(ptr_list==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AutomationEventList list=*ptr_list;
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[1])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[1]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=ExportAutomationEventList(list,(const char *)fileName);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_SetAutomationEventList(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AutomationEventList * list=(AutomationEventList *)JS_GetOpaque(argv[0],js_AutomationEventList_class_id);
		if(list==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type AutomationEventList");
			return JS_EXCEPTION;
		}
		SetAutomationEventList(list);
		JS_SetOpaque(argv[0],(void *)list);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetAutomationEventBaseFrame(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_frame;
		int err_frame=JS_ToInt32(ctx,&long_frame,argv[0]);
		if(err_frame<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int frame=((int)long_frame);
		SetAutomationEventBaseFrame(frame);
		return JS_UNDEFINED;
	}
	
	static JSValue js_StartAutomationEventRecording(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		StartAutomationEventRecording();
		return JS_UNDEFINED;
	}
	
	static JSValue js_StopAutomationEventRecording(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		StopAutomationEventRecording();
		return JS_UNDEFINED;
	}
	
	static JSValue js_PlayAutomationEvent(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AutomationEvent * ptr_event=(AutomationEvent *)JS_GetOpaque(argv[0],js_AutomationEvent_class_id);
		if(ptr_event==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AutomationEvent event=*ptr_event;
		PlayAutomationEvent(event);
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsKeyPressed(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_key;
		int err_key=JS_ToInt32(ctx,&long_key,argv[0]);
		if(err_key<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int key=((int)long_key);
		bool returnVal=IsKeyPressed(key);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsKeyPressedRepeat(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_key;
		int err_key=JS_ToInt32(ctx,&long_key,argv[0]);
		if(err_key<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int key=((int)long_key);
		bool returnVal=IsKeyPressedRepeat(key);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsKeyDown(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_key;
		int err_key=JS_ToInt32(ctx,&long_key,argv[0]);
		if(err_key<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int key=((int)long_key);
		bool returnVal=IsKeyDown(key);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsKeyReleased(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_key;
		int err_key=JS_ToInt32(ctx,&long_key,argv[0]);
		if(err_key<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int key=((int)long_key);
		bool returnVal=IsKeyReleased(key);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsKeyUp(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_key;
		int err_key=JS_ToInt32(ctx,&long_key,argv[0]);
		if(err_key<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int key=((int)long_key);
		bool returnVal=IsKeyUp(key);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_GetKeyPressed(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetKeyPressed();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetCharPressed(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetCharPressed();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetKeyName(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_key;
		int err_key=JS_ToInt32(ctx,&long_key,argv[0]);
		if(err_key<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int key=((int)long_key);
		char * returnVal=(char *)GetKeyName(key);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		return ret;
	}
	
	static JSValue js_SetExitKey(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_key;
		int err_key=JS_ToInt32(ctx,&long_key,argv[0]);
		if(err_key<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int key=((int)long_key);
		SetExitKey(key);
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsGamepadAvailable(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_gamepad;
		int err_gamepad=JS_ToInt32(ctx,&long_gamepad,argv[0]);
		if(err_gamepad<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int gamepad=((int)long_gamepad);
		bool returnVal=IsGamepadAvailable(gamepad);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_GetGamepadName(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_gamepad;
		int err_gamepad=JS_ToInt32(ctx,&long_gamepad,argv[0]);
		if(err_gamepad<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int gamepad=((int)long_gamepad);
		char * returnVal=(char *)GetGamepadName(gamepad);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		return ret;
	}
	
	static JSValue js_IsGamepadButtonPressed(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_gamepad;
		int err_gamepad=JS_ToInt32(ctx,&long_gamepad,argv[0]);
		if(err_gamepad<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int gamepad=((int)long_gamepad);
		int32_t long_button;
		int err_button=JS_ToInt32(ctx,&long_button,argv[1]);
		if(err_button<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int button=((int)long_button);
		bool returnVal=IsGamepadButtonPressed(gamepad,button);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsGamepadButtonDown(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_gamepad;
		int err_gamepad=JS_ToInt32(ctx,&long_gamepad,argv[0]);
		if(err_gamepad<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int gamepad=((int)long_gamepad);
		int32_t long_button;
		int err_button=JS_ToInt32(ctx,&long_button,argv[1]);
		if(err_button<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int button=((int)long_button);
		bool returnVal=IsGamepadButtonDown(gamepad,button);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsGamepadButtonReleased(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_gamepad;
		int err_gamepad=JS_ToInt32(ctx,&long_gamepad,argv[0]);
		if(err_gamepad<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int gamepad=((int)long_gamepad);
		int32_t long_button;
		int err_button=JS_ToInt32(ctx,&long_button,argv[1]);
		if(err_button<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int button=((int)long_button);
		bool returnVal=IsGamepadButtonReleased(gamepad,button);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsGamepadButtonUp(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_gamepad;
		int err_gamepad=JS_ToInt32(ctx,&long_gamepad,argv[0]);
		if(err_gamepad<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int gamepad=((int)long_gamepad);
		int32_t long_button;
		int err_button=JS_ToInt32(ctx,&long_button,argv[1]);
		if(err_button<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int button=((int)long_button);
		bool returnVal=IsGamepadButtonUp(gamepad,button);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_GetGamepadButtonPressed(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetGamepadButtonPressed();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetGamepadAxisCount(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_gamepad;
		int err_gamepad=JS_ToInt32(ctx,&long_gamepad,argv[0]);
		if(err_gamepad<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int gamepad=((int)long_gamepad);
		int returnVal=GetGamepadAxisCount(gamepad);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetGamepadAxisMovement(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_gamepad;
		int err_gamepad=JS_ToInt32(ctx,&long_gamepad,argv[0]);
		if(err_gamepad<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int gamepad=((int)long_gamepad);
		int32_t long_axis;
		int err_axis=JS_ToInt32(ctx,&long_axis,argv[1]);
		if(err_axis<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int axis=((int)long_axis);
		float returnVal=GetGamepadAxisMovement(gamepad,axis);
		JSValue ret=JS_NewFloat64(ctx,((double)returnVal));
		return ret;
	}
	
	static JSValue js_SetGamepadMappings(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * mappings;
		JSValue da_mappings;
		int64_t size_mappings;
		if(JS_IsString(argv[0])==1){
			mappings =(char *)JS_ToCStringLen(ctx,(size_t *)&size_mappings,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			mappings =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_mappings,argv[0]);
		}else{
			JSClassID classid_mappings=JS_GetClassID(argv[0]);
			if(classid_mappings==JS_CLASS_INT8_ARRAY){
				size_t offset_mappings;
				da_mappings =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_mappings,(size_t *)&size_mappings,NULL);
				mappings =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_mappings,da_mappings);
				mappings +=offset_mappings;
				size_mappings -=offset_mappings;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int returnVal=SetGamepadMappings((const char *)mappings);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)mappings);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)mappings);
		}else{
			JSClassID classid_mappings=JS_GetClassID(argv[0]);
			if(classid_mappings==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_mappings);
			}
		}
		return ret;
	}
	
	static JSValue js_SetGamepadVibration(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_gamepad;
		int err_gamepad=JS_ToInt32(ctx,&long_gamepad,argv[0]);
		if(err_gamepad<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int gamepad=((int)long_gamepad);
		double double_leftMotor;
		int err_leftMotor=JS_ToFloat64(ctx,&double_leftMotor,argv[1]);
		if(err_leftMotor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float leftMotor=((float)double_leftMotor);
		double double_rightMotor;
		int err_rightMotor=JS_ToFloat64(ctx,&double_rightMotor,argv[2]);
		if(err_rightMotor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float rightMotor=((float)double_rightMotor);
		double double_duration;
		int err_duration=JS_ToFloat64(ctx,&double_duration,argv[3]);
		if(err_duration<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float duration=((float)double_duration);
		SetGamepadVibration(gamepad,leftMotor,rightMotor,duration);
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsMouseButtonPressed(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_button;
		int err_button=JS_ToInt32(ctx,&long_button,argv[0]);
		if(err_button<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int button=((int)long_button);
		bool returnVal=IsMouseButtonPressed(button);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsMouseButtonDown(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_button;
		int err_button=JS_ToInt32(ctx,&long_button,argv[0]);
		if(err_button<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int button=((int)long_button);
		bool returnVal=IsMouseButtonDown(button);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsMouseButtonReleased(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_button;
		int err_button=JS_ToInt32(ctx,&long_button,argv[0]);
		if(err_button<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int button=((int)long_button);
		bool returnVal=IsMouseButtonReleased(button);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_IsMouseButtonUp(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_button;
		int err_button=JS_ToInt32(ctx,&long_button,argv[0]);
		if(err_button<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int button=((int)long_button);
		bool returnVal=IsMouseButtonUp(button);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_GetMouseX(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetMouseX();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetMouseY(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetMouseY();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetMousePosition(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 returnVal=GetMousePosition();
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetMouseDelta(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 returnVal=GetMouseDelta();
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_SetMousePosition(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_x;
		int err_x=JS_ToInt32(ctx,&long_x,argv[0]);
		if(err_x<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int x=((int)long_x);
		int32_t long_y;
		int err_y=JS_ToInt32(ctx,&long_y,argv[1]);
		if(err_y<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int y=((int)long_y);
		SetMousePosition(x,y);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetMouseOffset(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_offsetX;
		int err_offsetX=JS_ToInt32(ctx,&long_offsetX,argv[0]);
		if(err_offsetX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int offsetX=((int)long_offsetX);
		int32_t long_offsetY;
		int err_offsetY=JS_ToInt32(ctx,&long_offsetY,argv[1]);
		if(err_offsetY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int offsetY=((int)long_offsetY);
		SetMouseOffset(offsetX,offsetY);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetMouseScale(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double double_scaleX;
		int err_scaleX=JS_ToFloat64(ctx,&double_scaleX,argv[0]);
		if(err_scaleX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float scaleX=((float)double_scaleX);
		double double_scaleY;
		int err_scaleY=JS_ToFloat64(ctx,&double_scaleY,argv[1]);
		if(err_scaleY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float scaleY=((float)double_scaleY);
		SetMouseScale(scaleX,scaleY);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetMouseWheelMove(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		float returnVal=GetMouseWheelMove();
		JSValue ret=JS_NewFloat64(ctx,((double)returnVal));
		return ret;
	}
	
	static JSValue js_GetMouseWheelMoveV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 returnVal=GetMouseWheelMoveV();
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_SetMouseCursor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_cursor;
		int err_cursor=JS_ToInt32(ctx,&long_cursor,argv[0]);
		if(err_cursor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int cursor=((int)long_cursor);
		SetMouseCursor(cursor);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetTouchX(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetTouchX();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetTouchY(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetTouchY();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetTouchPosition(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_index;
		int err_index=JS_ToInt32(ctx,&long_index,argv[0]);
		if(err_index<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int index=((int)long_index);
		Vector2 returnVal=GetTouchPosition(index);
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetTouchPointId(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_index;
		int err_index=JS_ToInt32(ctx,&long_index,argv[0]);
		if(err_index<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int index=((int)long_index);
		int returnVal=GetTouchPointId(index);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetTouchPointCount(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetTouchPointCount();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_SetGesturesEnabled(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		uint32_t long_flags;
		int err_flags=JS_ToUint32(ctx,&long_flags,argv[0]);
		if(err_flags<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int flags=((unsigned int)long_flags);
		SetGesturesEnabled(flags);
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsGestureDetected(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		uint32_t long_gesture;
		int err_gesture=JS_ToUint32(ctx,&long_gesture,argv[0]);
		if(err_gesture<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int gesture=((unsigned int)long_gesture);
		bool returnVal=IsGestureDetected(gesture);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_GetGestureDetected(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int returnVal=GetGestureDetected();
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetGestureHoldDuration(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		float returnVal=GetGestureHoldDuration();
		JSValue ret=JS_NewFloat64(ctx,((double)returnVal));
		return ret;
	}
	
	static JSValue js_GetGestureDragVector(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 returnVal=GetGestureDragVector();
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetGestureDragAngle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		float returnVal=GetGestureDragAngle();
		JSValue ret=JS_NewFloat64(ctx,((double)returnVal));
		return ret;
	}
	
	static JSValue js_GetGesturePinchVector(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 returnVal=GetGesturePinchVector();
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetGesturePinchAngle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		float returnVal=GetGesturePinchAngle();
		JSValue ret=JS_NewFloat64(ctx,((double)returnVal));
		return ret;
	}
	
	static JSValue js_UpdateCamera(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Camera * camera=(Camera *)JS_GetOpaque(argv[0],js_Camera3D_class_id);
		if(camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Camera");
			return JS_EXCEPTION;
		}
		int32_t long_mode;
		int err_mode=JS_ToInt32(ctx,&long_mode,argv[1]);
		if(err_mode<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int mode=((int)long_mode);
		UpdateCamera(camera,mode);
		JS_SetOpaque(argv[0],(void *)camera);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UpdateCameraPro(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Camera * camera=(Camera *)JS_GetOpaque(argv[0],js_Camera3D_class_id);
		if(camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Camera");
			return JS_EXCEPTION;
		}
		Vector3 * ptr_movement=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_movement==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 movement=*ptr_movement;
		Vector3 * ptr_rotation=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_rotation==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 rotation=*ptr_rotation;
		double double_zoom;
		int err_zoom=JS_ToFloat64(ctx,&double_zoom,argv[3]);
		if(err_zoom<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float zoom=((float)double_zoom);
		UpdateCameraPro(camera,movement,rotation,zoom);
		JS_SetOpaque(argv[0],(void *)camera);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetShapesTexture(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		Rectangle * ptr_source=(Rectangle *)JS_GetOpaque(argv[1],js_Rectangle_class_id);
		if(ptr_source==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle source=*ptr_source;
		SetShapesTexture(texture,source);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetShapesTexture(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D returnVal=GetShapesTexture();
		Texture2D * ptr_ret=(Texture2D *)js_malloc(ctx,sizeof(Texture2D));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Texture_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetShapesTextureRectangle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Rectangle returnVal=GetShapesTextureRectangle();
		Rectangle * ptr_ret=(Rectangle *)js_malloc(ctx,sizeof(Rectangle));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Rectangle_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_DrawPixel(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_posX;
		int err_posX=JS_ToInt32(ctx,&long_posX,argv[0]);
		if(err_posX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int posX=((int)long_posX);
		int32_t long_posY;
		int err_posY=JS_ToInt32(ctx,&long_posY,argv[1]);
		if(err_posY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int posY=((int)long_posY);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawPixel(posX,posY,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawPixelV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawPixelV(position,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawLine(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_startPosX;
		int err_startPosX=JS_ToInt32(ctx,&long_startPosX,argv[0]);
		if(err_startPosX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int startPosX=((int)long_startPosX);
		int32_t long_startPosY;
		int err_startPosY=JS_ToInt32(ctx,&long_startPosY,argv[1]);
		if(err_startPosY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int startPosY=((int)long_startPosY);
		int32_t long_endPosX;
		int err_endPosX=JS_ToInt32(ctx,&long_endPosX,argv[2]);
		if(err_endPosX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int endPosX=((int)long_endPosX);
		int32_t long_endPosY;
		int err_endPosY=JS_ToInt32(ctx,&long_endPosY,argv[3]);
		if(err_endPosY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int endPosY=((int)long_endPosY);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawLine(startPosX,startPosY,endPosX,endPosY,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawLineV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_startPos=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_startPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 startPos=*ptr_startPos;
		Vector2 * ptr_endPos=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_endPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 endPos=*ptr_endPos;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawLineV(startPos,endPos,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawLineEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_startPos=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_startPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 startPos=*ptr_startPos;
		Vector2 * ptr_endPos=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_endPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 endPos=*ptr_endPos;
		double double_thick;
		int err_thick=JS_ToFloat64(ctx,&double_thick,argv[2]);
		if(err_thick<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float thick=((float)double_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawLineEx(startPos,endPos,thick,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawLineStrip(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * points;
		bool freesrc_points=(bool)false;
		int64_t size_points;
		JSClassID points_class=JS_GetClassID(argv[0]);
		if(points_class==js_ArrayProxy_class_id){
			void * opaque_points=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_points=((ArrayProxy_class *)opaque_points)[0];
			argv[0] =AP_points.values(ctx,AP_points.opaque,(int)0,(bool)false);
			freesrc_points =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_points)==-1){
				return JS_EXCEPTION;
			}
			points =(Vector2 *)js_malloc(ctx,size_points*sizeof(Vector2));
			int i;
			for(i=0;i<size_points;i++){
				JSValue js_points=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				Vector2 * ptr_pointsi=(Vector2 *)JS_GetOpaque(js_points,js_Vector2_class_id);
				if(ptr_pointsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_points does not allow null");
					return JS_EXCEPTION;
				}
				points[i] =*ptr_pointsi;
				JS_FreeValue(ctx,js_points);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			points =(Vector2 *)JS_GetArrayBuffer(ctx,(size_t *)&size_points,argv[0]);
		}else{
			if(freesrc_points){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Vector2 *");
			return JS_EXCEPTION;
		}
		int32_t long_pointCount;
		int err_pointCount=JS_ToInt32(ctx,&long_pointCount,argv[1]);
		if(err_pointCount<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int pointCount=((int)long_pointCount);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawLineStrip((const Vector2 *)points,pointCount,color);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)points);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawLineBezier(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_startPos=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_startPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 startPos=*ptr_startPos;
		Vector2 * ptr_endPos=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_endPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 endPos=*ptr_endPos;
		double double_thick;
		int err_thick=JS_ToFloat64(ctx,&double_thick,argv[2]);
		if(err_thick<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float thick=((float)double_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawLineBezier(startPos,endPos,thick,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCircle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_centerX;
		int err_centerX=JS_ToInt32(ctx,&long_centerX,argv[0]);
		if(err_centerX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int centerX=((int)long_centerX);
		int32_t long_centerY;
		int err_centerY=JS_ToInt32(ctx,&long_centerY,argv[1]);
		if(err_centerY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int centerY=((int)long_centerY);
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCircle(centerX,centerY,radius,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCircleSector(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[1]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		double double_startAngle;
		int err_startAngle=JS_ToFloat64(ctx,&double_startAngle,argv[2]);
		if(err_startAngle<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float startAngle=((float)double_startAngle);
		double double_endAngle;
		int err_endAngle=JS_ToFloat64(ctx,&double_endAngle,argv[3]);
		if(err_endAngle<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float endAngle=((float)double_endAngle);
		int32_t long_segments;
		int err_segments=JS_ToInt32(ctx,&long_segments,argv[4]);
		if(err_segments<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int segments=((int)long_segments);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCircleSector(center,radius,startAngle,endAngle,segments,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCircleSectorLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[1]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		double double_startAngle;
		int err_startAngle=JS_ToFloat64(ctx,&double_startAngle,argv[2]);
		if(err_startAngle<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float startAngle=((float)double_startAngle);
		double double_endAngle;
		int err_endAngle=JS_ToFloat64(ctx,&double_endAngle,argv[3]);
		if(err_endAngle<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float endAngle=((float)double_endAngle);
		int32_t long_segments;
		int err_segments=JS_ToInt32(ctx,&long_segments,argv[4]);
		if(err_segments<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int segments=((int)long_segments);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCircleSectorLines(center,radius,startAngle,endAngle,segments,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCircleGradient(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_centerX;
		int err_centerX=JS_ToInt32(ctx,&long_centerX,argv[0]);
		if(err_centerX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int centerX=((int)long_centerX);
		int32_t long_centerY;
		int err_centerY=JS_ToInt32(ctx,&long_centerY,argv[1]);
		if(err_centerY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int centerY=((int)long_centerY);
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		Color * ptr_inner=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_inner==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color inner=*ptr_inner;
		Color * ptr_outer=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_outer==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color outer=*ptr_outer;
		DrawCircleGradient(centerX,centerY,radius,inner,outer);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCircleV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[1]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCircleV(center,radius,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCircleLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_centerX;
		int err_centerX=JS_ToInt32(ctx,&long_centerX,argv[0]);
		if(err_centerX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int centerX=((int)long_centerX);
		int32_t long_centerY;
		int err_centerY=JS_ToInt32(ctx,&long_centerY,argv[1]);
		if(err_centerY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int centerY=((int)long_centerY);
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCircleLines(centerX,centerY,radius,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCircleLinesV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[1]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCircleLinesV(center,radius,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawEllipse(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_centerX;
		int err_centerX=JS_ToInt32(ctx,&long_centerX,argv[0]);
		if(err_centerX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int centerX=((int)long_centerX);
		int32_t long_centerY;
		int err_centerY=JS_ToInt32(ctx,&long_centerY,argv[1]);
		if(err_centerY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int centerY=((int)long_centerY);
		double double_radiusH;
		int err_radiusH=JS_ToFloat64(ctx,&double_radiusH,argv[2]);
		if(err_radiusH<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radiusH=((float)double_radiusH);
		double double_radiusV;
		int err_radiusV=JS_ToFloat64(ctx,&double_radiusV,argv[3]);
		if(err_radiusV<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float radiusV=((float)double_radiusV);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawEllipse(centerX,centerY,radiusH,radiusV,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawEllipseV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		double double_radiusH;
		int err_radiusH=JS_ToFloat64(ctx,&double_radiusH,argv[1]);
		if(err_radiusH<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radiusH=((float)double_radiusH);
		double double_radiusV;
		int err_radiusV=JS_ToFloat64(ctx,&double_radiusV,argv[2]);
		if(err_radiusV<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radiusV=((float)double_radiusV);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawEllipseV(center,radiusH,radiusV,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawEllipseLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_centerX;
		int err_centerX=JS_ToInt32(ctx,&long_centerX,argv[0]);
		if(err_centerX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int centerX=((int)long_centerX);
		int32_t long_centerY;
		int err_centerY=JS_ToInt32(ctx,&long_centerY,argv[1]);
		if(err_centerY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int centerY=((int)long_centerY);
		double double_radiusH;
		int err_radiusH=JS_ToFloat64(ctx,&double_radiusH,argv[2]);
		if(err_radiusH<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radiusH=((float)double_radiusH);
		double double_radiusV;
		int err_radiusV=JS_ToFloat64(ctx,&double_radiusV,argv[3]);
		if(err_radiusV<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float radiusV=((float)double_radiusV);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawEllipseLines(centerX,centerY,radiusH,radiusV,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawEllipseLinesV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		double double_radiusH;
		int err_radiusH=JS_ToFloat64(ctx,&double_radiusH,argv[1]);
		if(err_radiusH<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radiusH=((float)double_radiusH);
		double double_radiusV;
		int err_radiusV=JS_ToFloat64(ctx,&double_radiusV,argv[2]);
		if(err_radiusV<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radiusV=((float)double_radiusV);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawEllipseLinesV(center,radiusH,radiusV,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRing(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		double double_innerRadius;
		int err_innerRadius=JS_ToFloat64(ctx,&double_innerRadius,argv[1]);
		if(err_innerRadius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float innerRadius=((float)double_innerRadius);
		double double_outerRadius;
		int err_outerRadius=JS_ToFloat64(ctx,&double_outerRadius,argv[2]);
		if(err_outerRadius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float outerRadius=((float)double_outerRadius);
		double double_startAngle;
		int err_startAngle=JS_ToFloat64(ctx,&double_startAngle,argv[3]);
		if(err_startAngle<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float startAngle=((float)double_startAngle);
		double double_endAngle;
		int err_endAngle=JS_ToFloat64(ctx,&double_endAngle,argv[4]);
		if(err_endAngle<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float endAngle=((float)double_endAngle);
		int32_t long_segments;
		int err_segments=JS_ToInt32(ctx,&long_segments,argv[5]);
		if(err_segments<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] is not numeric");
			return JS_EXCEPTION;
		}
		int segments=((int)long_segments);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[6],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[6] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawRing(center,innerRadius,outerRadius,startAngle,endAngle,segments,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRingLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		double double_innerRadius;
		int err_innerRadius=JS_ToFloat64(ctx,&double_innerRadius,argv[1]);
		if(err_innerRadius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float innerRadius=((float)double_innerRadius);
		double double_outerRadius;
		int err_outerRadius=JS_ToFloat64(ctx,&double_outerRadius,argv[2]);
		if(err_outerRadius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float outerRadius=((float)double_outerRadius);
		double double_startAngle;
		int err_startAngle=JS_ToFloat64(ctx,&double_startAngle,argv[3]);
		if(err_startAngle<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float startAngle=((float)double_startAngle);
		double double_endAngle;
		int err_endAngle=JS_ToFloat64(ctx,&double_endAngle,argv[4]);
		if(err_endAngle<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float endAngle=((float)double_endAngle);
		int32_t long_segments;
		int err_segments=JS_ToInt32(ctx,&long_segments,argv[5]);
		if(err_segments<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] is not numeric");
			return JS_EXCEPTION;
		}
		int segments=((int)long_segments);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[6],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[6] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawRingLines(center,innerRadius,outerRadius,startAngle,endAngle,segments,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRectangle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_posX;
		int err_posX=JS_ToInt32(ctx,&long_posX,argv[0]);
		if(err_posX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int posX=((int)long_posX);
		int32_t long_posY;
		int err_posY=JS_ToInt32(ctx,&long_posY,argv[1]);
		if(err_posY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int posY=((int)long_posY);
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[2]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[3]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawRectangle(posX,posY,width,height,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRectangleV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		Vector2 * ptr_size=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_size==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 size=*ptr_size;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawRectangleV(position,size,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRectangleRec(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[0],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawRectangleRec(rec,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRectanglePro(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[0],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		Vector2 * ptr_origin=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_origin==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 origin=*ptr_origin;
		double double_rotation;
		int err_rotation=JS_ToFloat64(ctx,&double_rotation,argv[2]);
		if(err_rotation<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float rotation=((float)double_rotation);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawRectanglePro(rec,origin,rotation,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRectangleGradientV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_posX;
		int err_posX=JS_ToInt32(ctx,&long_posX,argv[0]);
		if(err_posX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int posX=((int)long_posX);
		int32_t long_posY;
		int err_posY=JS_ToInt32(ctx,&long_posY,argv[1]);
		if(err_posY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int posY=((int)long_posY);
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[2]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[3]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		Color * ptr_top=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_top==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color top=*ptr_top;
		Color * ptr_bottom=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_bottom==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color bottom=*ptr_bottom;
		DrawRectangleGradientV(posX,posY,width,height,top,bottom);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRectangleGradientH(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_posX;
		int err_posX=JS_ToInt32(ctx,&long_posX,argv[0]);
		if(err_posX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int posX=((int)long_posX);
		int32_t long_posY;
		int err_posY=JS_ToInt32(ctx,&long_posY,argv[1]);
		if(err_posY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int posY=((int)long_posY);
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[2]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[3]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		Color * ptr_left=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_left==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color left=*ptr_left;
		Color * ptr_right=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_right==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color right=*ptr_right;
		DrawRectangleGradientH(posX,posY,width,height,left,right);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRectangleGradientEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[0],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		Color * ptr_topLeft=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_topLeft==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color topLeft=*ptr_topLeft;
		Color * ptr_bottomLeft=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_bottomLeft==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color bottomLeft=*ptr_bottomLeft;
		Color * ptr_bottomRight=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_bottomRight==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color bottomRight=*ptr_bottomRight;
		Color * ptr_topRight=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_topRight==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color topRight=*ptr_topRight;
		DrawRectangleGradientEx(rec,topLeft,bottomLeft,bottomRight,topRight);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRectangleLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_posX;
		int err_posX=JS_ToInt32(ctx,&long_posX,argv[0]);
		if(err_posX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int posX=((int)long_posX);
		int32_t long_posY;
		int err_posY=JS_ToInt32(ctx,&long_posY,argv[1]);
		if(err_posY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int posY=((int)long_posY);
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[2]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[3]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawRectangleLines(posX,posY,width,height,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRectangleLinesEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[0],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		double double_lineThick;
		int err_lineThick=JS_ToFloat64(ctx,&double_lineThick,argv[1]);
		if(err_lineThick<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float lineThick=((float)double_lineThick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawRectangleLinesEx(rec,lineThick,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRectangleRounded(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[0],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		double double_roundness;
		int err_roundness=JS_ToFloat64(ctx,&double_roundness,argv[1]);
		if(err_roundness<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float roundness=((float)double_roundness);
		int32_t long_segments;
		int err_segments=JS_ToInt32(ctx,&long_segments,argv[2]);
		if(err_segments<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int segments=((int)long_segments);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawRectangleRounded(rec,roundness,segments,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRectangleRoundedLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[0],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		double double_roundness;
		int err_roundness=JS_ToFloat64(ctx,&double_roundness,argv[1]);
		if(err_roundness<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float roundness=((float)double_roundness);
		int32_t long_segments;
		int err_segments=JS_ToInt32(ctx,&long_segments,argv[2]);
		if(err_segments<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int segments=((int)long_segments);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawRectangleRoundedLines(rec,roundness,segments,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRectangleRoundedLinesEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[0],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		double double_roundness;
		int err_roundness=JS_ToFloat64(ctx,&double_roundness,argv[1]);
		if(err_roundness<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float roundness=((float)double_roundness);
		int32_t long_segments;
		int err_segments=JS_ToInt32(ctx,&long_segments,argv[2]);
		if(err_segments<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int segments=((int)long_segments);
		double double_lineThick;
		int err_lineThick=JS_ToFloat64(ctx,&double_lineThick,argv[3]);
		if(err_lineThick<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float lineThick=((float)double_lineThick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawRectangleRoundedLinesEx(rec,roundness,segments,lineThick,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTriangle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_v1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_v1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v1=*ptr_v1;
		Vector2 * ptr_v2=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_v2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v2=*ptr_v2;
		Vector2 * ptr_v3=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_v3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v3=*ptr_v3;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawTriangle(v1,v2,v3,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTriangleLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_v1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_v1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v1=*ptr_v1;
		Vector2 * ptr_v2=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_v2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v2=*ptr_v2;
		Vector2 * ptr_v3=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_v3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v3=*ptr_v3;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawTriangleLines(v1,v2,v3,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTriangleFan(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * points;
		bool freesrc_points=(bool)false;
		int64_t size_points;
		JSClassID points_class=JS_GetClassID(argv[0]);
		if(points_class==js_ArrayProxy_class_id){
			void * opaque_points=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_points=((ArrayProxy_class *)opaque_points)[0];
			argv[0] =AP_points.values(ctx,AP_points.opaque,(int)0,(bool)false);
			freesrc_points =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_points)==-1){
				return JS_EXCEPTION;
			}
			points =(Vector2 *)js_malloc(ctx,size_points*sizeof(Vector2));
			int i;
			for(i=0;i<size_points;i++){
				JSValue js_points=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				Vector2 * ptr_pointsi=(Vector2 *)JS_GetOpaque(js_points,js_Vector2_class_id);
				if(ptr_pointsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_points does not allow null");
					return JS_EXCEPTION;
				}
				points[i] =*ptr_pointsi;
				JS_FreeValue(ctx,js_points);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			points =(Vector2 *)JS_GetArrayBuffer(ctx,(size_t *)&size_points,argv[0]);
		}else{
			if(freesrc_points){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Vector2 *");
			return JS_EXCEPTION;
		}
		int32_t long_pointCount;
		int err_pointCount=JS_ToInt32(ctx,&long_pointCount,argv[1]);
		if(err_pointCount<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int pointCount=((int)long_pointCount);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawTriangleFan((const Vector2 *)points,pointCount,color);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)points);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTriangleStrip(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * points;
		bool freesrc_points=(bool)false;
		int64_t size_points;
		JSClassID points_class=JS_GetClassID(argv[0]);
		if(points_class==js_ArrayProxy_class_id){
			void * opaque_points=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_points=((ArrayProxy_class *)opaque_points)[0];
			argv[0] =AP_points.values(ctx,AP_points.opaque,(int)0,(bool)false);
			freesrc_points =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_points)==-1){
				return JS_EXCEPTION;
			}
			points =(Vector2 *)js_malloc(ctx,size_points*sizeof(Vector2));
			int i;
			for(i=0;i<size_points;i++){
				JSValue js_points=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				Vector2 * ptr_pointsi=(Vector2 *)JS_GetOpaque(js_points,js_Vector2_class_id);
				if(ptr_pointsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_points does not allow null");
					return JS_EXCEPTION;
				}
				points[i] =*ptr_pointsi;
				JS_FreeValue(ctx,js_points);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			points =(Vector2 *)JS_GetArrayBuffer(ctx,(size_t *)&size_points,argv[0]);
		}else{
			if(freesrc_points){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Vector2 *");
			return JS_EXCEPTION;
		}
		int32_t long_pointCount;
		int err_pointCount=JS_ToInt32(ctx,&long_pointCount,argv[1]);
		if(err_pointCount<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int pointCount=((int)long_pointCount);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawTriangleStrip((const Vector2 *)points,pointCount,color);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)points);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawPoly(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		int32_t long_sides;
		int err_sides=JS_ToInt32(ctx,&long_sides,argv[1]);
		if(err_sides<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int sides=((int)long_sides);
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		double double_rotation;
		int err_rotation=JS_ToFloat64(ctx,&double_rotation,argv[3]);
		if(err_rotation<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float rotation=((float)double_rotation);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawPoly(center,sides,radius,rotation,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawPolyLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		int32_t long_sides;
		int err_sides=JS_ToInt32(ctx,&long_sides,argv[1]);
		if(err_sides<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int sides=((int)long_sides);
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		double double_rotation;
		int err_rotation=JS_ToFloat64(ctx,&double_rotation,argv[3]);
		if(err_rotation<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float rotation=((float)double_rotation);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawPolyLines(center,sides,radius,rotation,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawPolyLinesEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		int32_t long_sides;
		int err_sides=JS_ToInt32(ctx,&long_sides,argv[1]);
		if(err_sides<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int sides=((int)long_sides);
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		double double_rotation;
		int err_rotation=JS_ToFloat64(ctx,&double_rotation,argv[3]);
		if(err_rotation<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float rotation=((float)double_rotation);
		double double_lineThick;
		int err_lineThick=JS_ToFloat64(ctx,&double_lineThick,argv[4]);
		if(err_lineThick<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float lineThick=((float)double_lineThick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawPolyLinesEx(center,sides,radius,rotation,lineThick,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSplineLinear(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * points;
		bool freesrc_points=(bool)false;
		int64_t size_points;
		JSClassID points_class=JS_GetClassID(argv[0]);
		if(points_class==js_ArrayProxy_class_id){
			void * opaque_points=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_points=((ArrayProxy_class *)opaque_points)[0];
			argv[0] =AP_points.values(ctx,AP_points.opaque,(int)0,(bool)false);
			freesrc_points =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_points)==-1){
				return JS_EXCEPTION;
			}
			points =(Vector2 *)js_malloc(ctx,size_points*sizeof(Vector2));
			int i;
			for(i=0;i<size_points;i++){
				JSValue js_points=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				Vector2 * ptr_pointsi=(Vector2 *)JS_GetOpaque(js_points,js_Vector2_class_id);
				if(ptr_pointsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_points does not allow null");
					return JS_EXCEPTION;
				}
				points[i] =*ptr_pointsi;
				JS_FreeValue(ctx,js_points);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			points =(Vector2 *)JS_GetArrayBuffer(ctx,(size_t *)&size_points,argv[0]);
		}else{
			if(freesrc_points){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Vector2 *");
			return JS_EXCEPTION;
		}
		int32_t long_pointCount;
		int err_pointCount=JS_ToInt32(ctx,&long_pointCount,argv[1]);
		if(err_pointCount<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int pointCount=((int)long_pointCount);
		double double_thick;
		int err_thick=JS_ToFloat64(ctx,&double_thick,argv[2]);
		if(err_thick<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float thick=((float)double_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSplineLinear((const Vector2 *)points,pointCount,thick,color);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)points);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSplineBasis(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * points;
		bool freesrc_points=(bool)false;
		int64_t size_points;
		JSClassID points_class=JS_GetClassID(argv[0]);
		if(points_class==js_ArrayProxy_class_id){
			void * opaque_points=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_points=((ArrayProxy_class *)opaque_points)[0];
			argv[0] =AP_points.values(ctx,AP_points.opaque,(int)0,(bool)false);
			freesrc_points =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_points)==-1){
				return JS_EXCEPTION;
			}
			points =(Vector2 *)js_malloc(ctx,size_points*sizeof(Vector2));
			int i;
			for(i=0;i<size_points;i++){
				JSValue js_points=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				Vector2 * ptr_pointsi=(Vector2 *)JS_GetOpaque(js_points,js_Vector2_class_id);
				if(ptr_pointsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_points does not allow null");
					return JS_EXCEPTION;
				}
				points[i] =*ptr_pointsi;
				JS_FreeValue(ctx,js_points);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			points =(Vector2 *)JS_GetArrayBuffer(ctx,(size_t *)&size_points,argv[0]);
		}else{
			if(freesrc_points){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Vector2 *");
			return JS_EXCEPTION;
		}
		int32_t long_pointCount;
		int err_pointCount=JS_ToInt32(ctx,&long_pointCount,argv[1]);
		if(err_pointCount<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int pointCount=((int)long_pointCount);
		double double_thick;
		int err_thick=JS_ToFloat64(ctx,&double_thick,argv[2]);
		if(err_thick<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float thick=((float)double_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSplineBasis((const Vector2 *)points,pointCount,thick,color);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)points);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSplineCatmullRom(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * points;
		bool freesrc_points=(bool)false;
		int64_t size_points;
		JSClassID points_class=JS_GetClassID(argv[0]);
		if(points_class==js_ArrayProxy_class_id){
			void * opaque_points=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_points=((ArrayProxy_class *)opaque_points)[0];
			argv[0] =AP_points.values(ctx,AP_points.opaque,(int)0,(bool)false);
			freesrc_points =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_points)==-1){
				return JS_EXCEPTION;
			}
			points =(Vector2 *)js_malloc(ctx,size_points*sizeof(Vector2));
			int i;
			for(i=0;i<size_points;i++){
				JSValue js_points=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				Vector2 * ptr_pointsi=(Vector2 *)JS_GetOpaque(js_points,js_Vector2_class_id);
				if(ptr_pointsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_points does not allow null");
					return JS_EXCEPTION;
				}
				points[i] =*ptr_pointsi;
				JS_FreeValue(ctx,js_points);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			points =(Vector2 *)JS_GetArrayBuffer(ctx,(size_t *)&size_points,argv[0]);
		}else{
			if(freesrc_points){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Vector2 *");
			return JS_EXCEPTION;
		}
		int32_t long_pointCount;
		int err_pointCount=JS_ToInt32(ctx,&long_pointCount,argv[1]);
		if(err_pointCount<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int pointCount=((int)long_pointCount);
		double double_thick;
		int err_thick=JS_ToFloat64(ctx,&double_thick,argv[2]);
		if(err_thick<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float thick=((float)double_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSplineCatmullRom((const Vector2 *)points,pointCount,thick,color);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)points);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSplineBezierQuadratic(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * points;
		bool freesrc_points=(bool)false;
		int64_t size_points;
		JSClassID points_class=JS_GetClassID(argv[0]);
		if(points_class==js_ArrayProxy_class_id){
			void * opaque_points=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_points=((ArrayProxy_class *)opaque_points)[0];
			argv[0] =AP_points.values(ctx,AP_points.opaque,(int)0,(bool)false);
			freesrc_points =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_points)==-1){
				return JS_EXCEPTION;
			}
			points =(Vector2 *)js_malloc(ctx,size_points*sizeof(Vector2));
			int i;
			for(i=0;i<size_points;i++){
				JSValue js_points=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				Vector2 * ptr_pointsi=(Vector2 *)JS_GetOpaque(js_points,js_Vector2_class_id);
				if(ptr_pointsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_points does not allow null");
					return JS_EXCEPTION;
				}
				points[i] =*ptr_pointsi;
				JS_FreeValue(ctx,js_points);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			points =(Vector2 *)JS_GetArrayBuffer(ctx,(size_t *)&size_points,argv[0]);
		}else{
			if(freesrc_points){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Vector2 *");
			return JS_EXCEPTION;
		}
		int32_t long_pointCount;
		int err_pointCount=JS_ToInt32(ctx,&long_pointCount,argv[1]);
		if(err_pointCount<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int pointCount=((int)long_pointCount);
		double double_thick;
		int err_thick=JS_ToFloat64(ctx,&double_thick,argv[2]);
		if(err_thick<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float thick=((float)double_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSplineBezierQuadratic((const Vector2 *)points,pointCount,thick,color);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)points);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSplineBezierCubic(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * points;
		bool freesrc_points=(bool)false;
		int64_t size_points;
		JSClassID points_class=JS_GetClassID(argv[0]);
		if(points_class==js_ArrayProxy_class_id){
			void * opaque_points=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_points=((ArrayProxy_class *)opaque_points)[0];
			argv[0] =AP_points.values(ctx,AP_points.opaque,(int)0,(bool)false);
			freesrc_points =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_points)==-1){
				return JS_EXCEPTION;
			}
			points =(Vector2 *)js_malloc(ctx,size_points*sizeof(Vector2));
			int i;
			for(i=0;i<size_points;i++){
				JSValue js_points=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				Vector2 * ptr_pointsi=(Vector2 *)JS_GetOpaque(js_points,js_Vector2_class_id);
				if(ptr_pointsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_points does not allow null");
					return JS_EXCEPTION;
				}
				points[i] =*ptr_pointsi;
				JS_FreeValue(ctx,js_points);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			points =(Vector2 *)JS_GetArrayBuffer(ctx,(size_t *)&size_points,argv[0]);
		}else{
			if(freesrc_points){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Vector2 *");
			return JS_EXCEPTION;
		}
		int32_t long_pointCount;
		int err_pointCount=JS_ToInt32(ctx,&long_pointCount,argv[1]);
		if(err_pointCount<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int pointCount=((int)long_pointCount);
		double double_thick;
		int err_thick=JS_ToFloat64(ctx,&double_thick,argv[2]);
		if(err_thick<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float thick=((float)double_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSplineBezierCubic((const Vector2 *)points,pointCount,thick,color);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)points);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSplineSegmentLinear(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_p1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p1=*ptr_p1;
		Vector2 * ptr_p2=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_p2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p2=*ptr_p2;
		double double_thick;
		int err_thick=JS_ToFloat64(ctx,&double_thick,argv[2]);
		if(err_thick<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float thick=((float)double_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSplineSegmentLinear(p1,p2,thick,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSplineSegmentBasis(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_p1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p1=*ptr_p1;
		Vector2 * ptr_p2=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_p2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p2=*ptr_p2;
		Vector2 * ptr_p3=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_p3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p3=*ptr_p3;
		Vector2 * ptr_p4=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_p4==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p4=*ptr_p4;
		double double_thick;
		int err_thick=JS_ToFloat64(ctx,&double_thick,argv[4]);
		if(err_thick<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float thick=((float)double_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSplineSegmentBasis(p1,p2,p3,p4,thick,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSplineSegmentCatmullRom(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_p1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p1=*ptr_p1;
		Vector2 * ptr_p2=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_p2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p2=*ptr_p2;
		Vector2 * ptr_p3=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_p3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p3=*ptr_p3;
		Vector2 * ptr_p4=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_p4==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p4=*ptr_p4;
		double double_thick;
		int err_thick=JS_ToFloat64(ctx,&double_thick,argv[4]);
		if(err_thick<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float thick=((float)double_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSplineSegmentCatmullRom(p1,p2,p3,p4,thick,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSplineSegmentBezierQuadratic(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_p1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p1=*ptr_p1;
		Vector2 * ptr_c2=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_c2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 c2=*ptr_c2;
		Vector2 * ptr_p3=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_p3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p3=*ptr_p3;
		double double_thick;
		int err_thick=JS_ToFloat64(ctx,&double_thick,argv[3]);
		if(err_thick<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float thick=((float)double_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSplineSegmentBezierQuadratic(p1,c2,p3,thick,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSplineSegmentBezierCubic(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_p1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p1=*ptr_p1;
		Vector2 * ptr_c2=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_c2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 c2=*ptr_c2;
		Vector2 * ptr_c3=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_c3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 c3=*ptr_c3;
		Vector2 * ptr_p4=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_p4==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p4=*ptr_p4;
		double double_thick;
		int err_thick=JS_ToFloat64(ctx,&double_thick,argv[4]);
		if(err_thick<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float thick=((float)double_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSplineSegmentBezierCubic(p1,c2,c3,p4,thick,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetSplinePointLinear(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_startPos=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_startPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 startPos=*ptr_startPos;
		Vector2 * ptr_endPos=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_endPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 endPos=*ptr_endPos;
		double double_t;
		int err_t=JS_ToFloat64(ctx,&double_t,argv[2]);
		if(err_t<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float t=((float)double_t);
		Vector2 returnVal=GetSplinePointLinear(startPos,endPos,t);
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetSplinePointBasis(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_p1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p1=*ptr_p1;
		Vector2 * ptr_p2=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_p2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p2=*ptr_p2;
		Vector2 * ptr_p3=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_p3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p3=*ptr_p3;
		Vector2 * ptr_p4=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_p4==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p4=*ptr_p4;
		double double_t;
		int err_t=JS_ToFloat64(ctx,&double_t,argv[4]);
		if(err_t<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float t=((float)double_t);
		Vector2 returnVal=GetSplinePointBasis(p1,p2,p3,p4,t);
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetSplinePointCatmullRom(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_p1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p1=*ptr_p1;
		Vector2 * ptr_p2=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_p2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p2=*ptr_p2;
		Vector2 * ptr_p3=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_p3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p3=*ptr_p3;
		Vector2 * ptr_p4=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_p4==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p4=*ptr_p4;
		double double_t;
		int err_t=JS_ToFloat64(ctx,&double_t,argv[4]);
		if(err_t<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float t=((float)double_t);
		Vector2 returnVal=GetSplinePointCatmullRom(p1,p2,p3,p4,t);
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetSplinePointBezierQuad(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_p1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p1=*ptr_p1;
		Vector2 * ptr_c2=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_c2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 c2=*ptr_c2;
		Vector2 * ptr_p3=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_p3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p3=*ptr_p3;
		double double_t;
		int err_t=JS_ToFloat64(ctx,&double_t,argv[3]);
		if(err_t<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float t=((float)double_t);
		Vector2 returnVal=GetSplinePointBezierQuad(p1,c2,p3,t);
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetSplinePointBezierCubic(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_p1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p1=*ptr_p1;
		Vector2 * ptr_c2=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_c2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 c2=*ptr_c2;
		Vector2 * ptr_c3=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_c3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 c3=*ptr_c3;
		Vector2 * ptr_p4=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_p4==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p4=*ptr_p4;
		double double_t;
		int err_t=JS_ToFloat64(ctx,&double_t,argv[4]);
		if(err_t<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float t=((float)double_t);
		Vector2 returnVal=GetSplinePointBezierCubic(p1,c2,c3,p4,t);
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_CheckCollisionRecs(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Rectangle * ptr_rec1=(Rectangle *)JS_GetOpaque(argv[0],js_Rectangle_class_id);
		if(ptr_rec1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec1=*ptr_rec1;
		Rectangle * ptr_rec2=(Rectangle *)JS_GetOpaque(argv[1],js_Rectangle_class_id);
		if(ptr_rec2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec2=*ptr_rec2;
		bool returnVal=CheckCollisionRecs(rec1,rec2);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_CheckCollisionCircles(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center1=*ptr_center1;
		double double_radius1;
		int err_radius1=JS_ToFloat64(ctx,&double_radius1,argv[1]);
		if(err_radius1<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius1=((float)double_radius1);
		Vector2 * ptr_center2=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_center2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center2=*ptr_center2;
		double double_radius2;
		int err_radius2=JS_ToFloat64(ctx,&double_radius2,argv[3]);
		if(err_radius2<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float radius2=((float)double_radius2);
		bool returnVal=CheckCollisionCircles(center1,radius1,center2,radius2);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_CheckCollisionCircleRec(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[1]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[2],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		bool returnVal=CheckCollisionCircleRec(center,radius,rec);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_CheckCollisionCircleLine(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[1]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		Vector2 * ptr_p1=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p1=*ptr_p1;
		Vector2 * ptr_p2=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_p2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p2=*ptr_p2;
		bool returnVal=CheckCollisionCircleLine(center,radius,p1,p2);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_CheckCollisionPointRec(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_point=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_point==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 point=*ptr_point;
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[1],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		bool returnVal=CheckCollisionPointRec(point,rec);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_CheckCollisionPointCircle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_point=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_point==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 point=*ptr_point;
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		bool returnVal=CheckCollisionPointCircle(point,center,radius);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_CheckCollisionPointTriangle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_point=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_point==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 point=*ptr_point;
		Vector2 * ptr_p1=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p1=*ptr_p1;
		Vector2 * ptr_p2=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_p2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p2=*ptr_p2;
		Vector2 * ptr_p3=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_p3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p3=*ptr_p3;
		bool returnVal=CheckCollisionPointTriangle(point,p1,p2,p3);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_CheckCollisionPointLine(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_point=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_point==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 point=*ptr_point;
		Vector2 * ptr_p1=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p1=*ptr_p1;
		Vector2 * ptr_p2=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_p2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 p2=*ptr_p2;
		int32_t long_threshold;
		int err_threshold=JS_ToInt32(ctx,&long_threshold,argv[3]);
		if(err_threshold<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int threshold=((int)long_threshold);
		bool returnVal=CheckCollisionPointLine(point,p1,p2,threshold);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_CheckCollisionPointPoly(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_point=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_point==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 point=*ptr_point;
		Vector2 * points;
		bool freesrc_points=(bool)false;
		int64_t size_points;
		JSClassID points_class=JS_GetClassID(argv[1]);
		if(points_class==js_ArrayProxy_class_id){
			void * opaque_points=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_points=((ArrayProxy_class *)opaque_points)[0];
			argv[1] =AP_points.values(ctx,AP_points.opaque,(int)0,(bool)false);
			freesrc_points =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_points)==-1){
				return JS_EXCEPTION;
			}
			points =(Vector2 *)js_malloc(ctx,size_points*sizeof(Vector2));
			int i;
			for(i=0;i<size_points;i++){
				JSValue js_points=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				Vector2 * ptr_pointsi=(Vector2 *)JS_GetOpaque(js_points,js_Vector2_class_id);
				if(ptr_pointsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_points does not allow null");
					return JS_EXCEPTION;
				}
				points[i] =*ptr_pointsi;
				JS_FreeValue(ctx,js_points);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			points =(Vector2 *)JS_GetArrayBuffer(ctx,(size_t *)&size_points,argv[1]);
		}else{
			if(freesrc_points){
				JS_FreeValue(ctx,argv[1]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type Vector2 *");
			return JS_EXCEPTION;
		}
		int32_t long_pointCount;
		int err_pointCount=JS_ToInt32(ctx,&long_pointCount,argv[2]);
		if(err_pointCount<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int pointCount=((int)long_pointCount);
		bool returnVal=CheckCollisionPointPoly(point,(const Vector2 *)points,pointCount);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)points);
		}
		return ret;
	}
	
	static JSValue js_CheckCollisionLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_startPos1=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_startPos1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 startPos1=*ptr_startPos1;
		Vector2 * ptr_endPos1=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_endPos1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 endPos1=*ptr_endPos1;
		Vector2 * ptr_startPos2=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_startPos2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 startPos2=*ptr_startPos2;
		Vector2 * ptr_endPos2=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_endPos2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 endPos2=*ptr_endPos2;
		Vector2 * collisionPoint=(Vector2 *)JS_GetOpaque(argv[4],js_Vector2_class_id);
		if(collisionPoint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not match type Vector2");
			return JS_EXCEPTION;
		}
		bool returnVal=CheckCollisionLines(startPos1,endPos1,startPos2,endPos2,collisionPoint);
		JS_SetOpaque(argv[4],(void *)collisionPoint);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_GetCollisionRec(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Rectangle * ptr_rec1=(Rectangle *)JS_GetOpaque(argv[0],js_Rectangle_class_id);
		if(ptr_rec1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec1=*ptr_rec1;
		Rectangle * ptr_rec2=(Rectangle *)JS_GetOpaque(argv[1],js_Rectangle_class_id);
		if(ptr_rec2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec2=*ptr_rec2;
		Rectangle returnVal=GetCollisionRec(rec1,rec2);
		Rectangle * ptr_ret=(Rectangle *)js_malloc(ctx,sizeof(Rectangle));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Rectangle_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_LoadImage(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Image returnVal=LoadImage((const char *)fileName);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_LoadImageRaw(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[1]);
		if(err_width<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)fileName);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)fileName);
			}else{
				JSClassID classid_fileName=JS_GetClassID(argv[0]);
				if(classid_fileName==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_fileName);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[2]);
		if(err_height<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)fileName);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)fileName);
			}else{
				JSClassID classid_fileName=JS_GetClassID(argv[0]);
				if(classid_fileName==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_fileName);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		int32_t long_format;
		int err_format=JS_ToInt32(ctx,&long_format,argv[3]);
		if(err_format<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)fileName);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)fileName);
			}else{
				JSClassID classid_fileName=JS_GetClassID(argv[0]);
				if(classid_fileName==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_fileName);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int format=((int)long_format);
		int32_t long_headerSize;
		int err_headerSize=JS_ToInt32(ctx,&long_headerSize,argv[4]);
		if(err_headerSize<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)fileName);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)fileName);
			}else{
				JSClassID classid_fileName=JS_GetClassID(argv[0]);
				if(classid_fileName==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_fileName);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int headerSize=((int)long_headerSize);
		Image returnVal=LoadImageRaw((const char *)fileName,width,height,format,headerSize);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_LoadImageAnim(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int * frames;
		bool freesrc_frames=(bool)false;
		int64_t size_frames;
		JSClassID frames_class=JS_GetClassID(argv[1]);
		if(frames_class==js_ArrayProxy_class_id){
			void * opaque_frames=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_frames=((ArrayProxy_class *)opaque_frames)[0];
			argv[1] =AP_frames.values(ctx,AP_frames.opaque,(int)0,(bool)false);
			freesrc_frames =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_frames)==-1){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)fileName);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)fileName);
				}else{
					JSClassID classid_fileName=JS_GetClassID(argv[0]);
					if(classid_fileName==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_fileName);
					}
				}
				return JS_EXCEPTION;
			}
			frames =(int *)js_malloc(ctx,size_frames*sizeof(int));
			int i;
			for(i=0;i<size_frames;i++){
				JSValue js_frames=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_framesi;
				int err_framesi=JS_ToInt32(ctx,&long_framesi,js_frames);
				if(err_framesi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_frames is not numeric");
					return JS_EXCEPTION;
				}
				frames[i] =((int)long_framesi);
				JS_FreeValue(ctx,js_frames);
			}
		}else{
			int32_t long_js_frames;
			int err_js_frames=JS_ToInt32(ctx,&long_js_frames,argv[1]);
			if(err_js_frames<0){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)fileName);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)fileName);
				}else{
					JSClassID classid_fileName=JS_GetClassID(argv[0]);
					if(classid_fileName==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_fileName);
					}
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
				return JS_EXCEPTION;
			}
			int js_frames=((int)long_js_frames);
			frames =&js_frames;
		}
		Image returnVal=LoadImageAnim((const char *)fileName,frames);
		if(JS_IsArray(argv[1])==1){
			JSValue js_argv1=JS_NewInt32(ctx,(int32_t)((long)frames[0]));
			JS_DefinePropertyValueUint32(ctx,argv[1],(uint32_t)0,js_argv1,JS_PROP_C_W_E);
		}
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)frames);
		}
		return ret;
	}
	
	static JSValue js_LoadImageAnimFromMemory(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * fileType;
		int64_t size_fileType;
		if(JS_IsString(argv[0])==1){
			fileType =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileType,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fileType);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileType =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileType,argv[0]);
		}else{
			JSClassID classid_fileType=JS_GetClassID(argv[0]);
			if(classid_fileType==JS_CLASS_INT8_ARRAY){
				size_t offset_fileType;
				JSValue da_fileType=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileType,(size_t *)&size_fileType,NULL);
				fileType =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileType,da_fileType);
				fileType +=offset_fileType;
				size_fileType -=offset_fileType;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileType);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		unsigned char * fileData;
		int64_t size_fileData;
		JSClassID fileData_class=JS_GetClassID(argv[1]);
		if(fileData_class==js_ArrayProxy_class_id){
			void * opaque_fileData=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_fileData=((ArrayProxy_class *)opaque_fileData)[0];
			argv[1] =AP_fileData.values(ctx,AP_fileData.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[1]);
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_fileData)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			fileData =(unsigned char *)js_malloc(ctx,size_fileData*sizeof(unsigned char));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)fileData);
			int i;
			for(i=0;i<size_fileData;i++){
				JSValue js_fileData=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				uint32_t long_fileDatai;
				int err_fileDatai=JS_ToUint32(ctx,&long_fileDatai,js_fileData);
				if(err_fileDatai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_fileData is not numeric");
					return JS_EXCEPTION;
				}
				fileData[i] =((unsigned char)long_fileDatai);
				JS_FreeValue(ctx,js_fileData);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileData =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileData,argv[1]);
		}else{
			JSClassID classid_fileData=JS_GetClassID(argv[1]);
			if(classid_fileData==JS_CLASS_UINT8_ARRAY||classid_fileData==JS_CLASS_UINT8C_ARRAY){
				size_t offset_fileData;
				JSValue da_fileData=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileData,(size_t *)&size_fileData,NULL);
				fileData =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileData,da_fileData);
				fileData +=offset_fileData;
				size_fileData -=offset_fileData;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileData);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[2]);
		if(err_dataSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		int * frames;
		int64_t size_frames;
		JSClassID frames_class=JS_GetClassID(argv[3]);
		if(frames_class==js_ArrayProxy_class_id){
			void * opaque_frames=JS_GetOpaque(argv[3],js_ArrayProxy_class_id);
			ArrayProxy_class AP_frames=((ArrayProxy_class *)opaque_frames)[0];
			argv[3] =AP_frames.values(ctx,AP_frames.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[3]);
		}
		if(JS_IsArray(argv[3])==1){
			if(JS_GetLength(ctx,argv[3],&size_frames)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			frames =(int *)js_malloc(ctx,size_frames*sizeof(int));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)frames);
			int i;
			for(i=0;i<size_frames;i++){
				JSValue js_frames=JS_GetPropertyUint32(ctx,argv[3],(uint32_t)i);
				int32_t long_framesi;
				int err_framesi=JS_ToInt32(ctx,&long_framesi,js_frames);
				if(err_framesi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_frames is not numeric");
					return JS_EXCEPTION;
				}
				frames[i] =((int)long_framesi);
				JS_FreeValue(ctx,js_frames);
			}
		}else{
			int32_t long_js_frames;
			int err_js_frames=JS_ToInt32(ctx,&long_js_frames,argv[3]);
			if(err_js_frames<0){
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
				return JS_EXCEPTION;
			}
			int js_frames=((int)long_js_frames);
			frames =&js_frames;
		}
		Image returnVal=LoadImageAnimFromMemory((const char *)fileType,(const unsigned char *)fileData,dataSize,frames);
		if(JS_IsArray(argv[3])==1){
			JSValue js_argv3=JS_NewInt32(ctx,(int32_t)((long)frames[0]));
			JS_DefinePropertyValueUint32(ctx,argv[3],(uint32_t)0,js_argv3,JS_PROP_C_W_E);
		}
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_LoadImageFromMemory(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * fileType;
		int64_t size_fileType;
		if(JS_IsString(argv[0])==1){
			fileType =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileType,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fileType);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileType =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileType,argv[0]);
		}else{
			JSClassID classid_fileType=JS_GetClassID(argv[0]);
			if(classid_fileType==JS_CLASS_INT8_ARRAY){
				size_t offset_fileType;
				JSValue da_fileType=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileType,(size_t *)&size_fileType,NULL);
				fileType =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileType,da_fileType);
				fileType +=offset_fileType;
				size_fileType -=offset_fileType;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileType);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		unsigned char * fileData;
		int64_t size_fileData;
		JSClassID fileData_class=JS_GetClassID(argv[1]);
		if(fileData_class==js_ArrayProxy_class_id){
			void * opaque_fileData=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_fileData=((ArrayProxy_class *)opaque_fileData)[0];
			argv[1] =AP_fileData.values(ctx,AP_fileData.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[1]);
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_fileData)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			fileData =(unsigned char *)js_malloc(ctx,size_fileData*sizeof(unsigned char));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)fileData);
			int i;
			for(i=0;i<size_fileData;i++){
				JSValue js_fileData=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				uint32_t long_fileDatai;
				int err_fileDatai=JS_ToUint32(ctx,&long_fileDatai,js_fileData);
				if(err_fileDatai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_fileData is not numeric");
					return JS_EXCEPTION;
				}
				fileData[i] =((unsigned char)long_fileDatai);
				JS_FreeValue(ctx,js_fileData);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileData =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileData,argv[1]);
		}else{
			JSClassID classid_fileData=JS_GetClassID(argv[1]);
			if(classid_fileData==JS_CLASS_UINT8_ARRAY||classid_fileData==JS_CLASS_UINT8C_ARRAY){
				size_t offset_fileData;
				JSValue da_fileData=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileData,(size_t *)&size_fileData,NULL);
				fileData =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileData,da_fileData);
				fileData +=offset_fileData;
				size_fileData -=offset_fileData;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileData);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[2]);
		if(err_dataSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		Image returnVal=LoadImageFromMemory((const char *)fileType,(const unsigned char *)fileData,dataSize);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_LoadImageFromTexture(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		Image returnVal=LoadImageFromTexture(texture);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_LoadImageFromScreen(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image returnVal=LoadImageFromScreen();
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_IsImageValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		bool returnVal=IsImageValid(image);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_UnloadImage(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		UnloadImage(image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ExportImage(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[1])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[1]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=ExportImage(image,(const char *)fileName);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_ExportImageToMemory(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		char * fileType;
		JSValue da_fileType;
		int64_t size_fileType;
		if(JS_IsString(argv[1])==1){
			fileType =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileType,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileType =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileType,argv[1]);
		}else{
			JSClassID classid_fileType=JS_GetClassID(argv[1]);
			if(classid_fileType==JS_CLASS_INT8_ARRAY){
				size_t offset_fileType;
				da_fileType =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileType,(size_t *)&size_fileType,NULL);
				fileType =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileType,da_fileType);
				fileType +=offset_fileType;
				size_fileType -=offset_fileType;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int * fileSize;
		bool freesrc_fileSize=(bool)false;
		int64_t size_fileSize;
		JSClassID fileSize_class=JS_GetClassID(argv[2]);
		if(fileSize_class==js_ArrayProxy_class_id){
			void * opaque_fileSize=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_fileSize=((ArrayProxy_class *)opaque_fileSize)[0];
			argv[2] =AP_fileSize.values(ctx,AP_fileSize.opaque,(int)0,(bool)false);
			freesrc_fileSize =(bool)true;
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_fileSize)==-1){
				if(JS_IsArray(argv[1])==1){
					js_free(ctx,(void *)fileType);
				}else if(JS_IsString(argv[1])==1){
					JS_FreeCString(ctx,(const char *)fileType);
				}else{
					JSClassID classid_fileType=JS_GetClassID(argv[1]);
					if(classid_fileType==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_fileType);
					}
				}
				return JS_EXCEPTION;
			}
			fileSize =(int *)js_malloc(ctx,size_fileSize*sizeof(int));
			int i;
			for(i=0;i<size_fileSize;i++){
				JSValue js_fileSize=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				int32_t long_fileSizei;
				int err_fileSizei=JS_ToInt32(ctx,&long_fileSizei,js_fileSize);
				if(err_fileSizei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_fileSize is not numeric");
					return JS_EXCEPTION;
				}
				fileSize[i] =((int)long_fileSizei);
				JS_FreeValue(ctx,js_fileSize);
			}
		}else{
			int32_t long_js_fileSize;
			int err_js_fileSize=JS_ToInt32(ctx,&long_js_fileSize,argv[2]);
			if(err_js_fileSize<0){
				if(JS_IsArray(argv[1])==1){
					js_free(ctx,(void *)fileType);
				}else if(JS_IsString(argv[1])==1){
					JS_FreeCString(ctx,(const char *)fileType);
				}else{
					JSClassID classid_fileType=JS_GetClassID(argv[1]);
					if(classid_fileType==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_fileType);
					}
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
				return JS_EXCEPTION;
			}
			int js_fileSize=((int)long_js_fileSize);
			fileSize =&js_fileSize;
		}
		char * returnVal=ExportImageToMemory(image,(const char *)fileType,fileSize);
		if(JS_IsArray(argv[2])==1){
			JSValue js_argv2=JS_NewInt32(ctx,(int32_t)((long)fileSize[0]));
			JS_DefinePropertyValueUint32(ctx,argv[2],(uint32_t)0,js_argv2,JS_PROP_C_W_E);
		}
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)fileType);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)fileType);
		}else{
			JSClassID classid_fileType=JS_GetClassID(argv[1]);
			if(classid_fileType==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileType);
			}
		}
		if(JS_IsArray(argv[2])==1){
			js_free(ctx,(void *)fileSize);
		}
		return ret;
	}
	
	static JSValue js_ExportImageAsCode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[1])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[1]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=ExportImageAsCode(image,(const char *)fileName);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_GenImageColor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		Image returnVal=GenImageColor(width,height,color);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenImageGradientLinear(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		int32_t long_direction;
		int err_direction=JS_ToInt32(ctx,&long_direction,argv[2]);
		if(err_direction<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int direction=((int)long_direction);
		Color * ptr_start=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_start==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color start=*ptr_start;
		Color * ptr_end=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_end==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color end=*ptr_end;
		Image returnVal=GenImageGradientLinear(width,height,direction,start,end);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenImageGradientRadial(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		double double_density;
		int err_density=JS_ToFloat64(ctx,&double_density,argv[2]);
		if(err_density<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float density=((float)double_density);
		Color * ptr_inner=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_inner==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color inner=*ptr_inner;
		Color * ptr_outer=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_outer==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color outer=*ptr_outer;
		Image returnVal=GenImageGradientRadial(width,height,density,inner,outer);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenImageGradientSquare(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		double double_density;
		int err_density=JS_ToFloat64(ctx,&double_density,argv[2]);
		if(err_density<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float density=((float)double_density);
		Color * ptr_inner=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_inner==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color inner=*ptr_inner;
		Color * ptr_outer=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_outer==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color outer=*ptr_outer;
		Image returnVal=GenImageGradientSquare(width,height,density,inner,outer);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenImageChecked(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		int32_t long_checksX;
		int err_checksX=JS_ToInt32(ctx,&long_checksX,argv[2]);
		if(err_checksX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int checksX=((int)long_checksX);
		int32_t long_checksY;
		int err_checksY=JS_ToInt32(ctx,&long_checksY,argv[3]);
		if(err_checksY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int checksY=((int)long_checksY);
		Color * ptr_col1=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_col1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color col1=*ptr_col1;
		Color * ptr_col2=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_col2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color col2=*ptr_col2;
		Image returnVal=GenImageChecked(width,height,checksX,checksY,col1,col2);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenImageWhiteNoise(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		double double_factor;
		int err_factor=JS_ToFloat64(ctx,&double_factor,argv[2]);
		if(err_factor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float factor=((float)double_factor);
		Image returnVal=GenImageWhiteNoise(width,height,factor);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenImagePerlinNoise(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		int32_t long_offsetX;
		int err_offsetX=JS_ToInt32(ctx,&long_offsetX,argv[2]);
		if(err_offsetX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int offsetX=((int)long_offsetX);
		int32_t long_offsetY;
		int err_offsetY=JS_ToInt32(ctx,&long_offsetY,argv[3]);
		if(err_offsetY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int offsetY=((int)long_offsetY);
		double double_scale;
		int err_scale=JS_ToFloat64(ctx,&double_scale,argv[4]);
		if(err_scale<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float scale=((float)double_scale);
		Image returnVal=GenImagePerlinNoise(width,height,offsetX,offsetY,scale);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenImageCellular(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		int32_t long_tileSize;
		int err_tileSize=JS_ToInt32(ctx,&long_tileSize,argv[2]);
		if(err_tileSize<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int tileSize=((int)long_tileSize);
		Image returnVal=GenImageCellular(width,height,tileSize);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenImageText(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[2])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[2]);
		}else if(JS_IsArrayBuffer(argv[2])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[2]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[2]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Image returnVal=GenImageText(width,height,(const char *)text);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[2])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[2])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[2]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_ImageCopy(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		Image returnVal=ImageCopy(image);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ImageFromImage(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[1],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		Image returnVal=ImageFromImage(image,rec);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ImageFromChannel(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		int32_t long_selectedChannel;
		int err_selectedChannel=JS_ToInt32(ctx,&long_selectedChannel,argv[1]);
		if(err_selectedChannel<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int selectedChannel=((int)long_selectedChannel);
		Image returnVal=ImageFromChannel(image,selectedChannel);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ImageText(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_fontSize;
		int err_fontSize=JS_ToInt32(ctx,&long_fontSize,argv[1]);
		if(err_fontSize<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[0]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int fontSize=((int)long_fontSize);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[0]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		Image returnVal=ImageText((const char *)text,fontSize,color);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_ImageTextEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font * ptr_font=(Font *)JS_GetOpaque(argv[0],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[1])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[1]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[1]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		double double_fontSize;
		int err_fontSize=JS_ToFloat64(ctx,&double_fontSize,argv[2]);
		if(err_fontSize<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float fontSize=((float)double_fontSize);
		double double_spacing;
		int err_spacing=JS_ToFloat64(ctx,&double_spacing,argv[3]);
		if(err_spacing<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float spacing=((float)double_spacing);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_tint==NULL){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		Image returnVal=ImageTextEx(font,(const char *)text,fontSize,spacing,tint);
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[1]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_ImageFormat(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_newFormat;
		int err_newFormat=JS_ToInt32(ctx,&long_newFormat,argv[1]);
		if(err_newFormat<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int newFormat=((int)long_newFormat);
		ImageFormat(image,newFormat);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageToPOT(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Color * ptr_fill=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_fill==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color fill=*ptr_fill;
		ImageToPOT(image,fill);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageCrop(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Rectangle * ptr_crop=(Rectangle *)JS_GetOpaque(argv[1],js_Rectangle_class_id);
		if(ptr_crop==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle crop=*ptr_crop;
		ImageCrop(image,crop);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageAlphaCrop(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		double double_threshold;
		int err_threshold=JS_ToFloat64(ctx,&double_threshold,argv[1]);
		if(err_threshold<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float threshold=((float)double_threshold);
		ImageAlphaCrop(image,threshold);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageAlphaClear(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Color * ptr_color=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		double double_threshold;
		int err_threshold=JS_ToFloat64(ctx,&double_threshold,argv[2]);
		if(err_threshold<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float threshold=((float)double_threshold);
		ImageAlphaClear(image,color,threshold);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageAlphaMask(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Image * ptr_alphaMask=(Image *)JS_GetOpaque(argv[1],js_Image_class_id);
		if(ptr_alphaMask==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Image alphaMask=*ptr_alphaMask;
		ImageAlphaMask(image,alphaMask);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageAlphaPremultiply(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		ImageAlphaPremultiply(image);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageBlurGaussian(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_blurSize;
		int err_blurSize=JS_ToInt32(ctx,&long_blurSize,argv[1]);
		if(err_blurSize<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int blurSize=((int)long_blurSize);
		ImageBlurGaussian(image,blurSize);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageKernelConvolution(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		float * kernel;
		bool freesrc_kernel=(bool)false;
		JSValue da_kernel;
		int64_t size_kernel;
		JSClassID kernel_class=JS_GetClassID(argv[1]);
		if(kernel_class==js_ArrayProxy_class_id){
			void * opaque_kernel=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_kernel=((ArrayProxy_class *)opaque_kernel)[0];
			argv[1] =AP_kernel.values(ctx,AP_kernel.opaque,(int)0,(bool)false);
			freesrc_kernel =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_kernel)==-1){
				return JS_EXCEPTION;
			}
			kernel =(float *)js_malloc(ctx,size_kernel*sizeof(float));
			int i;
			for(i=0;i<size_kernel;i++){
				JSValue js_kernel=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				double double_kerneli;
				int err_kerneli=JS_ToFloat64(ctx,&double_kerneli,js_kernel);
				if(err_kerneli<0){
					JS_ThrowTypeError(ctx,(const char *)"js_kernel is not numeric");
					return JS_EXCEPTION;
				}
				kernel[i] =((float)double_kerneli);
				JS_FreeValue(ctx,js_kernel);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			kernel =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_kernel,argv[1]);
		}else{
			JSClassID classid_kernel=JS_GetClassID(argv[1]);
			if(classid_kernel==JS_CLASS_FLOAT32_ARRAY){
				size_t offset_kernel;
				da_kernel =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_kernel,(size_t *)&size_kernel,NULL);
				kernel =(float *)JS_GetArrayBuffer(ctx,(size_t *)&size_kernel,da_kernel);
				kernel +=offset_kernel;
				size_kernel -=offset_kernel;
			}else{
				if(freesrc_kernel){
					JS_FreeValue(ctx,argv[1]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type float *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_kernelSize;
		int err_kernelSize=JS_ToInt32(ctx,&long_kernelSize,argv[2]);
		if(err_kernelSize<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)kernel);
			}else{
				JSClassID classid_kernel=JS_GetClassID(argv[1]);
				if(classid_kernel==JS_CLASS_FLOAT32_ARRAY){
					js_free(ctx,(void *)&da_kernel);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int kernelSize=((int)long_kernelSize);
		ImageKernelConvolution(image,(const float *)kernel,kernelSize);
		JS_SetOpaque(argv[0],(void *)image);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)kernel);
		}else{
			JSClassID classid_kernel=JS_GetClassID(argv[1]);
			if(classid_kernel==JS_CLASS_FLOAT32_ARRAY){
				js_free(ctx,(void *)&da_kernel);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageResize(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_newWidth;
		int err_newWidth=JS_ToInt32(ctx,&long_newWidth,argv[1]);
		if(err_newWidth<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int newWidth=((int)long_newWidth);
		int32_t long_newHeight;
		int err_newHeight=JS_ToInt32(ctx,&long_newHeight,argv[2]);
		if(err_newHeight<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int newHeight=((int)long_newHeight);
		ImageResize(image,newWidth,newHeight);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageResizeNN(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_newWidth;
		int err_newWidth=JS_ToInt32(ctx,&long_newWidth,argv[1]);
		if(err_newWidth<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int newWidth=((int)long_newWidth);
		int32_t long_newHeight;
		int err_newHeight=JS_ToInt32(ctx,&long_newHeight,argv[2]);
		if(err_newHeight<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int newHeight=((int)long_newHeight);
		ImageResizeNN(image,newWidth,newHeight);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageResizeCanvas(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_newWidth;
		int err_newWidth=JS_ToInt32(ctx,&long_newWidth,argv[1]);
		if(err_newWidth<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int newWidth=((int)long_newWidth);
		int32_t long_newHeight;
		int err_newHeight=JS_ToInt32(ctx,&long_newHeight,argv[2]);
		if(err_newHeight<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int newHeight=((int)long_newHeight);
		int32_t long_offsetX;
		int err_offsetX=JS_ToInt32(ctx,&long_offsetX,argv[3]);
		if(err_offsetX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int offsetX=((int)long_offsetX);
		int32_t long_offsetY;
		int err_offsetY=JS_ToInt32(ctx,&long_offsetY,argv[4]);
		if(err_offsetY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int offsetY=((int)long_offsetY);
		Color * ptr_fill=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_fill==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color fill=*ptr_fill;
		ImageResizeCanvas(image,newWidth,newHeight,offsetX,offsetY,fill);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageMipmaps(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		ImageMipmaps(image);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDither(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_rBpp;
		int err_rBpp=JS_ToInt32(ctx,&long_rBpp,argv[1]);
		if(err_rBpp<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int rBpp=((int)long_rBpp);
		int32_t long_gBpp;
		int err_gBpp=JS_ToInt32(ctx,&long_gBpp,argv[2]);
		if(err_gBpp<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int gBpp=((int)long_gBpp);
		int32_t long_bBpp;
		int err_bBpp=JS_ToInt32(ctx,&long_bBpp,argv[3]);
		if(err_bBpp<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int bBpp=((int)long_bBpp);
		int32_t long_aBpp;
		int err_aBpp=JS_ToInt32(ctx,&long_aBpp,argv[4]);
		if(err_aBpp<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int aBpp=((int)long_aBpp);
		ImageDither(image,rBpp,gBpp,bBpp,aBpp);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageFlipVertical(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		ImageFlipVertical(image);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageFlipHorizontal(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		ImageFlipHorizontal(image);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageRotate(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_degrees;
		int err_degrees=JS_ToInt32(ctx,&long_degrees,argv[1]);
		if(err_degrees<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int degrees=((int)long_degrees);
		ImageRotate(image,degrees);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageRotateCW(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		ImageRotateCW(image);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageRotateCCW(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		ImageRotateCCW(image);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageColorTint(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Color * ptr_color=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageColorTint(image,color);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageColorInvert(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		ImageColorInvert(image);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageColorGrayscale(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		ImageColorGrayscale(image);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageColorContrast(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		double double_contrast;
		int err_contrast=JS_ToFloat64(ctx,&double_contrast,argv[1]);
		if(err_contrast<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float contrast=((float)double_contrast);
		ImageColorContrast(image,contrast);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageColorBrightness(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_brightness;
		int err_brightness=JS_ToInt32(ctx,&long_brightness,argv[1]);
		if(err_brightness<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int brightness=((int)long_brightness);
		ImageColorBrightness(image,brightness);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageColorReplace(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Color * ptr_color=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		Color * ptr_replace=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_replace==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color replace=*ptr_replace;
		ImageColorReplace(image,color,replace);
		JS_SetOpaque(argv[0],(void *)image);
		return JS_UNDEFINED;
	}
	
	static JSValue js_LoadImageColors(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		Color * colors=LoadImageColors(image);
		JSValue retVal=JS_NewArrayBufferCopy(ctx,(const uint8_t *)colors,image.width*image.height*sizeof(Color));
		UnloadImageColors(colors);
		return retVal;
	}
	
	static JSValue js_LoadImagePalette(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		int32_t long_maxPaletteSize;
		int err_maxPaletteSize=JS_ToInt32(ctx,&long_maxPaletteSize,argv[1]);
		if(err_maxPaletteSize<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int maxPaletteSize=((int)long_maxPaletteSize);
		int * colorCount;
		bool freesrc_colorCount=(bool)false;
		JSValue da_colorCount;
		int64_t size_colorCount;
		JSClassID colorCount_class=JS_GetClassID(argv[2]);
		if(colorCount_class==js_ArrayProxy_class_id){
			void * opaque_colorCount=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_colorCount=((ArrayProxy_class *)opaque_colorCount)[0];
			argv[2] =AP_colorCount.values(ctx,AP_colorCount.opaque,(int)0,(bool)false);
			freesrc_colorCount =(bool)true;
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_colorCount)==-1){
				return JS_EXCEPTION;
			}
			colorCount =(int *)js_malloc(ctx,size_colorCount*sizeof(int));
			int i;
			for(i=0;i<size_colorCount;i++){
				JSValue js_colorCount=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				int32_t long_colorCounti;
				int err_colorCounti=JS_ToInt32(ctx,&long_colorCounti,js_colorCount);
				if(err_colorCounti<0){
					JS_ThrowTypeError(ctx,(const char *)"js_colorCount is not numeric");
					return JS_EXCEPTION;
				}
				colorCount[i] =((int)long_colorCounti);
				JS_FreeValue(ctx,js_colorCount);
			}
		}else if(JS_IsArrayBuffer(argv[2])==1){
			colorCount =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_colorCount,argv[2]);
		}else{
			JSClassID classid_colorCount=JS_GetClassID(argv[2]);
			if(classid_colorCount==JS_CLASS_INT16_ARRAY){
				size_t offset_colorCount;
				da_colorCount =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_colorCount,(size_t *)&size_colorCount,NULL);
				colorCount =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_colorCount,da_colorCount);
				colorCount +=offset_colorCount;
				size_colorCount -=offset_colorCount;
			}else{
				if(freesrc_colorCount){
					JS_FreeValue(ctx,argv[2]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		Color * returnVal=LoadImagePalette(image,maxPaletteSize,colorCount);
		JSValue ret;
		ret =JS_NewArray(ctx);
		Color * sizeref_ret=returnVal;
		size_t size_ret=sizeof(sizeref_ret);
		size_t size1_ret=sizeof(Color);
		size_ret =size_ret/size1_ret;
		int i;
		for(i=0;i<size_ret;i++){
			Color * ptr_js_ret=(Color *)js_malloc(ctx,sizeof(Color));
			ptr_js_ret[0]=returnVal[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(JS_IsArray(argv[2])==1){
			js_free(ctx,(void *)colorCount);
		}else{
			JSClassID classid_colorCount=JS_GetClassID(argv[2]);
			if(classid_colorCount==JS_CLASS_INT16_ARRAY){
				js_free(ctx,(void *)&da_colorCount);
			}
		}
		return ret;
	}
	
	static JSValue js_UnloadImageColors(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * colors=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(colors==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Color");
			return JS_EXCEPTION;
		}
		UnloadImageColors(colors);
		JS_SetOpaque(argv[0],(void *)colors);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UnloadImagePalette(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * colors=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(colors==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Color");
			return JS_EXCEPTION;
		}
		UnloadImagePalette(colors);
		JS_SetOpaque(argv[0],(void *)colors);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetImageAlphaBorder(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		double double_threshold;
		int err_threshold=JS_ToFloat64(ctx,&double_threshold,argv[1]);
		if(err_threshold<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float threshold=((float)double_threshold);
		Rectangle returnVal=GetImageAlphaBorder(image,threshold);
		Rectangle * ptr_ret=(Rectangle *)js_malloc(ctx,sizeof(Rectangle));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Rectangle_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetImageColor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		int32_t long_x;
		int err_x=JS_ToInt32(ctx,&long_x,argv[1]);
		if(err_x<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int x=((int)long_x);
		int32_t long_y;
		int err_y=JS_ToInt32(ctx,&long_y,argv[2]);
		if(err_y<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int y=((int)long_y);
		Color returnVal=GetImageColor(image,x,y);
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ImageClearBackground(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Color * ptr_color=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageClearBackground(dst,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawPixel(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_posX;
		int err_posX=JS_ToInt32(ctx,&long_posX,argv[1]);
		if(err_posX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int posX=((int)long_posX);
		int32_t long_posY;
		int err_posY=JS_ToInt32(ctx,&long_posY,argv[2]);
		if(err_posY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int posY=((int)long_posY);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawPixel(dst,posX,posY,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawPixelV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawPixelV(dst,position,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawLine(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_startPosX;
		int err_startPosX=JS_ToInt32(ctx,&long_startPosX,argv[1]);
		if(err_startPosX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int startPosX=((int)long_startPosX);
		int32_t long_startPosY;
		int err_startPosY=JS_ToInt32(ctx,&long_startPosY,argv[2]);
		if(err_startPosY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int startPosY=((int)long_startPosY);
		int32_t long_endPosX;
		int err_endPosX=JS_ToInt32(ctx,&long_endPosX,argv[3]);
		if(err_endPosX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int endPosX=((int)long_endPosX);
		int32_t long_endPosY;
		int err_endPosY=JS_ToInt32(ctx,&long_endPosY,argv[4]);
		if(err_endPosY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int endPosY=((int)long_endPosY);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawLine(dst,startPosX,startPosY,endPosX,endPosY,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawLineV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Vector2 * ptr_start=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_start==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 start=*ptr_start;
		Vector2 * ptr_end=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_end==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 end=*ptr_end;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawLineV(dst,start,end,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawLineEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Vector2 * ptr_start=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_start==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 start=*ptr_start;
		Vector2 * ptr_end=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_end==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 end=*ptr_end;
		int32_t long_thick;
		int err_thick=JS_ToInt32(ctx,&long_thick,argv[3]);
		if(err_thick<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int thick=((int)long_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawLineEx(dst,start,end,thick,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawCircle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_centerX;
		int err_centerX=JS_ToInt32(ctx,&long_centerX,argv[1]);
		if(err_centerX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int centerX=((int)long_centerX);
		int32_t long_centerY;
		int err_centerY=JS_ToInt32(ctx,&long_centerY,argv[2]);
		if(err_centerY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int centerY=((int)long_centerY);
		int32_t long_radius;
		int err_radius=JS_ToInt32(ctx,&long_radius,argv[3]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int radius=((int)long_radius);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawCircle(dst,centerX,centerY,radius,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawCircleV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		int32_t long_radius;
		int err_radius=JS_ToInt32(ctx,&long_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int radius=((int)long_radius);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawCircleV(dst,center,radius,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawCircleLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_centerX;
		int err_centerX=JS_ToInt32(ctx,&long_centerX,argv[1]);
		if(err_centerX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int centerX=((int)long_centerX);
		int32_t long_centerY;
		int err_centerY=JS_ToInt32(ctx,&long_centerY,argv[2]);
		if(err_centerY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int centerY=((int)long_centerY);
		int32_t long_radius;
		int err_radius=JS_ToInt32(ctx,&long_radius,argv[3]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int radius=((int)long_radius);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawCircleLines(dst,centerX,centerY,radius,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawCircleLinesV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Vector2 * ptr_center=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 center=*ptr_center;
		int32_t long_radius;
		int err_radius=JS_ToInt32(ctx,&long_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int radius=((int)long_radius);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawCircleLinesV(dst,center,radius,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawRectangle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		int32_t long_posX;
		int err_posX=JS_ToInt32(ctx,&long_posX,argv[1]);
		if(err_posX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int posX=((int)long_posX);
		int32_t long_posY;
		int err_posY=JS_ToInt32(ctx,&long_posY,argv[2]);
		if(err_posY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int posY=((int)long_posY);
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[3]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[4]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawRectangle(dst,posX,posY,width,height,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawRectangleV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		Vector2 * ptr_size=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_size==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 size=*ptr_size;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawRectangleV(dst,position,size,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawRectangleRec(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[1],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawRectangleRec(dst,rec,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawRectangleLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[1],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		int32_t long_thick;
		int err_thick=JS_ToInt32(ctx,&long_thick,argv[2]);
		if(err_thick<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int thick=((int)long_thick);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawRectangleLines(dst,rec,thick,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawTriangle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Vector2 * ptr_v1=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_v1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v1=*ptr_v1;
		Vector2 * ptr_v2=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_v2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v2=*ptr_v2;
		Vector2 * ptr_v3=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_v3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v3=*ptr_v3;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawTriangle(dst,v1,v2,v3,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawTriangleEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Vector2 * ptr_v1=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_v1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v1=*ptr_v1;
		Vector2 * ptr_v2=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_v2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v2=*ptr_v2;
		Vector2 * ptr_v3=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_v3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v3=*ptr_v3;
		Color * ptr_c1=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_c1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color c1=*ptr_c1;
		Color * ptr_c2=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_c2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color c2=*ptr_c2;
		Color * ptr_c3=(Color *)JS_GetOpaque(argv[6],js_Color_class_id);
		if(ptr_c3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[6] does not allow null");
			return JS_EXCEPTION;
		}
		Color c3=*ptr_c3;
		ImageDrawTriangleEx(dst,v1,v2,v3,c1,c2,c3);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawTriangleLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Vector2 * ptr_v1=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_v1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v1=*ptr_v1;
		Vector2 * ptr_v2=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_v2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v2=*ptr_v2;
		Vector2 * ptr_v3=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_v3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 v3=*ptr_v3;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawTriangleLines(dst,v1,v2,v3,color);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawTriangleFan(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Vector2 * points;
		bool freesrc_points=(bool)false;
		int64_t size_points;
		JSClassID points_class=JS_GetClassID(argv[1]);
		if(points_class==js_ArrayProxy_class_id){
			void * opaque_points=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_points=((ArrayProxy_class *)opaque_points)[0];
			argv[1] =AP_points.values(ctx,AP_points.opaque,(int)0,(bool)false);
			freesrc_points =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_points)==-1){
				return JS_EXCEPTION;
			}
			points =(Vector2 *)js_malloc(ctx,size_points*sizeof(Vector2));
			int i;
			for(i=0;i<size_points;i++){
				JSValue js_points=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				Vector2 * ptr_pointsi=(Vector2 *)JS_GetOpaque(js_points,js_Vector2_class_id);
				if(ptr_pointsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_points does not allow null");
					return JS_EXCEPTION;
				}
				points[i] =*ptr_pointsi;
				JS_FreeValue(ctx,js_points);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			points =(Vector2 *)JS_GetArrayBuffer(ctx,(size_t *)&size_points,argv[1]);
		}else{
			if(freesrc_points){
				JS_FreeValue(ctx,argv[1]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type Vector2 *");
			return JS_EXCEPTION;
		}
		int32_t long_pointCount;
		int err_pointCount=JS_ToInt32(ctx,&long_pointCount,argv[2]);
		if(err_pointCount<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int pointCount=((int)long_pointCount);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawTriangleFan(dst,(const Vector2 *)points,pointCount,color);
		JS_SetOpaque(argv[0],(void *)dst);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)points);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawTriangleStrip(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Vector2 * points;
		bool freesrc_points=(bool)false;
		int64_t size_points;
		JSClassID points_class=JS_GetClassID(argv[1]);
		if(points_class==js_ArrayProxy_class_id){
			void * opaque_points=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_points=((ArrayProxy_class *)opaque_points)[0];
			argv[1] =AP_points.values(ctx,AP_points.opaque,(int)0,(bool)false);
			freesrc_points =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_points)==-1){
				return JS_EXCEPTION;
			}
			points =(Vector2 *)js_malloc(ctx,size_points*sizeof(Vector2));
			int i;
			for(i=0;i<size_points;i++){
				JSValue js_points=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				Vector2 * ptr_pointsi=(Vector2 *)JS_GetOpaque(js_points,js_Vector2_class_id);
				if(ptr_pointsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_points does not allow null");
					return JS_EXCEPTION;
				}
				points[i] =*ptr_pointsi;
				JS_FreeValue(ctx,js_points);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			points =(Vector2 *)JS_GetArrayBuffer(ctx,(size_t *)&size_points,argv[1]);
		}else{
			if(freesrc_points){
				JS_FreeValue(ctx,argv[1]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type Vector2 *");
			return JS_EXCEPTION;
		}
		int32_t long_pointCount;
		int err_pointCount=JS_ToInt32(ctx,&long_pointCount,argv[2]);
		if(err_pointCount<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int pointCount=((int)long_pointCount);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawTriangleStrip(dst,(const Vector2 *)points,pointCount,color);
		JS_SetOpaque(argv[0],(void *)dst);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)points);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDraw(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Image * ptr_src=(Image *)JS_GetOpaque(argv[1],js_Image_class_id);
		if(ptr_src==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Image src=*ptr_src;
		Rectangle * ptr_srcRec=(Rectangle *)JS_GetOpaque(argv[2],js_Rectangle_class_id);
		if(ptr_srcRec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle srcRec=*ptr_srcRec;
		Rectangle * ptr_dstRec=(Rectangle *)JS_GetOpaque(argv[3],js_Rectangle_class_id);
		if(ptr_dstRec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle dstRec=*ptr_dstRec;
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		ImageDraw(dst,src,srcRec,dstRec,tint);
		JS_SetOpaque(argv[0],(void *)dst);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawText(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[1])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[1]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[1]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_posX;
		int err_posX=JS_ToInt32(ctx,&long_posX,argv[2]);
		if(err_posX<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int posX=((int)long_posX);
		int32_t long_posY;
		int err_posY=JS_ToInt32(ctx,&long_posY,argv[3]);
		if(err_posY<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int posY=((int)long_posY);
		int32_t long_fontSize;
		int err_fontSize=JS_ToInt32(ctx,&long_fontSize,argv[4]);
		if(err_fontSize<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int fontSize=((int)long_fontSize);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		ImageDrawText(dst,(const char *)text,posX,posY,fontSize,color);
		JS_SetOpaque(argv[0],(void *)dst);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[1]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_ImageDrawTextEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * dst=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Image");
			return JS_EXCEPTION;
		}
		Font * ptr_font=(Font *)JS_GetOpaque(argv[1],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[2])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[2]);
		}else if(JS_IsArrayBuffer(argv[2])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[2]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[2]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[2],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_position==NULL){
			if(JS_IsArray(argv[2])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[2])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[2]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		double double_fontSize;
		int err_fontSize=JS_ToFloat64(ctx,&double_fontSize,argv[4]);
		if(err_fontSize<0){
			if(JS_IsArray(argv[2])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[2])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[2]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float fontSize=((float)double_fontSize);
		double double_spacing;
		int err_spacing=JS_ToFloat64(ctx,&double_spacing,argv[5]);
		if(err_spacing<0){
			if(JS_IsArray(argv[2])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[2])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[2]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[5] is not numeric");
			return JS_EXCEPTION;
		}
		float spacing=((float)double_spacing);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[6],js_Color_class_id);
		if(ptr_tint==NULL){
			if(JS_IsArray(argv[2])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[2])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[2]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[6] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		ImageDrawTextEx(dst,font,(const char *)text,position,fontSize,spacing,tint);
		JS_SetOpaque(argv[0],(void *)dst);
		if(JS_IsArray(argv[2])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[2])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[2]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_LoadTexture(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Texture2D returnVal=LoadTexture((const char *)fileName);
		Texture2D * ptr_ret=(Texture2D *)js_malloc(ctx,sizeof(Texture2D));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Texture_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_LoadTextureFromImage(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		Texture2D returnVal=LoadTextureFromImage(image);
		Texture2D * ptr_ret=(Texture2D *)js_malloc(ctx,sizeof(Texture2D));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Texture_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_LoadTextureCubemap(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		int32_t long_layout;
		int err_layout=JS_ToInt32(ctx,&long_layout,argv[1]);
		if(err_layout<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int layout=((int)long_layout);
		TextureCubemap returnVal=LoadTextureCubemap(image,layout);
		TextureCubemap * ptr_ret=(TextureCubemap *)js_malloc(ctx,sizeof(TextureCubemap));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Texture_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_LoadRenderTexture(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		RenderTexture2D returnVal=LoadRenderTexture(width,height);
		RenderTexture2D * ptr_ret=(RenderTexture2D *)js_malloc(ctx,sizeof(RenderTexture2D));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_RenderTexture_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_IsTextureValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		bool returnVal=IsTextureValid(texture);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_UnloadTexture(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		UnloadTexture(texture);
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsRenderTextureValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		RenderTexture2D * ptr_target=(RenderTexture2D *)JS_GetOpaque(argv[0],js_RenderTexture_class_id);
		if(ptr_target==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		RenderTexture2D target=*ptr_target;
		bool returnVal=IsRenderTextureValid(target);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_UnloadRenderTexture(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		RenderTexture2D * ptr_target=(RenderTexture2D *)JS_GetOpaque(argv[0],js_RenderTexture_class_id);
		if(ptr_target==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		RenderTexture2D target=*ptr_target;
		UnloadRenderTexture(target);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UpdateTexture(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		void * pixels;
		int64_t size_pixels;
		if(JS_IsArrayBuffer(argv[1])==1){
			pixels =(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_pixels,argv[1]);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type void *");
			return JS_EXCEPTION;
		}
		UpdateTexture(texture,(const void *)pixels);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UpdateTextureRec(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		Rectangle * ptr_rec=(Rectangle *)JS_GetOpaque(argv[1],js_Rectangle_class_id);
		if(ptr_rec==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle rec=*ptr_rec;
		void * pixels;
		int64_t size_pixels;
		if(JS_IsArrayBuffer(argv[2])==1){
			pixels =(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_pixels,argv[2]);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type void *");
			return JS_EXCEPTION;
		}
		UpdateTextureRec(texture,rec,(const void *)pixels);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GenTextureMipmaps(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Texture2D");
			return JS_EXCEPTION;
		}
		GenTextureMipmaps(texture);
		JS_SetOpaque(argv[0],(void *)texture);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetTextureFilter(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		int32_t long_filter;
		int err_filter=JS_ToInt32(ctx,&long_filter,argv[1]);
		if(err_filter<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int filter=((int)long_filter);
		SetTextureFilter(texture,filter);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetTextureWrap(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		int32_t long_wrap;
		int err_wrap=JS_ToInt32(ctx,&long_wrap,argv[1]);
		if(err_wrap<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int wrap=((int)long_wrap);
		SetTextureWrap(texture,wrap);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTexture(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		int32_t long_posX;
		int err_posX=JS_ToInt32(ctx,&long_posX,argv[1]);
		if(err_posX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int posX=((int)long_posX);
		int32_t long_posY;
		int err_posY=JS_ToInt32(ctx,&long_posY,argv[2]);
		if(err_posY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int posY=((int)long_posY);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawTexture(texture,posX,posY,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTextureV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawTextureV(texture,position,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTextureEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		double double_rotation;
		int err_rotation=JS_ToFloat64(ctx,&double_rotation,argv[2]);
		if(err_rotation<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float rotation=((float)double_rotation);
		double double_scale;
		int err_scale=JS_ToFloat64(ctx,&double_scale,argv[3]);
		if(err_scale<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float scale=((float)double_scale);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawTextureEx(texture,position,rotation,scale,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTextureRec(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		Rectangle * ptr_source=(Rectangle *)JS_GetOpaque(argv[1],js_Rectangle_class_id);
		if(ptr_source==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle source=*ptr_source;
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawTextureRec(texture,source,position,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTexturePro(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		Rectangle * ptr_source=(Rectangle *)JS_GetOpaque(argv[1],js_Rectangle_class_id);
		if(ptr_source==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle source=*ptr_source;
		Rectangle * ptr_dest=(Rectangle *)JS_GetOpaque(argv[2],js_Rectangle_class_id);
		if(ptr_dest==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle dest=*ptr_dest;
		Vector2 * ptr_origin=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_origin==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 origin=*ptr_origin;
		double double_rotation;
		int err_rotation=JS_ToFloat64(ctx,&double_rotation,argv[4]);
		if(err_rotation<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float rotation=((float)double_rotation);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawTexturePro(texture,source,dest,origin,rotation,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTextureNPatch(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[0],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		NPatchInfo * ptr_nPatchInfo=(NPatchInfo *)JS_GetOpaque(argv[1],js_NPatchInfo_class_id);
		if(ptr_nPatchInfo==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		NPatchInfo nPatchInfo=*ptr_nPatchInfo;
		Rectangle * ptr_dest=(Rectangle *)JS_GetOpaque(argv[2],js_Rectangle_class_id);
		if(ptr_dest==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle dest=*ptr_dest;
		Vector2 * ptr_origin=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_origin==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 origin=*ptr_origin;
		double double_rotation;
		int err_rotation=JS_ToFloat64(ctx,&double_rotation,argv[4]);
		if(err_rotation<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float rotation=((float)double_rotation);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawTextureNPatch(texture,nPatchInfo,dest,origin,rotation,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ColorIsEqual(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * ptr_col1=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(ptr_col1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Color col1=*ptr_col1;
		Color * ptr_col2=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_col2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color col2=*ptr_col2;
		bool returnVal=ColorIsEqual(col1,col2);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_Fade(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * ptr_color=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		double double_alpha;
		int err_alpha=JS_ToFloat64(ctx,&double_alpha,argv[1]);
		if(err_alpha<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float alpha=((float)double_alpha);
		Color returnVal=Fade(color,alpha);
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ColorToInt(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * ptr_color=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		int returnVal=ColorToInt(color);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_ColorNormalize(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * ptr_color=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		Vector4 returnVal=ColorNormalize(color);
		Vector4 * ptr_ret=(Vector4 *)js_malloc(ctx,sizeof(Vector4));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector4_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ColorFromNormalized(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector4 * ptr_normalized=(Vector4 *)JS_GetOpaque(argv[0],js_Vector4_class_id);
		if(ptr_normalized==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector4 normalized=*ptr_normalized;
		Color returnVal=ColorFromNormalized(normalized);
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ColorToHSV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * ptr_color=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		Vector3 returnVal=ColorToHSV(color);
		Vector3 * ptr_ret=(Vector3 *)js_malloc(ctx,sizeof(Vector3));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector3_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ColorFromHSV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double double_hue;
		int err_hue=JS_ToFloat64(ctx,&double_hue,argv[0]);
		if(err_hue<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float hue=((float)double_hue);
		double double_saturation;
		int err_saturation=JS_ToFloat64(ctx,&double_saturation,argv[1]);
		if(err_saturation<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float saturation=((float)double_saturation);
		double double_value;
		int err_value=JS_ToFloat64(ctx,&double_value,argv[2]);
		if(err_value<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float value=((float)double_value);
		Color returnVal=ColorFromHSV(hue,saturation,value);
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ColorTint(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * ptr_color=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		Color returnVal=ColorTint(color,tint);
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ColorBrightness(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * ptr_color=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		double double_factor;
		int err_factor=JS_ToFloat64(ctx,&double_factor,argv[1]);
		if(err_factor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float factor=((float)double_factor);
		Color returnVal=ColorBrightness(color,factor);
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ColorContrast(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * ptr_color=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		double double_contrast;
		int err_contrast=JS_ToFloat64(ctx,&double_contrast,argv[1]);
		if(err_contrast<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float contrast=((float)double_contrast);
		Color returnVal=ColorContrast(color,contrast);
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ColorAlpha(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * ptr_color=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		double double_alpha;
		int err_alpha=JS_ToFloat64(ctx,&double_alpha,argv[1]);
		if(err_alpha<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float alpha=((float)double_alpha);
		Color returnVal=ColorAlpha(color,alpha);
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ColorAlphaBlend(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * ptr_dst=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(ptr_dst==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Color dst=*ptr_dst;
		Color * ptr_src=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_src==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color src=*ptr_src;
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		Color returnVal=ColorAlphaBlend(dst,src,tint);
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_ColorLerp(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Color * ptr_color1=(Color *)JS_GetOpaque(argv[0],js_Color_class_id);
		if(ptr_color1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Color color1=*ptr_color1;
		Color * ptr_color2=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_color2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color color2=*ptr_color2;
		double double_factor;
		int err_factor=JS_ToFloat64(ctx,&double_factor,argv[2]);
		if(err_factor<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float factor=((float)double_factor);
		Color returnVal=ColorLerp(color1,color2,factor);
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetColor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		uint32_t long_hexValue;
		int err_hexValue=JS_ToUint32(ctx,&long_hexValue,argv[0]);
		if(err_hexValue<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int hexValue=((unsigned int)long_hexValue);
		Color returnVal=GetColor(hexValue);
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetPixelColor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		void * srcPtr;
		int64_t size_srcPtr;
		if(JS_IsArrayBuffer(argv[0])==1){
			srcPtr =(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_srcPtr,argv[0]);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type void *");
			return JS_EXCEPTION;
		}
		int32_t long_format;
		int err_format=JS_ToInt32(ctx,&long_format,argv[1]);
		if(err_format<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int format=((int)long_format);
		Color returnVal=GetPixelColor(srcPtr,format);
		Color * ptr_ret=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_SetPixelColor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		void * dstPtr;
		int64_t size_dstPtr;
		if(JS_IsArrayBuffer(argv[0])==1){
			dstPtr =(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_dstPtr,argv[0]);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type void *");
			return JS_EXCEPTION;
		}
		Color * ptr_color=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		int32_t long_format;
		int err_format=JS_ToInt32(ctx,&long_format,argv[2]);
		if(err_format<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int format=((int)long_format);
		SetPixelColor(dstPtr,color,format);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetPixelDataSize(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_width;
		int err_width=JS_ToInt32(ctx,&long_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int width=((int)long_width);
		int32_t long_height;
		int err_height=JS_ToInt32(ctx,&long_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int height=((int)long_height);
		int32_t long_format;
		int err_format=JS_ToInt32(ctx,&long_format,argv[2]);
		if(err_format<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int format=((int)long_format);
		int returnVal=GetPixelDataSize(width,height,format);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetFontDefault(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font returnVal=GetFontDefault();
		Font * ptr_ret=(Font *)js_malloc(ctx,sizeof(Font));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Font_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_LoadFont(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Font returnVal=LoadFont((const char *)fileName);
		Font * ptr_ret=(Font *)js_malloc(ctx,sizeof(Font));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Font_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_LoadFontEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fileName);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				JSValue da_fileName=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileName);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_fontSize;
		int err_fontSize=JS_ToInt32(ctx,&long_fontSize,argv[1]);
		if(err_fontSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int fontSize=((int)long_fontSize);
		int * codepoints;
		int64_t size_codepoints;
		JSClassID codepoints_class=JS_GetClassID(argv[2]);
		if(codepoints_class==js_ArrayProxy_class_id){
			void * opaque_codepoints=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_codepoints=((ArrayProxy_class *)opaque_codepoints)[0];
			argv[2] =AP_codepoints.values(ctx,AP_codepoints.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[2]);
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_codepoints)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			codepoints =(int *)js_malloc(ctx,size_codepoints*sizeof(int));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)codepoints);
			int i;
			for(i=0;i<size_codepoints;i++){
				JSValue js_codepoints=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				int32_t long_codepointsi;
				int err_codepointsi=JS_ToInt32(ctx,&long_codepointsi,js_codepoints);
				if(err_codepointsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_codepoints is not numeric");
					return JS_EXCEPTION;
				}
				codepoints[i] =((int)long_codepointsi);
				JS_FreeValue(ctx,js_codepoints);
			}
		}else if(JS_IsNull(argv[2])||JS_IsUndefined(argv[2])){
			codepoints =NULL;
		}else if(JS_IsArrayBuffer(argv[2])==1){
			codepoints =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_codepoints,argv[2]);
		}else{
			JSClassID classid_codepoints=JS_GetClassID(argv[2]);
			if(classid_codepoints==JS_CLASS_INT16_ARRAY){
				size_t offset_codepoints;
				JSValue da_codepoints=JS_GetTypedArrayBuffer(ctx,argv[2],&offset_codepoints,(size_t *)&size_codepoints,NULL);
				codepoints =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_codepoints,da_codepoints);
				codepoints +=offset_codepoints;
				size_codepoints -=offset_codepoints;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_codepoints);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_codepointCount;
		int err_codepointCount=JS_ToInt32(ctx,&long_codepointCount,argv[3]);
		if(err_codepointCount<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int codepointCount=((int)long_codepointCount);
		Font returnVal=LoadFontEx((const char *)fileName,fontSize,codepoints,codepointCount);
		Font * ptr_ret=(Font *)js_malloc(ctx,sizeof(Font));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Font_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_LoadFontFromImage(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_image=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_image==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image image=*ptr_image;
		Color * ptr_key=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_key==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color key=*ptr_key;
		int32_t long_firstChar;
		int err_firstChar=JS_ToInt32(ctx,&long_firstChar,argv[2]);
		if(err_firstChar<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int firstChar=((int)long_firstChar);
		Font returnVal=LoadFontFromImage(image,key,firstChar);
		Font * ptr_ret=(Font *)js_malloc(ctx,sizeof(Font));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Font_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_LoadFontFromMemory(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * fileType;
		int64_t size_fileType;
		if(JS_IsString(argv[0])==1){
			fileType =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileType,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fileType);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileType =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileType,argv[0]);
		}else{
			JSClassID classid_fileType=JS_GetClassID(argv[0]);
			if(classid_fileType==JS_CLASS_INT8_ARRAY){
				size_t offset_fileType;
				JSValue da_fileType=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileType,(size_t *)&size_fileType,NULL);
				fileType =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileType,da_fileType);
				fileType +=offset_fileType;
				size_fileType -=offset_fileType;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileType);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		unsigned char * fileData;
		int64_t size_fileData;
		JSClassID fileData_class=JS_GetClassID(argv[1]);
		if(fileData_class==js_ArrayProxy_class_id){
			void * opaque_fileData=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_fileData=((ArrayProxy_class *)opaque_fileData)[0];
			argv[1] =AP_fileData.values(ctx,AP_fileData.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[1]);
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_fileData)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			fileData =(unsigned char *)js_malloc(ctx,size_fileData*sizeof(unsigned char));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)fileData);
			int i;
			for(i=0;i<size_fileData;i++){
				JSValue js_fileData=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				uint32_t long_fileDatai;
				int err_fileDatai=JS_ToUint32(ctx,&long_fileDatai,js_fileData);
				if(err_fileDatai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_fileData is not numeric");
					return JS_EXCEPTION;
				}
				fileData[i] =((unsigned char)long_fileDatai);
				JS_FreeValue(ctx,js_fileData);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileData =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileData,argv[1]);
		}else{
			JSClassID classid_fileData=JS_GetClassID(argv[1]);
			if(classid_fileData==JS_CLASS_UINT8_ARRAY||classid_fileData==JS_CLASS_UINT8C_ARRAY){
				size_t offset_fileData;
				JSValue da_fileData=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileData,(size_t *)&size_fileData,NULL);
				fileData =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileData,da_fileData);
				fileData +=offset_fileData;
				size_fileData -=offset_fileData;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileData);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[2]);
		if(err_dataSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		int32_t long_fontSize;
		int err_fontSize=JS_ToInt32(ctx,&long_fontSize,argv[3]);
		if(err_fontSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int fontSize=((int)long_fontSize);
		int * codepoints;
		int64_t size_codepoints;
		JSClassID codepoints_class=JS_GetClassID(argv[4]);
		if(codepoints_class==js_ArrayProxy_class_id){
			void * opaque_codepoints=JS_GetOpaque(argv[4],js_ArrayProxy_class_id);
			ArrayProxy_class AP_codepoints=((ArrayProxy_class *)opaque_codepoints)[0];
			argv[4] =AP_codepoints.values(ctx,AP_codepoints.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[4]);
		}
		if(JS_IsArray(argv[4])==1){
			if(JS_GetLength(ctx,argv[4],&size_codepoints)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			codepoints =(int *)js_malloc(ctx,size_codepoints*sizeof(int));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)codepoints);
			int i;
			for(i=0;i<size_codepoints;i++){
				JSValue js_codepoints=JS_GetPropertyUint32(ctx,argv[4],(uint32_t)i);
				int32_t long_codepointsi;
				int err_codepointsi=JS_ToInt32(ctx,&long_codepointsi,js_codepoints);
				if(err_codepointsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_codepoints is not numeric");
					return JS_EXCEPTION;
				}
				codepoints[i] =((int)long_codepointsi);
				JS_FreeValue(ctx,js_codepoints);
			}
		}else if(JS_IsArrayBuffer(argv[4])==1){
			codepoints =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_codepoints,argv[4]);
		}else{
			JSClassID classid_codepoints=JS_GetClassID(argv[4]);
			if(classid_codepoints==JS_CLASS_INT16_ARRAY){
				size_t offset_codepoints;
				JSValue da_codepoints=JS_GetTypedArrayBuffer(ctx,argv[4],&offset_codepoints,(size_t *)&size_codepoints,NULL);
				codepoints =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_codepoints,da_codepoints);
				codepoints +=offset_codepoints;
				size_codepoints -=offset_codepoints;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_codepoints);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[4] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_codepointCount;
		int err_codepointCount=JS_ToInt32(ctx,&long_codepointCount,argv[5]);
		if(err_codepointCount<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[5] is not numeric");
			return JS_EXCEPTION;
		}
		int codepointCount=((int)long_codepointCount);
		Font returnVal=LoadFontFromMemory((const char *)fileType,(const unsigned char *)fileData,dataSize,fontSize,codepoints,codepointCount);
		Font * ptr_ret=(Font *)js_malloc(ctx,sizeof(Font));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Font_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_IsFontValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font * ptr_font=(Font *)JS_GetOpaque(argv[0],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		bool returnVal=IsFontValid(font);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_LoadFontData(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		unsigned char * fileData;
		int64_t size_fileData;
		JSClassID fileData_class=JS_GetClassID(argv[0]);
		if(fileData_class==js_ArrayProxy_class_id){
			void * opaque_fileData=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_fileData=((ArrayProxy_class *)opaque_fileData)[0];
			argv[0] =AP_fileData.values(ctx,AP_fileData.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[0]);
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_fileData)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			fileData =(unsigned char *)js_malloc(ctx,size_fileData*sizeof(unsigned char));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)fileData);
			int i;
			for(i=0;i<size_fileData;i++){
				JSValue js_fileData=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				uint32_t long_fileDatai;
				int err_fileDatai=JS_ToUint32(ctx,&long_fileDatai,js_fileData);
				if(err_fileDatai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_fileData is not numeric");
					return JS_EXCEPTION;
				}
				fileData[i] =((unsigned char)long_fileDatai);
				JS_FreeValue(ctx,js_fileData);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileData =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileData,argv[0]);
		}else{
			JSClassID classid_fileData=JS_GetClassID(argv[0]);
			if(classid_fileData==JS_CLASS_UINT8_ARRAY||classid_fileData==JS_CLASS_UINT8C_ARRAY){
				size_t offset_fileData;
				JSValue da_fileData=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileData,(size_t *)&size_fileData,NULL);
				fileData =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileData,da_fileData);
				fileData +=offset_fileData;
				size_fileData -=offset_fileData;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileData);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[1]);
		if(err_dataSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		int32_t long_fontSize;
		int err_fontSize=JS_ToInt32(ctx,&long_fontSize,argv[2]);
		if(err_fontSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int fontSize=((int)long_fontSize);
		int * codepoints;
		int64_t size_codepoints;
		JSClassID codepoints_class=JS_GetClassID(argv[3]);
		if(codepoints_class==js_ArrayProxy_class_id){
			void * opaque_codepoints=JS_GetOpaque(argv[3],js_ArrayProxy_class_id);
			ArrayProxy_class AP_codepoints=((ArrayProxy_class *)opaque_codepoints)[0];
			argv[3] =AP_codepoints.values(ctx,AP_codepoints.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[3]);
		}
		if(JS_IsArray(argv[3])==1){
			if(JS_GetLength(ctx,argv[3],&size_codepoints)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			codepoints =(int *)js_malloc(ctx,size_codepoints*sizeof(int));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)codepoints);
			int i;
			for(i=0;i<size_codepoints;i++){
				JSValue js_codepoints=JS_GetPropertyUint32(ctx,argv[3],(uint32_t)i);
				int32_t long_codepointsi;
				int err_codepointsi=JS_ToInt32(ctx,&long_codepointsi,js_codepoints);
				if(err_codepointsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_codepoints is not numeric");
					return JS_EXCEPTION;
				}
				codepoints[i] =((int)long_codepointsi);
				JS_FreeValue(ctx,js_codepoints);
			}
		}else if(JS_IsNull(argv[3])||JS_IsUndefined(argv[3])){
			codepoints =NULL;
		}else if(JS_IsArrayBuffer(argv[3])==1){
			codepoints =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_codepoints,argv[3]);
		}else{
			JSClassID classid_codepoints=JS_GetClassID(argv[3]);
			if(classid_codepoints==JS_CLASS_INT16_ARRAY){
				size_t offset_codepoints;
				JSValue da_codepoints=JS_GetTypedArrayBuffer(ctx,argv[3],&offset_codepoints,(size_t *)&size_codepoints,NULL);
				codepoints =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_codepoints,da_codepoints);
				codepoints +=offset_codepoints;
				size_codepoints -=offset_codepoints;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_codepoints);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[3] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_codepointCount;
		int err_codepointCount=JS_ToInt32(ctx,&long_codepointCount,argv[4]);
		if(err_codepointCount<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int codepointCount=((int)long_codepointCount);
		int32_t long_type;
		int err_type=JS_ToInt32(ctx,&long_type,argv[5]);
		if(err_type<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[5] is not numeric");
			return JS_EXCEPTION;
		}
		int type=((int)long_type);
		GlyphInfo * returnVal=LoadFontData((const unsigned char *)fileData,dataSize,fontSize,codepoints,codepointCount,type);
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<codepointCount;i++){
			GlyphInfo * ptr_js_ret=(GlyphInfo *)js_malloc(ctx,sizeof(GlyphInfo));
			ptr_js_ret[0]=returnVal[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_GlyphInfo_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_GenImageFontAtlas(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		GlyphInfo * glyphs;
		int64_t size_glyphs;
		JSClassID glyphs_class=JS_GetClassID(argv[0]);
		if(glyphs_class==js_ArrayProxy_class_id){
			void * opaque_glyphs=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_glyphs=((ArrayProxy_class *)opaque_glyphs)[0];
			argv[0] =AP_glyphs.values(ctx,AP_glyphs.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[0]);
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_glyphs)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			glyphs =(GlyphInfo *)js_malloc(ctx,size_glyphs*sizeof(GlyphInfo));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)glyphs);
			int i;
			for(i=0;i<size_glyphs;i++){
				JSValue js_glyphs=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				GlyphInfo * ptr_glyphsi=(GlyphInfo *)JS_GetOpaque(js_glyphs,js_GlyphInfo_class_id);
				if(ptr_glyphsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_glyphs does not allow null");
					return JS_EXCEPTION;
				}
				glyphs[i] =*ptr_glyphsi;
				JS_FreeValue(ctx,js_glyphs);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			glyphs =(GlyphInfo *)JS_GetArrayBuffer(ctx,(size_t *)&size_glyphs,argv[0]);
		}else{
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type GlyphInfo *");
			return JS_EXCEPTION;
		}
		Rectangle * * glyphRecs;
		glyphRecs[0] =NULL;
		int32_t long_glyphCount;
		int err_glyphCount=JS_ToInt32(ctx,&long_glyphCount,argv[2]);
		if(err_glyphCount<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int glyphCount=((int)long_glyphCount);
		int32_t long_fontSize;
		int err_fontSize=JS_ToInt32(ctx,&long_fontSize,argv[3]);
		if(err_fontSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int fontSize=((int)long_fontSize);
		int32_t long_padding;
		int err_padding=JS_ToInt32(ctx,&long_padding,argv[4]);
		if(err_padding<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int padding=((int)long_padding);
		int32_t long_packMethod;
		int err_packMethod=JS_ToInt32(ctx,&long_packMethod,argv[5]);
		if(err_packMethod<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[5] is not numeric");
			return JS_EXCEPTION;
		}
		int packMethod=((int)long_packMethod);
		Image returnVal=GenImageFontAtlas((const GlyphInfo *)glyphs,glyphRecs,glyphCount,fontSize,padding,packMethod);
		if(glyphRecs!=NULL){
			if(JS_IsArray(argv[1])==1){
				size_t size_argv1;
				JS_GetLength(ctx,argv[1],(int64_t *)&size_argv1);
				int i;
				for(i=0;i<size_argv1;i++){
					Rectangle * ptr_js_argv1=(Rectangle *)js_malloc(ctx,sizeof(Rectangle));
					ptr_js_argv1[0]=*glyphRecs[i];
					JSValue js_argv1=JS_NewObjectClass(ctx,(int)js_Rectangle_class_id);
					JS_SetOpaque(js_argv1,(void *)ptr_js_argv1);
					JS_DefinePropertyValueUint32(ctx,argv[1],(uint32_t)i,js_argv1,JS_PROP_C_W_E);
				}
			}
		}
		Image * ptr_ret=(Image *)js_malloc(ctx,sizeof(Image));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Image_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_UnloadFontData(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		GlyphInfo * glyphs;
		bool freesrc_glyphs=(bool)false;
		int64_t size_glyphs;
		JSClassID glyphs_class=JS_GetClassID(argv[0]);
		if(glyphs_class==js_ArrayProxy_class_id){
			void * opaque_glyphs=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_glyphs=((ArrayProxy_class *)opaque_glyphs)[0];
			argv[0] =AP_glyphs.values(ctx,AP_glyphs.opaque,(int)0,(bool)false);
			freesrc_glyphs =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_glyphs)==-1){
				return JS_EXCEPTION;
			}
			glyphs =(GlyphInfo *)js_malloc(ctx,size_glyphs*sizeof(GlyphInfo));
			int i;
			for(i=0;i<size_glyphs;i++){
				JSValue js_glyphs=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				GlyphInfo * ptr_glyphsi=(GlyphInfo *)JS_GetOpaque(js_glyphs,js_GlyphInfo_class_id);
				if(ptr_glyphsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_glyphs does not allow null");
					return JS_EXCEPTION;
				}
				glyphs[i] =*ptr_glyphsi;
				JS_FreeValue(ctx,js_glyphs);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			glyphs =(GlyphInfo *)JS_GetArrayBuffer(ctx,(size_t *)&size_glyphs,argv[0]);
		}else{
			if(freesrc_glyphs){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type GlyphInfo *");
			return JS_EXCEPTION;
		}
		int32_t long_glyphCount;
		int err_glyphCount=JS_ToInt32(ctx,&long_glyphCount,argv[1]);
		if(err_glyphCount<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)glyphs);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int glyphCount=((int)long_glyphCount);
		UnloadFontData(glyphs,glyphCount);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)glyphs);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_UnloadFont(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font * ptr_font=(Font *)JS_GetOpaque(argv[0],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		UnloadFont(font);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ExportFontAsCode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font * ptr_font=(Font *)JS_GetOpaque(argv[0],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[1])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[1]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=ExportFontAsCode(font,(const char *)fileName);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_DrawFPS(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_posX;
		int err_posX=JS_ToInt32(ctx,&long_posX,argv[0]);
		if(err_posX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int posX=((int)long_posX);
		int32_t long_posY;
		int err_posY=JS_ToInt32(ctx,&long_posY,argv[1]);
		if(err_posY<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int posY=((int)long_posY);
		DrawFPS(posX,posY);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawText(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_posX;
		int err_posX=JS_ToInt32(ctx,&long_posX,argv[1]);
		if(err_posX<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[0]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int posX=((int)long_posX);
		int32_t long_posY;
		int err_posY=JS_ToInt32(ctx,&long_posY,argv[2]);
		if(err_posY<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[0]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int posY=((int)long_posY);
		int32_t long_fontSize;
		int err_fontSize=JS_ToInt32(ctx,&long_fontSize,argv[3]);
		if(err_fontSize<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[0]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int fontSize=((int)long_fontSize);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[0]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawText((const char *)text,posX,posY,fontSize,color);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTextEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font * ptr_font=(Font *)JS_GetOpaque(argv[0],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[1])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[1]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[1]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_position==NULL){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		double double_fontSize;
		int err_fontSize=JS_ToFloat64(ctx,&double_fontSize,argv[3]);
		if(err_fontSize<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float fontSize=((float)double_fontSize);
		double double_spacing;
		int err_spacing=JS_ToFloat64(ctx,&double_spacing,argv[4]);
		if(err_spacing<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float spacing=((float)double_spacing);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_tint==NULL){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawTextEx(font,(const char *)text,position,fontSize,spacing,tint);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[1]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTextPro(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font * ptr_font=(Font *)JS_GetOpaque(argv[0],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[1])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[1]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[1]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_position==NULL){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		Vector2 * ptr_origin=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_origin==NULL){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 origin=*ptr_origin;
		double double_rotation;
		int err_rotation=JS_ToFloat64(ctx,&double_rotation,argv[4]);
		if(err_rotation<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float rotation=((float)double_rotation);
		double double_fontSize;
		int err_fontSize=JS_ToFloat64(ctx,&double_fontSize,argv[5]);
		if(err_fontSize<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[5] is not numeric");
			return JS_EXCEPTION;
		}
		float fontSize=((float)double_fontSize);
		double double_spacing;
		int err_spacing=JS_ToFloat64(ctx,&double_spacing,argv[6]);
		if(err_spacing<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[6] is not numeric");
			return JS_EXCEPTION;
		}
		float spacing=((float)double_spacing);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[7],js_Color_class_id);
		if(ptr_tint==NULL){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[7] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawTextPro(font,(const char *)text,position,origin,rotation,fontSize,spacing,tint);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[1]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTextCodepoint(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font * ptr_font=(Font *)JS_GetOpaque(argv[0],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		int32_t long_codepoint;
		int err_codepoint=JS_ToInt32(ctx,&long_codepoint,argv[1]);
		if(err_codepoint<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int codepoint=((int)long_codepoint);
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[2],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		double double_fontSize;
		int err_fontSize=JS_ToFloat64(ctx,&double_fontSize,argv[3]);
		if(err_fontSize<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float fontSize=((float)double_fontSize);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawTextCodepoint(font,codepoint,position,fontSize,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTextCodepoints(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font * ptr_font=(Font *)JS_GetOpaque(argv[0],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		int * codepoints;
		bool freesrc_codepoints=(bool)false;
		JSValue da_codepoints;
		int64_t size_codepoints;
		JSClassID codepoints_class=JS_GetClassID(argv[1]);
		if(codepoints_class==js_ArrayProxy_class_id){
			void * opaque_codepoints=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_codepoints=((ArrayProxy_class *)opaque_codepoints)[0];
			argv[1] =AP_codepoints.values(ctx,AP_codepoints.opaque,(int)0,(bool)false);
			freesrc_codepoints =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_codepoints)==-1){
				return JS_EXCEPTION;
			}
			codepoints =(int *)js_malloc(ctx,size_codepoints*sizeof(int));
			int i;
			for(i=0;i<size_codepoints;i++){
				JSValue js_codepoints=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_codepointsi;
				int err_codepointsi=JS_ToInt32(ctx,&long_codepointsi,js_codepoints);
				if(err_codepointsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_codepoints is not numeric");
					return JS_EXCEPTION;
				}
				codepoints[i] =((int)long_codepointsi);
				JS_FreeValue(ctx,js_codepoints);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			codepoints =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_codepoints,argv[1]);
		}else{
			JSClassID classid_codepoints=JS_GetClassID(argv[1]);
			if(classid_codepoints==JS_CLASS_INT16_ARRAY){
				size_t offset_codepoints;
				da_codepoints =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_codepoints,(size_t *)&size_codepoints,NULL);
				codepoints =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_codepoints,da_codepoints);
				codepoints +=offset_codepoints;
				size_codepoints -=offset_codepoints;
			}else{
				if(freesrc_codepoints){
					JS_FreeValue(ctx,argv[1]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_codepointCount;
		int err_codepointCount=JS_ToInt32(ctx,&long_codepointCount,argv[2]);
		if(err_codepointCount<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)codepoints);
			}else{
				JSClassID classid_codepoints=JS_GetClassID(argv[1]);
				if(classid_codepoints==JS_CLASS_INT16_ARRAY){
					js_free(ctx,(void *)&da_codepoints);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int codepointCount=((int)long_codepointCount);
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[3],js_Vector2_class_id);
		if(ptr_position==NULL){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)codepoints);
			}else{
				JSClassID classid_codepoints=JS_GetClassID(argv[1]);
				if(classid_codepoints==JS_CLASS_INT16_ARRAY){
					js_free(ctx,(void *)&da_codepoints);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		double double_fontSize;
		int err_fontSize=JS_ToFloat64(ctx,&double_fontSize,argv[4]);
		if(err_fontSize<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)codepoints);
			}else{
				JSClassID classid_codepoints=JS_GetClassID(argv[1]);
				if(classid_codepoints==JS_CLASS_INT16_ARRAY){
					js_free(ctx,(void *)&da_codepoints);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		float fontSize=((float)double_fontSize);
		double double_spacing;
		int err_spacing=JS_ToFloat64(ctx,&double_spacing,argv[5]);
		if(err_spacing<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)codepoints);
			}else{
				JSClassID classid_codepoints=JS_GetClassID(argv[1]);
				if(classid_codepoints==JS_CLASS_INT16_ARRAY){
					js_free(ctx,(void *)&da_codepoints);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[5] is not numeric");
			return JS_EXCEPTION;
		}
		float spacing=((float)double_spacing);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[6],js_Color_class_id);
		if(ptr_tint==NULL){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)codepoints);
			}else{
				JSClassID classid_codepoints=JS_GetClassID(argv[1]);
				if(classid_codepoints==JS_CLASS_INT16_ARRAY){
					js_free(ctx,(void *)&da_codepoints);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[6] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawTextCodepoints(font,(const int *)codepoints,codepointCount,position,fontSize,spacing,tint);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)codepoints);
		}else{
			JSClassID classid_codepoints=JS_GetClassID(argv[1]);
			if(classid_codepoints==JS_CLASS_INT16_ARRAY){
				js_free(ctx,(void *)&da_codepoints);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetTextLineSpacing(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_spacing;
		int err_spacing=JS_ToInt32(ctx,&long_spacing,argv[0]);
		if(err_spacing<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int spacing=((int)long_spacing);
		SetTextLineSpacing(spacing);
		return JS_UNDEFINED;
	}
	
	static JSValue js_MeasureText(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_fontSize;
		int err_fontSize=JS_ToInt32(ctx,&long_fontSize,argv[1]);
		if(err_fontSize<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[0]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int fontSize=((int)long_fontSize);
		int returnVal=MeasureText((const char *)text,fontSize);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_MeasureTextEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font * ptr_font=(Font *)JS_GetOpaque(argv[0],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[1])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[1]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[1]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		double double_fontSize;
		int err_fontSize=JS_ToFloat64(ctx,&double_fontSize,argv[2]);
		if(err_fontSize<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float fontSize=((float)double_fontSize);
		double double_spacing;
		int err_spacing=JS_ToFloat64(ctx,&double_spacing,argv[3]);
		if(err_spacing<0){
			if(JS_IsArray(argv[1])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[1])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[1]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float spacing=((float)double_spacing);
		Vector2 returnVal=MeasureTextEx(font,(const char *)text,fontSize,spacing);
		Vector2 * ptr_ret=(Vector2 *)js_malloc(ctx,sizeof(Vector2));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Vector2_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[1]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_GetGlyphIndex(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font * ptr_font=(Font *)JS_GetOpaque(argv[0],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		int32_t long_codepoint;
		int err_codepoint=JS_ToInt32(ctx,&long_codepoint,argv[1]);
		if(err_codepoint<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int codepoint=((int)long_codepoint);
		int returnVal=GetGlyphIndex(font,codepoint);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		return ret;
	}
	
	static JSValue js_GetGlyphInfo(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font * ptr_font=(Font *)JS_GetOpaque(argv[0],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		int32_t long_codepoint;
		int err_codepoint=JS_ToInt32(ctx,&long_codepoint,argv[1]);
		if(err_codepoint<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int codepoint=((int)long_codepoint);
		GlyphInfo returnVal=GetGlyphInfo(font,codepoint);
		GlyphInfo * ptr_ret=(GlyphInfo *)js_malloc(ctx,sizeof(GlyphInfo));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_GlyphInfo_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetGlyphAtlasRec(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Font * ptr_font=(Font *)JS_GetOpaque(argv[0],js_Font_class_id);
		if(ptr_font==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Font font=*ptr_font;
		int32_t long_codepoint;
		int err_codepoint=JS_ToInt32(ctx,&long_codepoint,argv[1]);
		if(err_codepoint<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int codepoint=((int)long_codepoint);
		Rectangle returnVal=GetGlyphAtlasRec(font,codepoint);
		Rectangle * ptr_ret=(Rectangle *)js_malloc(ctx,sizeof(Rectangle));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Rectangle_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_LoadUTF8(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int * codepoints;
		bool freesrc_codepoints=(bool)false;
		JSValue da_codepoints;
		int64_t size_codepoints;
		JSClassID codepoints_class=JS_GetClassID(argv[0]);
		if(codepoints_class==js_ArrayProxy_class_id){
			void * opaque_codepoints=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_codepoints=((ArrayProxy_class *)opaque_codepoints)[0];
			argv[0] =AP_codepoints.values(ctx,AP_codepoints.opaque,(int)0,(bool)false);
			freesrc_codepoints =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_codepoints)==-1){
				return JS_EXCEPTION;
			}
			codepoints =(int *)js_malloc(ctx,size_codepoints*sizeof(int));
			int i;
			for(i=0;i<size_codepoints;i++){
				JSValue js_codepoints=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				int32_t long_codepointsi;
				int err_codepointsi=JS_ToInt32(ctx,&long_codepointsi,js_codepoints);
				if(err_codepointsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_codepoints is not numeric");
					return JS_EXCEPTION;
				}
				codepoints[i] =((int)long_codepointsi);
				JS_FreeValue(ctx,js_codepoints);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			codepoints =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_codepoints,argv[0]);
		}else{
			JSClassID classid_codepoints=JS_GetClassID(argv[0]);
			if(classid_codepoints==JS_CLASS_INT16_ARRAY){
				size_t offset_codepoints;
				da_codepoints =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_codepoints,(size_t *)&size_codepoints,NULL);
				codepoints =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_codepoints,da_codepoints);
				codepoints +=offset_codepoints;
				size_codepoints -=offset_codepoints;
			}else{
				if(freesrc_codepoints){
					JS_FreeValue(ctx,argv[0]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_length;
		int err_length=JS_ToInt32(ctx,&long_length,argv[1]);
		if(err_length<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)codepoints);
			}else{
				JSClassID classid_codepoints=JS_GetClassID(argv[0]);
				if(classid_codepoints==JS_CLASS_INT16_ARRAY){
					js_free(ctx,(void *)&da_codepoints);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int length=((int)long_length);
		char * returnVal=LoadUTF8((const int *)codepoints,length);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)codepoints);
		}else{
			JSClassID classid_codepoints=JS_GetClassID(argv[0]);
			if(classid_codepoints==JS_CLASS_INT16_ARRAY){
				js_free(ctx,(void *)&da_codepoints);
			}
		}
		return ret;
	}
	
	static JSValue js_UnloadUTF8(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		UnloadUTF8(text);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_LoadCodepoints(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int * count;
		bool freesrc_count=(bool)false;
		int64_t size_count;
		JSClassID count_class=JS_GetClassID(argv[1]);
		if(count_class==js_ArrayProxy_class_id){
			void * opaque_count=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_count=((ArrayProxy_class *)opaque_count)[0];
			argv[1] =AP_count.values(ctx,AP_count.opaque,(int)0,(bool)false);
			freesrc_count =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_count)==-1){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)text);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)text);
				}else{
					JSClassID classid_text=JS_GetClassID(argv[0]);
					if(classid_text==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_text);
					}
				}
				return JS_EXCEPTION;
			}
			count =(int *)js_malloc(ctx,size_count*sizeof(int));
			int i;
			for(i=0;i<size_count;i++){
				JSValue js_count=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_counti;
				int err_counti=JS_ToInt32(ctx,&long_counti,js_count);
				if(err_counti<0){
					JS_ThrowTypeError(ctx,(const char *)"js_count is not numeric");
					return JS_EXCEPTION;
				}
				count[i] =((int)long_counti);
				JS_FreeValue(ctx,js_count);
			}
		}else{
			int32_t long_js_count;
			int err_js_count=JS_ToInt32(ctx,&long_js_count,argv[1]);
			if(err_js_count<0){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)text);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)text);
				}else{
					JSClassID classid_text=JS_GetClassID(argv[0]);
					if(classid_text==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_text);
					}
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
				return JS_EXCEPTION;
			}
			int js_count=((int)long_js_count);
			count =&js_count;
		}
		int * returnVal=LoadCodepoints((const char *)text,count);
		if(JS_IsArray(argv[1])==1){
			JSValue js_argv1=JS_NewInt32(ctx,(int32_t)((long)count[0]));
			JS_DefinePropertyValueUint32(ctx,argv[1],(uint32_t)0,js_argv1,JS_PROP_C_W_E);
		}
		JSValue ret;
		ret =JS_NewArray(ctx);
		int * sizeref_ret=returnVal;
		size_t size_ret=sizeof(sizeref_ret);
		size_t size1_ret=sizeof(int);
		size_ret =size_ret/size1_ret;
		int i;
		for(i=0;i<size_ret;i++){
			JSValue js_ret=JS_NewInt32(ctx,(int32_t)((long)returnVal[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)count);
		}
		return ret;
	}
	
	static JSValue js_UnloadCodepoints(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int * codepoints;
		bool freesrc_codepoints=(bool)false;
		int64_t size_codepoints;
		JSClassID codepoints_class=JS_GetClassID(argv[0]);
		if(codepoints_class==js_ArrayProxy_class_id){
			void * opaque_codepoints=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_codepoints=((ArrayProxy_class *)opaque_codepoints)[0];
			argv[0] =AP_codepoints.values(ctx,AP_codepoints.opaque,(int)0,(bool)false);
			freesrc_codepoints =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_codepoints)==-1){
				return JS_EXCEPTION;
			}
			codepoints =(int *)js_malloc(ctx,size_codepoints*sizeof(int));
			int i;
			for(i=0;i<size_codepoints;i++){
				JSValue js_codepoints=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				int32_t long_codepointsi;
				int err_codepointsi=JS_ToInt32(ctx,&long_codepointsi,js_codepoints);
				if(err_codepointsi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_codepoints is not numeric");
					return JS_EXCEPTION;
				}
				codepoints[i] =((int)long_codepointsi);
				JS_FreeValue(ctx,js_codepoints);
			}
		}else{
			int32_t long_js_codepoints;
			int err_js_codepoints=JS_ToInt32(ctx,&long_js_codepoints,argv[0]);
			if(err_js_codepoints<0){
				JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
				return JS_EXCEPTION;
			}
			int js_codepoints=((int)long_js_codepoints);
			codepoints =&js_codepoints;
		}
		UnloadCodepoints(codepoints);
		if(JS_IsArray(argv[0])==1){
			JSValue js_argv0=JS_NewInt32(ctx,(int32_t)((long)codepoints[0]));
			JS_DefinePropertyValueUint32(ctx,argv[0],(uint32_t)0,js_argv0,JS_PROP_C_W_E);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetCodepointCount(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int returnVal=GetCodepointCount((const char *)text);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_GetCodepoint(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int * codepointSize;
		bool freesrc_codepointSize=(bool)false;
		int64_t size_codepointSize;
		JSClassID codepointSize_class=JS_GetClassID(argv[1]);
		if(codepointSize_class==js_ArrayProxy_class_id){
			void * opaque_codepointSize=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_codepointSize=((ArrayProxy_class *)opaque_codepointSize)[0];
			argv[1] =AP_codepointSize.values(ctx,AP_codepointSize.opaque,(int)0,(bool)false);
			freesrc_codepointSize =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_codepointSize)==-1){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)text);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)text);
				}else{
					JSClassID classid_text=JS_GetClassID(argv[0]);
					if(classid_text==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_text);
					}
				}
				return JS_EXCEPTION;
			}
			codepointSize =(int *)js_malloc(ctx,size_codepointSize*sizeof(int));
			int i;
			for(i=0;i<size_codepointSize;i++){
				JSValue js_codepointSize=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_codepointSizei;
				int err_codepointSizei=JS_ToInt32(ctx,&long_codepointSizei,js_codepointSize);
				if(err_codepointSizei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_codepointSize is not numeric");
					return JS_EXCEPTION;
				}
				codepointSize[i] =((int)long_codepointSizei);
				JS_FreeValue(ctx,js_codepointSize);
			}
		}else{
			int32_t long_js_codepointSize;
			int err_js_codepointSize=JS_ToInt32(ctx,&long_js_codepointSize,argv[1]);
			if(err_js_codepointSize<0){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)text);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)text);
				}else{
					JSClassID classid_text=JS_GetClassID(argv[0]);
					if(classid_text==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_text);
					}
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
				return JS_EXCEPTION;
			}
			int js_codepointSize=((int)long_js_codepointSize);
			codepointSize =&js_codepointSize;
		}
		int returnVal=GetCodepoint((const char *)text,codepointSize);
		if(JS_IsArray(argv[1])==1){
			JSValue js_argv1=JS_NewInt32(ctx,(int32_t)((long)codepointSize[0]));
			JS_DefinePropertyValueUint32(ctx,argv[1],(uint32_t)0,js_argv1,JS_PROP_C_W_E);
		}
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)codepointSize);
		}
		return ret;
	}
	
	static JSValue js_GetCodepointNext(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int * codepointSize;
		bool freesrc_codepointSize=(bool)false;
		int64_t size_codepointSize;
		JSClassID codepointSize_class=JS_GetClassID(argv[1]);
		if(codepointSize_class==js_ArrayProxy_class_id){
			void * opaque_codepointSize=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_codepointSize=((ArrayProxy_class *)opaque_codepointSize)[0];
			argv[1] =AP_codepointSize.values(ctx,AP_codepointSize.opaque,(int)0,(bool)false);
			freesrc_codepointSize =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_codepointSize)==-1){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)text);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)text);
				}else{
					JSClassID classid_text=JS_GetClassID(argv[0]);
					if(classid_text==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_text);
					}
				}
				return JS_EXCEPTION;
			}
			codepointSize =(int *)js_malloc(ctx,size_codepointSize*sizeof(int));
			int i;
			for(i=0;i<size_codepointSize;i++){
				JSValue js_codepointSize=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_codepointSizei;
				int err_codepointSizei=JS_ToInt32(ctx,&long_codepointSizei,js_codepointSize);
				if(err_codepointSizei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_codepointSize is not numeric");
					return JS_EXCEPTION;
				}
				codepointSize[i] =((int)long_codepointSizei);
				JS_FreeValue(ctx,js_codepointSize);
			}
		}else{
			int32_t long_js_codepointSize;
			int err_js_codepointSize=JS_ToInt32(ctx,&long_js_codepointSize,argv[1]);
			if(err_js_codepointSize<0){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)text);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)text);
				}else{
					JSClassID classid_text=JS_GetClassID(argv[0]);
					if(classid_text==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_text);
					}
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
				return JS_EXCEPTION;
			}
			int js_codepointSize=((int)long_js_codepointSize);
			codepointSize =&js_codepointSize;
		}
		int returnVal=GetCodepointNext((const char *)text,codepointSize);
		if(JS_IsArray(argv[1])==1){
			JSValue js_argv1=JS_NewInt32(ctx,(int32_t)((long)codepointSize[0]));
			JS_DefinePropertyValueUint32(ctx,argv[1],(uint32_t)0,js_argv1,JS_PROP_C_W_E);
		}
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)codepointSize);
		}
		return ret;
	}
	
	static JSValue js_GetCodepointPrevious(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int * codepointSize;
		bool freesrc_codepointSize=(bool)false;
		int64_t size_codepointSize;
		JSClassID codepointSize_class=JS_GetClassID(argv[1]);
		if(codepointSize_class==js_ArrayProxy_class_id){
			void * opaque_codepointSize=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_codepointSize=((ArrayProxy_class *)opaque_codepointSize)[0];
			argv[1] =AP_codepointSize.values(ctx,AP_codepointSize.opaque,(int)0,(bool)false);
			freesrc_codepointSize =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_codepointSize)==-1){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)text);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)text);
				}else{
					JSClassID classid_text=JS_GetClassID(argv[0]);
					if(classid_text==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_text);
					}
				}
				return JS_EXCEPTION;
			}
			codepointSize =(int *)js_malloc(ctx,size_codepointSize*sizeof(int));
			int i;
			for(i=0;i<size_codepointSize;i++){
				JSValue js_codepointSize=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_codepointSizei;
				int err_codepointSizei=JS_ToInt32(ctx,&long_codepointSizei,js_codepointSize);
				if(err_codepointSizei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_codepointSize is not numeric");
					return JS_EXCEPTION;
				}
				codepointSize[i] =((int)long_codepointSizei);
				JS_FreeValue(ctx,js_codepointSize);
			}
		}else{
			int32_t long_js_codepointSize;
			int err_js_codepointSize=JS_ToInt32(ctx,&long_js_codepointSize,argv[1]);
			if(err_js_codepointSize<0){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)text);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)text);
				}else{
					JSClassID classid_text=JS_GetClassID(argv[0]);
					if(classid_text==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_text);
					}
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
				return JS_EXCEPTION;
			}
			int js_codepointSize=((int)long_js_codepointSize);
			codepointSize =&js_codepointSize;
		}
		int returnVal=GetCodepointPrevious((const char *)text,codepointSize);
		if(JS_IsArray(argv[1])==1){
			JSValue js_argv1=JS_NewInt32(ctx,(int32_t)((long)codepointSize[0]));
			JS_DefinePropertyValueUint32(ctx,argv[1],(uint32_t)0,js_argv1,JS_PROP_C_W_E);
		}
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)codepointSize);
		}
		return ret;
	}
	
	static JSValue js_CodepointToUTF8(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_codepoint;
		int err_codepoint=JS_ToInt32(ctx,&long_codepoint,argv[0]);
		if(err_codepoint<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int codepoint=((int)long_codepoint);
		int * utf8Size;
		bool freesrc_utf8Size=(bool)false;
		JSValue da_utf8Size;
		int64_t size_utf8Size;
		JSClassID utf8Size_class=JS_GetClassID(argv[1]);
		if(utf8Size_class==js_ArrayProxy_class_id){
			void * opaque_utf8Size=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_utf8Size=((ArrayProxy_class *)opaque_utf8Size)[0];
			argv[1] =AP_utf8Size.values(ctx,AP_utf8Size.opaque,(int)0,(bool)false);
			freesrc_utf8Size =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_utf8Size)==-1){
				return JS_EXCEPTION;
			}
			utf8Size =(int *)js_malloc(ctx,size_utf8Size*sizeof(int));
			int i;
			for(i=0;i<size_utf8Size;i++){
				JSValue js_utf8Size=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_utf8Sizei;
				int err_utf8Sizei=JS_ToInt32(ctx,&long_utf8Sizei,js_utf8Size);
				if(err_utf8Sizei<0){
					JS_ThrowTypeError(ctx,(const char *)"js_utf8Size is not numeric");
					return JS_EXCEPTION;
				}
				utf8Size[i] =((int)long_utf8Sizei);
				JS_FreeValue(ctx,js_utf8Size);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			utf8Size =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_utf8Size,argv[1]);
		}else{
			JSClassID classid_utf8Size=JS_GetClassID(argv[1]);
			if(classid_utf8Size==JS_CLASS_INT16_ARRAY){
				size_t offset_utf8Size;
				da_utf8Size =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_utf8Size,(size_t *)&size_utf8Size,NULL);
				utf8Size =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_utf8Size,da_utf8Size);
				utf8Size +=offset_utf8Size;
				size_utf8Size -=offset_utf8Size;
			}else{
				if(freesrc_utf8Size){
					JS_FreeValue(ctx,argv[1]);
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=(char *)CodepointToUTF8(codepoint,utf8Size);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)utf8Size);
		}else{
			JSClassID classid_utf8Size=JS_GetClassID(argv[1]);
			if(classid_utf8Size==JS_CLASS_INT16_ARRAY){
				js_free(ctx,(void *)&da_utf8Size);
			}
		}
		return ret;
	}
	
	static JSValue js_LoadTextLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int * count;
		bool freesrc_count=(bool)false;
		int64_t size_count;
		JSClassID count_class=JS_GetClassID(argv[1]);
		if(count_class==js_ArrayProxy_class_id){
			void * opaque_count=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_count=((ArrayProxy_class *)opaque_count)[0];
			argv[1] =AP_count.values(ctx,AP_count.opaque,(int)0,(bool)false);
			freesrc_count =(bool)true;
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_count)==-1){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)text);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)text);
				}else{
					JSClassID classid_text=JS_GetClassID(argv[0]);
					if(classid_text==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_text);
					}
				}
				return JS_EXCEPTION;
			}
			count =(int *)js_malloc(ctx,size_count*sizeof(int));
			int i;
			for(i=0;i<size_count;i++){
				JSValue js_count=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_counti;
				int err_counti=JS_ToInt32(ctx,&long_counti,js_count);
				if(err_counti<0){
					JS_ThrowTypeError(ctx,(const char *)"js_count is not numeric");
					return JS_EXCEPTION;
				}
				count[i] =((int)long_counti);
				JS_FreeValue(ctx,js_count);
			}
		}else{
			int32_t long_js_count;
			int err_js_count=JS_ToInt32(ctx,&long_js_count,argv[1]);
			if(err_js_count<0){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)text);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)text);
				}else{
					JSClassID classid_text=JS_GetClassID(argv[0]);
					if(classid_text==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_text);
					}
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
				return JS_EXCEPTION;
			}
			int js_count=((int)long_js_count);
			count =&js_count;
		}
		char * * returnVal=LoadTextLines((const char *)text,count);
		if(JS_IsArray(argv[1])==1){
			JSValue js_argv1=JS_NewInt32(ctx,(int32_t)((long)count[0]));
			JS_DefinePropertyValueUint32(ctx,argv[1],(uint32_t)0,js_argv1,JS_PROP_C_W_E);
		}
		JSValue ret;
		ret =JS_NewArray(ctx);
		char * * sizeref_ret=returnVal;
		size_t size_ret=sizeof(sizeref_ret);
		size_t size1_ret=sizeof(char *);
		size_ret =size_ret/size1_ret;
		int i;
		for(i=0;i<size_ret;i++){
			JSValue js_ret;
			js_ret =JS_NewString(ctx,(const char *)returnVal[i]);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)count);
		}
		return ret;
	}
	
	static JSValue js_UnloadTextLines(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * * text;
		bool freesrc_text=(bool)false;
		int64_t size_text;
		JSClassID text_class=JS_GetClassID(argv[0]);
		if(text_class==js_ArrayProxy_class_id){
			void * opaque_text=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_text=((ArrayProxy_class *)opaque_text)[0];
			argv[0] =AP_text.values(ctx,AP_text.opaque,(int)0,(bool)false);
			freesrc_text =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_text)==-1){
				return JS_EXCEPTION;
			}
			text =(char * *)js_malloc(ctx,size_text*sizeof(char *));
			int i;
			for(i=0;i<size_text;i++){
				JSValue js_text=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				int64_t size_texti;
				if(JS_IsString(js_text)==1){
					text[i] =(char *)JS_ToCStringLen(ctx,(size_t *)&size_texti,js_text);
					memoryNode * memoryCurrent=memoryStore(memoryCurrent,JS_FreeCString,(void *)text[i]);
				}else if(JS_IsArrayBuffer(js_text)==1){
					text[i] =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_texti,js_text);
				}else{
					JSClassID classid_texti=JS_GetClassID(js_text);
					if(classid_texti==JS_CLASS_INT8_ARRAY){
						size_t offset_texti;
						JSValue da_texti=JS_GetTypedArrayBuffer(ctx,js_text,&offset_texti,(size_t *)&size_texti,NULL);
						text[i] =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_texti,da_texti);
						text[i] +=offset_texti;
						size_texti -=offset_texti;
						memoryNode * memoryCurrent=memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_texti);
					}else{
						JS_ThrowTypeError(ctx,(const char *)"js_text does not match type char *");
						return JS_EXCEPTION;
					}
				}
				JS_FreeValue(ctx,js_text);
			}
		}else{
			if(freesrc_text){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char * *");
			return JS_EXCEPTION;
		}
		UnloadTextLines(text);
		if(JS_IsArray(argv[0])==1){
			argv[0] =JS_NewString(ctx,(const char *)*text);
		}
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)*text);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_TextIsEqual(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * text1;
		int64_t size_text1;
		if(JS_IsString(argv[0])==1){
			text1 =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text1,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)text1);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text1 =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text1,argv[0]);
		}else{
			JSClassID classid_text1=JS_GetClassID(argv[0]);
			if(classid_text1==JS_CLASS_INT8_ARRAY){
				size_t offset_text1;
				JSValue da_text1=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text1,(size_t *)&size_text1,NULL);
				text1 =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text1,da_text1);
				text1 +=offset_text1;
				size_text1 -=offset_text1;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_text1);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * text2;
		int64_t size_text2;
		if(JS_IsString(argv[1])==1){
			text2 =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text2,argv[1]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)text2);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			text2 =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text2,argv[1]);
		}else{
			JSClassID classid_text2=JS_GetClassID(argv[1]);
			if(classid_text2==JS_CLASS_INT8_ARRAY){
				size_t offset_text2;
				JSValue da_text2=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_text2,(size_t *)&size_text2,NULL);
				text2 =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text2,da_text2);
				text2 +=offset_text2;
				size_text2 -=offset_text2;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_text2);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=TextIsEqual((const char *)text1,(const char *)text2);
		JSValue ret=JS_NewBool(ctx,returnVal);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_TextLength(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int returnVal=TextLength((const char *)text);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_TextFormat(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		size_t char_ptrlen=(size_t)10;
		char * char_ptr=(char *)js_calloc(ctx,char_ptrlen,sizeof(char));
		int64_t formatlen;
		if(JS_GetLength(ctx,argv[0],&formatlen)==-1){
			memoryClear(ctx,memoryHead);
			js_free(ctx,(void *)char_ptr);
			return JS_EXCEPTION;
		}
		char * format;
		int64_t size_format;
		if(JS_IsString(argv[0])==1){
			format =(char *)JS_ToCStringLen(ctx,(size_t *)&size_format,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)format);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			format =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_format,argv[0]);
		}else{
			JSClassID classid_format=JS_GetClassID(argv[0]);
			if(classid_format==JS_CLASS_INT8_ARRAY){
				size_t offset_format;
				JSValue da_format=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_format,(size_t *)&size_format,NULL);
				format =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_format,da_format);
				format +=offset_format;
				size_format -=offset_format;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_format);
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * subformat=format;
		size_t subformatlen=(size_t)0;
		char subformatlenh;
		size_t bufferlen=formatlen*2;
		char * buffer=(char *)js_calloc(ctx,bufferlen,sizeof(char));
		int l=(int)0;
		int c=(int)1;
		int ilen=(int)0;
		int i;
		for(i=0;i<formatlen;i++){
			int n=(int)2;
			int w=(int)0;
			int p=(int)0;
			if(format[i]!='%'){
				buffer[l]=format[i];
				l +=1;
			}else{
				int firsth=(int)i+1;
				char har=format[firsth];
				if(har==0){
					JSValue ret;
					ret =JS_NewString(ctx,(const char *)buffer);
					memoryClear(ctx,memoryHead);
					js_free(ctx,(void *)char_ptr);
					js_free(ctx,(void *)buffer);
					return ret;
				}
				while(!(har>=97&&har<=122)&&!(har>=65&&har<=90)&&har!='%'){
					firsth +=1;
					har =format[firsth];
					if(har==0){
						JSValue ret;
						ret =JS_NewString(ctx,(const char *)buffer);
						memoryClear(ctx,memoryHead);
						js_free(ctx,(void *)char_ptr);
						js_free(ctx,(void *)buffer);
						return ret;
					}
				}
				int lasth=firsth;
				har=format[lasth];
				while(strchr("diuoxXfFeEfFeEgGaAcspn%", har)==NULL){
					if(har=='*'){
						if(n==1){
							w =p;
						}
						int32_t long_p;
						int err_p=JS_ToInt32(ctx,&long_p,argv[c]);
						if(err_p<0){
							memoryClear(ctx,memoryHead);
							js_free(ctx,(void *)char_ptr);
							js_free(ctx,(void *)buffer);
							JS_ThrowTypeError(ctx,(const char *)"argv[c] is not numeric");
							return JS_EXCEPTION;
						}
						p =((int)long_p);
						c +=1;
						n -=1;
					}
					lasth +=1;
					har =format[lasth];
					if(har==0){
						JSValue ret;
						ret =JS_NewString(ctx,(const char *)buffer);
						memoryClear(ctx,memoryHead);
						js_free(ctx,(void *)char_ptr);
						js_free(ctx,(void *)buffer);
						return ret;
					}
				}
				subformatlen =lasth-i+1;
				subformatlenh =format[lasth+1];
				subformat =format+i;
				subformat[subformatlen]=(char)0;
				if(format[lasth]=='%'){
					i =lasth;
					buffer[l]='%';
					l +=1;
					continue;
				}
				memset((void *)char_ptr,(int)0,ilen*sizeof(char));
				if(har=='d'||har=='i'){
					int64_t a;
					int err_a=JS_ToInt64(ctx,&a,argv[c]);
					if(err_a<0){
						memoryClear(ctx,memoryHead);
						js_free(ctx,(void *)char_ptr);
						js_free(ctx,(void *)buffer);
						JS_ThrowTypeError(ctx,(const char *)"argv[c] is not numeric");
						return JS_EXCEPTION;
					}
					if(firsth==lasth){
						char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(int)a);
					}else{
						if(format[lasth-1]=='h'){
							if(subformat[lasth-i-2]=='h'){
								char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(signed char)a);
							}else{
								char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(short int)a);
							}
						}else if(format[lasth-1]=='l'){
							if(subformat[lasth-i-2]=='l'){
								char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(long long int)a);
							}else{
								char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(long int)a);
							}
						}else if(format[lasth-1]=='j'){
							char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(intmax_t)a);
						}else if(format[lasth-1]=='z'){
							char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(size_t)a);
						}else if(format[lasth-1]=='t'){
							char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(ptrdiff_t)a);
						}
					}
				}else if(har=='u'||har=='o'||har=='x'||har=='X'){
					uint32_t a;
					int err_a=JS_ToUint32(ctx,&a,argv[c]);
					if(err_a<0){
						memoryClear(ctx,memoryHead);
						js_free(ctx,(void *)char_ptr);
						js_free(ctx,(void *)buffer);
						JS_ThrowTypeError(ctx,(const char *)"argv[c] is not numeric");
						return JS_EXCEPTION;
					}
					if(firsth==lasth){
						char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(unsigned int)a);
					}else{
						if(subformat[lasth-i-1]=='h'){
							if(subformat[lasth-i-2]=='h'){
								char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(unsigned char)a);
							}else{
								char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(unsigned short int)a);
							}
						}else if(subformat[lasth-i-1]=='l'){
							if(subformat[lasth-i-2]=='l'){
								char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(unsigned long long int)a);
							}else{
								char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(unsigned long int)a);
							}
						}else if(subformat[lasth-i-1]=='j'){
							char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(uintmax_t)a);
						}else if(subformat[lasth-i-1]=='z'){
							char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(size_t)a);
						}else if(subformat[lasth-i-1]=='t'){
							char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(ptrdiff_t)a);
						}
					}
				}else if(har=='f'||har=='F'||har=='e'||har=='E'||har=='g'||har=='G'||har=='a'||har=='A'){
					double a;
					int err_a=JS_ToFloat64(ctx,&a,argv[c]);
					if(err_a<0){
						memoryClear(ctx,memoryHead);
						js_free(ctx,(void *)char_ptr);
						js_free(ctx,(void *)buffer);
						JS_ThrowTypeError(ctx,(const char *)"argv[c] is not numeric");
						return JS_EXCEPTION;
					}
					if(firsth==lasth){
						char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(double)a);
					}else{
						char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(long double)a);
					}
				}else if(har=='c'){
					int32_t long_a;
					int err_a=JS_ToInt32(ctx,&long_a,argv[c]);
					if(err_a<0){
						memoryClear(ctx,memoryHead);
						js_free(ctx,(void *)char_ptr);
						js_free(ctx,(void *)buffer);
						JS_ThrowTypeError(ctx,(const char *)"argv[c] is not numeric");
						return JS_EXCEPTION;
					}
					int a=((int)long_a);
					if(firsth==lasth){
						char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(int)a);
					}else{
						char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(wint_t)a);
					}
				}else if(har=='s'){
					if(firsth==lasth){
						char * a;
						int64_t size_a;
						if(JS_IsString(argv[c])==1){
							a =(char *)JS_ToCStringLen(ctx,(size_t *)&size_a,argv[c]);
							memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)a);
						}else if(JS_IsArrayBuffer(argv[c])==1){
							a =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_a,argv[c]);
						}else{
							JSClassID classid_a=JS_GetClassID(argv[c]);
							if(classid_a==JS_CLASS_INT8_ARRAY){
								size_t offset_a;
								JSValue da_a=JS_GetTypedArrayBuffer(ctx,argv[c],&offset_a,(size_t *)&size_a,NULL);
								a =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_a,da_a);
								a +=offset_a;
								size_a -=offset_a;
								memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_a);
							}else{
								memoryClear(ctx,memoryHead);
								js_free(ctx,(void *)char_ptr);
								js_free(ctx,(void *)buffer);
								JS_ThrowTypeError(ctx,(const char *)"argv[c] does not match type char *");
								return JS_EXCEPTION;
							}
						}
						char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,a);
					}else{
						wchar_t * a;
						int64_t size_a;
						JSClassID a_class=JS_GetClassID(argv[c]);
						if(a_class==js_ArrayProxy_class_id){
							void * opaque_a=JS_GetOpaque(argv[c],js_ArrayProxy_class_id);
							ArrayProxy_class AP_a=((ArrayProxy_class *)opaque_a)[0];
							argv[c] =AP_a.values(ctx,AP_a.opaque,(int)0,(bool)false);
							memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[c]);
						}
						if(JS_IsArray(argv[c])==1){
							if(JS_GetLength(ctx,argv[c],&size_a)==-1){
								memoryClear(ctx,memoryHead);
								js_free(ctx,(void *)char_ptr);
								js_free(ctx,(void *)buffer);
								return JS_EXCEPTION;
							}
							a =(wchar_t *)js_malloc(ctx,size_a*sizeof(wchar_t));
							memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)a);
							int i0;
							for(i0=0;i0<size_a;i0++){
								JSValue js_a=JS_GetPropertyUint32(ctx,argv[c],(uint32_t)i0);
								uint32_t long_ai0;
								int err_ai0=JS_ToUint32(ctx,&long_ai0,js_a);
								if(err_ai0<0){
									JS_ThrowTypeError(ctx,(const char *)"js_a is not numeric");
									return JS_EXCEPTION;
								}
								a[i0] =((wchar_t)long_ai0);
								JS_FreeValue(ctx,js_a);
							}
						}else if(JS_IsArrayBuffer(argv[c])==1){
							a =(wchar_t *)JS_GetArrayBuffer(ctx,(size_t *)&size_a,argv[c]);
						}else{
							JSClassID classid_a=JS_GetClassID(argv[c]);
							if(classid_a==JS_CLASS_UINT32_ARRAY){
								size_t offset_a;
								JSValue da_a=JS_GetTypedArrayBuffer(ctx,argv[c],&offset_a,(size_t *)&size_a,NULL);
								a =(wchar_t *)JS_GetArrayBuffer(ctx,(size_t *)&size_a,da_a);
								a +=offset_a;
								size_a -=offset_a;
								memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_a);
							}else{
								memoryClear(ctx,memoryHead);
								js_free(ctx,(void *)char_ptr);
								js_free(ctx,(void *)buffer);
								JS_ThrowTypeError(ctx,(const char *)"argv[c] does not match type wchar_t *");
								return JS_EXCEPTION;
							}
						}
						char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,a);
					}
				}else if(har=='p'){
					char_ptr =asnprintf(ctx,char_ptr,&char_ptrlen,(const char *)subformat,n,w,p,(void *)&argv[c]);
				}else if(har=='n'){
					argv[c] =JS_NewInt32(ctx,(int32_t)((long)l));
				}
				subformat[subformatlen]=subformatlenh;
				c +=1;
				ilen =(int)strlen((const char *)char_ptr);
				int maxstrlen=(int)formatlen+l+ilen-lasth;
				if(bufferlen<maxstrlen){
					buffer =(char *)js_realloc(ctx,(void *)buffer,(size_t)maxstrlen);
					memset((void *)buffer+bufferlen,(int)0,maxstrlen-bufferlen);
					bufferlen =maxstrlen;
				}
				strncpy(buffer+l,(const char *)char_ptr,(size_t)ilen);
				l +=ilen;
				i =lasth;
			}
		}
		JSValue js_buffer;
		js_buffer =JS_NewString(ctx,(const char *)buffer);
		memoryClear(ctx,memoryHead);
		js_free(ctx,(void *)char_ptr);
		js_free(ctx,(void *)buffer);
		return js_buffer;
	}
	
	static JSValue js_TextSubtext(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_position;
		int err_position=JS_ToInt32(ctx,&long_position,argv[1]);
		if(err_position<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[0]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int position=((int)long_position);
		int32_t long_length;
		int err_length=JS_ToInt32(ctx,&long_length,argv[2]);
		if(err_length<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)text);
			}else if(JS_IsString(argv[0])==1){
				JS_FreeCString(ctx,(const char *)text);
			}else{
				JSClassID classid_text=JS_GetClassID(argv[0]);
				if(classid_text==JS_CLASS_INT8_ARRAY){
					js_free(ctx,(void *)&da_text);
				}
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int length=((int)long_length);
		char * returnVal=(char *)TextSubtext((const char *)text,position,length);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_TextReplace(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)text);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				JSValue da_text=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_text);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * replace;
		int64_t size_replace;
		if(JS_IsString(argv[1])==1){
			replace =(char *)JS_ToCStringLen(ctx,(size_t *)&size_replace,argv[1]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)replace);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			replace =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_replace,argv[1]);
		}else{
			JSClassID classid_replace=JS_GetClassID(argv[1]);
			if(classid_replace==JS_CLASS_INT8_ARRAY){
				size_t offset_replace;
				JSValue da_replace=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_replace,(size_t *)&size_replace,NULL);
				replace =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_replace,da_replace);
				replace +=offset_replace;
				size_replace -=offset_replace;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_replace);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * by;
		int64_t size_by;
		if(JS_IsString(argv[2])==1){
			by =(char *)JS_ToCStringLen(ctx,(size_t *)&size_by,argv[2]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)by);
		}else if(JS_IsArrayBuffer(argv[2])==1){
			by =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_by,argv[2]);
		}else{
			JSClassID classid_by=JS_GetClassID(argv[2]);
			if(classid_by==JS_CLASS_INT8_ARRAY){
				size_t offset_by;
				JSValue da_by=JS_GetTypedArrayBuffer(ctx,argv[2],&offset_by,(size_t *)&size_by,NULL);
				by =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_by,da_by);
				by +=offset_by;
				size_by -=offset_by;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_by);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=TextReplace((const char *)text,(const char *)replace,(const char *)by);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_TextInsert(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)text);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				JSValue da_text=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_text);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * insert;
		int64_t size_insert;
		if(JS_IsString(argv[1])==1){
			insert =(char *)JS_ToCStringLen(ctx,(size_t *)&size_insert,argv[1]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)insert);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			insert =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_insert,argv[1]);
		}else{
			JSClassID classid_insert=JS_GetClassID(argv[1]);
			if(classid_insert==JS_CLASS_INT8_ARRAY){
				size_t offset_insert;
				JSValue da_insert=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_insert,(size_t *)&size_insert,NULL);
				insert =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_insert,da_insert);
				insert +=offset_insert;
				size_insert -=offset_insert;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_insert);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_position;
		int err_position=JS_ToInt32(ctx,&long_position,argv[2]);
		if(err_position<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int position=((int)long_position);
		char * returnVal=TextInsert((const char *)text,(const char *)insert,position);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_TextJoin(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * * textList;
		int64_t size_textList;
		JSClassID textList_class=JS_GetClassID(argv[0]);
		if(textList_class==js_ArrayProxy_class_id){
			void * opaque_textList=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_textList=((ArrayProxy_class *)opaque_textList)[0];
			argv[0] =AP_textList.values(ctx,AP_textList.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[0]);
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_textList)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			textList =(char * *)js_malloc(ctx,size_textList*sizeof(char *));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)*textList);
			int i;
			for(i=0;i<size_textList;i++){
				JSValue js_textList=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				int64_t size_textListi;
				if(JS_IsString(js_textList)==1){
					textList[i] =(char *)JS_ToCStringLen(ctx,(size_t *)&size_textListi,js_textList);
					memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)textList[i]);
				}else if(JS_IsArrayBuffer(js_textList)==1){
					textList[i] =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_textListi,js_textList);
				}else{
					JSClassID classid_textListi=JS_GetClassID(js_textList);
					if(classid_textListi==JS_CLASS_INT8_ARRAY){
						size_t offset_textListi;
						JSValue da_textListi=JS_GetTypedArrayBuffer(ctx,js_textList,&offset_textListi,(size_t *)&size_textListi,NULL);
						textList[i] =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_textListi,da_textListi);
						textList[i] +=offset_textListi;
						size_textListi -=offset_textListi;
						memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_textListi);
					}else{
						JS_ThrowTypeError(ctx,(const char *)"js_textList does not match type char *");
						return JS_EXCEPTION;
					}
				}
				JS_FreeValue(ctx,js_textList);
			}
		}else{
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char * *");
			return JS_EXCEPTION;
		}
		int32_t long_count;
		int err_count=JS_ToInt32(ctx,&long_count,argv[1]);
		if(err_count<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int count=((int)long_count);
		char * delimiter;
		int64_t size_delimiter;
		if(JS_IsString(argv[2])==1){
			delimiter =(char *)JS_ToCStringLen(ctx,(size_t *)&size_delimiter,argv[2]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)delimiter);
		}else if(JS_IsArrayBuffer(argv[2])==1){
			delimiter =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_delimiter,argv[2]);
		}else{
			JSClassID classid_delimiter=JS_GetClassID(argv[2]);
			if(classid_delimiter==JS_CLASS_INT8_ARRAY){
				size_t offset_delimiter;
				JSValue da_delimiter=JS_GetTypedArrayBuffer(ctx,argv[2],&offset_delimiter,(size_t *)&size_delimiter,NULL);
				delimiter =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_delimiter,da_delimiter);
				delimiter +=offset_delimiter;
				size_delimiter -=offset_delimiter;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_delimiter);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=TextJoin(textList,count,(const char *)delimiter);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_TextSplit(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * js_delimiter=(char *)JS_ToCString(ctx,argv[1]);
		char delimiter=((char)js_delimiter[0]);
		JS_FreeCString(ctx,(const char *)js_delimiter);
		int * count;
		bool freesrc_count=(bool)false;
		int64_t size_count;
		JSClassID count_class=JS_GetClassID(argv[2]);
		if(count_class==js_ArrayProxy_class_id){
			void * opaque_count=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_count=((ArrayProxy_class *)opaque_count)[0];
			argv[2] =AP_count.values(ctx,AP_count.opaque,(int)0,(bool)false);
			freesrc_count =(bool)true;
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_count)==-1){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)text);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)text);
				}else{
					JSClassID classid_text=JS_GetClassID(argv[0]);
					if(classid_text==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_text);
					}
				}
				return JS_EXCEPTION;
			}
			count =(int *)js_malloc(ctx,size_count*sizeof(int));
			int i;
			for(i=0;i<size_count;i++){
				JSValue js_count=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				int32_t long_counti;
				int err_counti=JS_ToInt32(ctx,&long_counti,js_count);
				if(err_counti<0){
					JS_ThrowTypeError(ctx,(const char *)"js_count is not numeric");
					return JS_EXCEPTION;
				}
				count[i] =((int)long_counti);
				JS_FreeValue(ctx,js_count);
			}
		}else{
			int32_t long_js_count;
			int err_js_count=JS_ToInt32(ctx,&long_js_count,argv[2]);
			if(err_js_count<0){
				if(JS_IsArray(argv[0])==1){
					js_free(ctx,(void *)text);
				}else if(JS_IsString(argv[0])==1){
					JS_FreeCString(ctx,(const char *)text);
				}else{
					JSClassID classid_text=JS_GetClassID(argv[0]);
					if(classid_text==JS_CLASS_INT8_ARRAY){
						js_free(ctx,(void *)&da_text);
					}
				}
				JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
				return JS_EXCEPTION;
			}
			int js_count=((int)long_js_count);
			count =&js_count;
		}
		char * * returnVal=TextSplit((const char *)text,delimiter,count);
		if(JS_IsArray(argv[2])==1){
			JSValue js_argv2=JS_NewInt32(ctx,(int32_t)((long)count[0]));
			JS_DefinePropertyValueUint32(ctx,argv[2],(uint32_t)0,js_argv2,JS_PROP_C_W_E);
		}
		JSValue ret;
		ret =JS_NewArray(ctx);
		char * * sizeref_ret=returnVal;
		size_t size_ret=sizeof(sizeref_ret);
		size_t size1_ret=sizeof(char *);
		size_ret =size_ret/size1_ret;
		int i;
		for(i=0;i<size_ret;i++){
			JSValue js_ret;
			js_ret =JS_NewString(ctx,(const char *)returnVal[i]);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		if(JS_IsArray(argv[2])==1){
			js_free(ctx,(void *)count);
		}
		return ret;
	}
	
	static JSValue js_TextAppend(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)text);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				JSValue da_text=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_text);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * append;
		int64_t size_append;
		if(JS_IsString(argv[1])==1){
			append =(char *)JS_ToCStringLen(ctx,(size_t *)&size_append,argv[1]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)append);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			append =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_append,argv[1]);
		}else{
			JSClassID classid_append=JS_GetClassID(argv[1]);
			if(classid_append==JS_CLASS_INT8_ARRAY){
				size_t offset_append;
				JSValue da_append=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_append,(size_t *)&size_append,NULL);
				append =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_append,da_append);
				append +=offset_append;
				size_append -=offset_append;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_append);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int * position;
		int64_t size_position;
		JSClassID position_class=JS_GetClassID(argv[2]);
		if(position_class==js_ArrayProxy_class_id){
			void * opaque_position=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_position=((ArrayProxy_class *)opaque_position)[0];
			argv[2] =AP_position.values(ctx,AP_position.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[2]);
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_position)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			position =(int *)js_malloc(ctx,size_position*sizeof(int));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)position);
			int i;
			for(i=0;i<size_position;i++){
				JSValue js_position=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				int32_t long_positioni;
				int err_positioni=JS_ToInt32(ctx,&long_positioni,js_position);
				if(err_positioni<0){
					JS_ThrowTypeError(ctx,(const char *)"js_position is not numeric");
					return JS_EXCEPTION;
				}
				position[i] =((int)long_positioni);
				JS_FreeValue(ctx,js_position);
			}
		}else{
			int32_t long_js_position;
			int err_js_position=JS_ToInt32(ctx,&long_js_position,argv[2]);
			if(err_js_position<0){
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
				return JS_EXCEPTION;
			}
			int js_position=((int)long_js_position);
			position =&js_position;
		}
		TextAppend(text,(const char *)append,position);
		if(JS_IsArray(argv[2])==1){
			JSValue js_argv2=JS_NewInt32(ctx,(int32_t)((long)position[0]));
			JS_DefinePropertyValueUint32(ctx,argv[2],(uint32_t)0,js_argv2,JS_PROP_C_W_E);
		}
		memoryClear(ctx,memoryHead);
		return JS_UNDEFINED;
	}
	
	static JSValue js_TextFindIndex(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)text);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				JSValue da_text=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_text);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * find;
		int64_t size_find;
		if(JS_IsString(argv[1])==1){
			find =(char *)JS_ToCStringLen(ctx,(size_t *)&size_find,argv[1]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)find);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			find =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_find,argv[1]);
		}else{
			JSClassID classid_find=JS_GetClassID(argv[1]);
			if(classid_find==JS_CLASS_INT8_ARRAY){
				size_t offset_find;
				JSValue da_find=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_find,(size_t *)&size_find,NULL);
				find =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_find,da_find);
				find +=offset_find;
				size_find -=offset_find;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_find);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int returnVal=TextFindIndex((const char *)text,(const char *)find);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_TextToUpper(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=TextToUpper((const char *)text);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_TextToLower(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=TextToLower((const char *)text);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_TextToPascal(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=TextToPascal((const char *)text);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_TextToSnake(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=TextToSnake((const char *)text);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_TextToCamel(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		char * returnVal=TextToCamel((const char *)text);
		JSValue ret;
		ret =JS_NewString(ctx,(const char *)returnVal);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_TextToInteger(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int returnVal=TextToInteger((const char *)text);
		JSValue ret=JS_NewInt32(ctx,(int32_t)((long)returnVal));
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_TextToFloat(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * text;
		JSValue da_text;
		int64_t size_text;
		if(JS_IsString(argv[0])==1){
			text =(char *)JS_ToCStringLen(ctx,(size_t *)&size_text,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,argv[0]);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				size_t offset_text;
				da_text =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_text,(size_t *)&size_text,NULL);
				text =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_text,da_text);
				text +=offset_text;
				size_text -=offset_text;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		float returnVal=TextToFloat((const char *)text);
		JSValue ret=JS_NewFloat64(ctx,((double)returnVal));
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)text);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)text);
		}else{
			JSClassID classid_text=JS_GetClassID(argv[0]);
			if(classid_text==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_text);
			}
		}
		return ret;
	}
	
	static JSValue js_DrawLine3D(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_startPos=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_startPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 startPos=*ptr_startPos;
		Vector3 * ptr_endPos=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_endPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 endPos=*ptr_endPos;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawLine3D(startPos,endPos,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawPoint3D(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawPoint3D(position,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCircle3D(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_center=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 center=*ptr_center;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[1]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		Vector3 * ptr_rotationAxis=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_rotationAxis==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 rotationAxis=*ptr_rotationAxis;
		double double_rotationAngle;
		int err_rotationAngle=JS_ToFloat64(ctx,&double_rotationAngle,argv[3]);
		if(err_rotationAngle<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float rotationAngle=((float)double_rotationAngle);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCircle3D(center,radius,rotationAxis,rotationAngle,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTriangle3D(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_v1=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_v1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 v1=*ptr_v1;
		Vector3 * ptr_v2=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_v2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 v2=*ptr_v2;
		Vector3 * ptr_v3=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_v3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 v3=*ptr_v3;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawTriangle3D(v1,v2,v3,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawTriangleStrip3D(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * points;
		bool freesrc_points=(bool)false;
		int64_t size_points;
		JSClassID points_class=JS_GetClassID(argv[0]);
		if(points_class==js_ArrayProxy_class_id){
			void * opaque_points=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_points=((ArrayProxy_class *)opaque_points)[0];
			argv[0] =AP_points.values(ctx,AP_points.opaque,(int)0,(bool)false);
			freesrc_points =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_points)==-1){
				return JS_EXCEPTION;
			}
			points =(Vector3 *)js_malloc(ctx,size_points*sizeof(Vector3));
			int i;
			for(i=0;i<size_points;i++){
				JSValue js_points=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				Vector3 * ptr_pointsi=(Vector3 *)JS_GetOpaque(js_points,js_Vector3_class_id);
				if(ptr_pointsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_points does not allow null");
					return JS_EXCEPTION;
				}
				points[i] =*ptr_pointsi;
				JS_FreeValue(ctx,js_points);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			points =(Vector3 *)JS_GetArrayBuffer(ctx,(size_t *)&size_points,argv[0]);
		}else{
			if(freesrc_points){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Vector3 *");
			return JS_EXCEPTION;
		}
		int32_t long_pointCount;
		int err_pointCount=JS_ToInt32(ctx,&long_pointCount,argv[1]);
		if(err_pointCount<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int pointCount=((int)long_pointCount);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)points);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawTriangleStrip3D((const Vector3 *)points,pointCount,color);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)points);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCube(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		double double_width;
		int err_width=JS_ToFloat64(ctx,&double_width,argv[1]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float width=((float)double_width);
		double double_height;
		int err_height=JS_ToFloat64(ctx,&double_height,argv[2]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float height=((float)double_height);
		double double_length;
		int err_length=JS_ToFloat64(ctx,&double_length,argv[3]);
		if(err_length<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float length=((float)double_length);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCube(position,width,height,length,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCubeV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		Vector3 * ptr_size=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_size==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 size=*ptr_size;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCubeV(position,size,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCubeWires(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		double double_width;
		int err_width=JS_ToFloat64(ctx,&double_width,argv[1]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float width=((float)double_width);
		double double_height;
		int err_height=JS_ToFloat64(ctx,&double_height,argv[2]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float height=((float)double_height);
		double double_length;
		int err_length=JS_ToFloat64(ctx,&double_length,argv[3]);
		if(err_length<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float length=((float)double_length);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCubeWires(position,width,height,length,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCubeWiresV(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		Vector3 * ptr_size=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_size==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 size=*ptr_size;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCubeWiresV(position,size,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSphere(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_centerPos=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_centerPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 centerPos=*ptr_centerPos;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[1]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSphere(centerPos,radius,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSphereEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_centerPos=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_centerPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 centerPos=*ptr_centerPos;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[1]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		int32_t long_rings;
		int err_rings=JS_ToInt32(ctx,&long_rings,argv[2]);
		if(err_rings<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int rings=((int)long_rings);
		int32_t long_slices;
		int err_slices=JS_ToInt32(ctx,&long_slices,argv[3]);
		if(err_slices<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int slices=((int)long_slices);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSphereEx(centerPos,radius,rings,slices,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawSphereWires(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_centerPos=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_centerPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 centerPos=*ptr_centerPos;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[1]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		int32_t long_rings;
		int err_rings=JS_ToInt32(ctx,&long_rings,argv[2]);
		if(err_rings<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int rings=((int)long_rings);
		int32_t long_slices;
		int err_slices=JS_ToInt32(ctx,&long_slices,argv[3]);
		if(err_slices<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int slices=((int)long_slices);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawSphereWires(centerPos,radius,rings,slices,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCylinder(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		double double_radiusTop;
		int err_radiusTop=JS_ToFloat64(ctx,&double_radiusTop,argv[1]);
		if(err_radiusTop<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radiusTop=((float)double_radiusTop);
		double double_radiusBottom;
		int err_radiusBottom=JS_ToFloat64(ctx,&double_radiusBottom,argv[2]);
		if(err_radiusBottom<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radiusBottom=((float)double_radiusBottom);
		double double_height;
		int err_height=JS_ToFloat64(ctx,&double_height,argv[3]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float height=((float)double_height);
		int32_t long_slices;
		int err_slices=JS_ToInt32(ctx,&long_slices,argv[4]);
		if(err_slices<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int slices=((int)long_slices);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCylinder(position,radiusTop,radiusBottom,height,slices,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCylinderEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_startPos=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_startPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 startPos=*ptr_startPos;
		Vector3 * ptr_endPos=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_endPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 endPos=*ptr_endPos;
		double double_startRadius;
		int err_startRadius=JS_ToFloat64(ctx,&double_startRadius,argv[2]);
		if(err_startRadius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float startRadius=((float)double_startRadius);
		double double_endRadius;
		int err_endRadius=JS_ToFloat64(ctx,&double_endRadius,argv[3]);
		if(err_endRadius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float endRadius=((float)double_endRadius);
		int32_t long_sides;
		int err_sides=JS_ToInt32(ctx,&long_sides,argv[4]);
		if(err_sides<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int sides=((int)long_sides);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCylinderEx(startPos,endPos,startRadius,endRadius,sides,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCylinderWires(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		double double_radiusTop;
		int err_radiusTop=JS_ToFloat64(ctx,&double_radiusTop,argv[1]);
		if(err_radiusTop<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radiusTop=((float)double_radiusTop);
		double double_radiusBottom;
		int err_radiusBottom=JS_ToFloat64(ctx,&double_radiusBottom,argv[2]);
		if(err_radiusBottom<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radiusBottom=((float)double_radiusBottom);
		double double_height;
		int err_height=JS_ToFloat64(ctx,&double_height,argv[3]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float height=((float)double_height);
		int32_t long_slices;
		int err_slices=JS_ToInt32(ctx,&long_slices,argv[4]);
		if(err_slices<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int slices=((int)long_slices);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCylinderWires(position,radiusTop,radiusBottom,height,slices,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCylinderWiresEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_startPos=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_startPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 startPos=*ptr_startPos;
		Vector3 * ptr_endPos=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_endPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 endPos=*ptr_endPos;
		double double_startRadius;
		int err_startRadius=JS_ToFloat64(ctx,&double_startRadius,argv[2]);
		if(err_startRadius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float startRadius=((float)double_startRadius);
		double double_endRadius;
		int err_endRadius=JS_ToFloat64(ctx,&double_endRadius,argv[3]);
		if(err_endRadius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float endRadius=((float)double_endRadius);
		int32_t long_sides;
		int err_sides=JS_ToInt32(ctx,&long_sides,argv[4]);
		if(err_sides<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int sides=((int)long_sides);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCylinderWiresEx(startPos,endPos,startRadius,endRadius,sides,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCapsule(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_startPos=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_startPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 startPos=*ptr_startPos;
		Vector3 * ptr_endPos=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_endPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 endPos=*ptr_endPos;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		int32_t long_slices;
		int err_slices=JS_ToInt32(ctx,&long_slices,argv[3]);
		if(err_slices<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int slices=((int)long_slices);
		int32_t long_rings;
		int err_rings=JS_ToInt32(ctx,&long_rings,argv[4]);
		if(err_rings<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int rings=((int)long_rings);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCapsule(startPos,endPos,radius,slices,rings,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawCapsuleWires(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_startPos=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_startPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 startPos=*ptr_startPos;
		Vector3 * ptr_endPos=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_endPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 endPos=*ptr_endPos;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		int32_t long_slices;
		int err_slices=JS_ToInt32(ctx,&long_slices,argv[3]);
		if(err_slices<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int slices=((int)long_slices);
		int32_t long_rings;
		int err_rings=JS_ToInt32(ctx,&long_rings,argv[4]);
		if(err_rings<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int rings=((int)long_rings);
		Color * ptr_color=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawCapsuleWires(startPos,endPos,radius,slices,rings,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawPlane(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_centerPos=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_centerPos==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 centerPos=*ptr_centerPos;
		Vector2 * ptr_size=(Vector2 *)JS_GetOpaque(argv[1],js_Vector2_class_id);
		if(ptr_size==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 size=*ptr_size;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[2],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawPlane(centerPos,size,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawRay(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Ray * ptr_ray=(Ray *)JS_GetOpaque(argv[0],js_Ray_class_id);
		if(ptr_ray==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Ray ray=*ptr_ray;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawRay(ray,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawGrid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_slices;
		int err_slices=JS_ToInt32(ctx,&long_slices,argv[0]);
		if(err_slices<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int slices=((int)long_slices);
		double double_spacing;
		int err_spacing=JS_ToFloat64(ctx,&double_spacing,argv[1]);
		if(err_spacing<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float spacing=((float)double_spacing);
		DrawGrid(slices,spacing);
		return JS_UNDEFINED;
	}
	
	static JSValue js_LoadModel(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Model returnVal=LoadModel((const char *)fileName);
		Model * ptr_ret=(Model *)js_malloc(ctx,sizeof(Model));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Model_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_LoadModelFromMesh(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Mesh * ptr_mesh=(Mesh *)JS_GetOpaque(argv[0],js_Mesh_class_id);
		if(ptr_mesh==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Mesh mesh=*ptr_mesh;
		Model returnVal=LoadModelFromMesh(mesh);
		Model * ptr_ret=(Model *)js_malloc(ctx,sizeof(Model));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Model_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_IsModelValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * ptr_model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(ptr_model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Model model=*ptr_model;
		bool returnVal=IsModelValid(model);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_UnloadModel(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * ptr_model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(ptr_model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Model model=*ptr_model;
		UnloadModel(model);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetModelBoundingBox(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * ptr_model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(ptr_model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Model model=*ptr_model;
		BoundingBox returnVal=GetModelBoundingBox(model);
		BoundingBox * ptr_ret=(BoundingBox *)js_malloc(ctx,sizeof(BoundingBox));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_BoundingBox_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_DrawModel(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * ptr_model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(ptr_model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Model model=*ptr_model;
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		double double_scale;
		int err_scale=JS_ToFloat64(ctx,&double_scale,argv[2]);
		if(err_scale<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float scale=((float)double_scale);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawModel(model,position,scale,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawModelEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * ptr_model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(ptr_model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Model model=*ptr_model;
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		Vector3 * ptr_rotationAxis=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_rotationAxis==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 rotationAxis=*ptr_rotationAxis;
		double double_rotationAngle;
		int err_rotationAngle=JS_ToFloat64(ctx,&double_rotationAngle,argv[3]);
		if(err_rotationAngle<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float rotationAngle=((float)double_rotationAngle);
		Vector3 * ptr_scale=(Vector3 *)JS_GetOpaque(argv[4],js_Vector3_class_id);
		if(ptr_scale==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 scale=*ptr_scale;
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawModelEx(model,position,rotationAxis,rotationAngle,scale,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawModelWires(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * ptr_model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(ptr_model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Model model=*ptr_model;
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		double double_scale;
		int err_scale=JS_ToFloat64(ctx,&double_scale,argv[2]);
		if(err_scale<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float scale=((float)double_scale);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawModelWires(model,position,scale,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawModelWiresEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * ptr_model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(ptr_model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Model model=*ptr_model;
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		Vector3 * ptr_rotationAxis=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_rotationAxis==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 rotationAxis=*ptr_rotationAxis;
		double double_rotationAngle;
		int err_rotationAngle=JS_ToFloat64(ctx,&double_rotationAngle,argv[3]);
		if(err_rotationAngle<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float rotationAngle=((float)double_rotationAngle);
		Vector3 * ptr_scale=(Vector3 *)JS_GetOpaque(argv[4],js_Vector3_class_id);
		if(ptr_scale==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 scale=*ptr_scale;
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawModelWiresEx(model,position,rotationAxis,rotationAngle,scale,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawModelPoints(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * ptr_model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(ptr_model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Model model=*ptr_model;
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		double double_scale;
		int err_scale=JS_ToFloat64(ctx,&double_scale,argv[2]);
		if(err_scale<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float scale=((float)double_scale);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[3],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawModelPoints(model,position,scale,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawModelPointsEx(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * ptr_model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(ptr_model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Model model=*ptr_model;
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		Vector3 * ptr_rotationAxis=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_rotationAxis==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 rotationAxis=*ptr_rotationAxis;
		double double_rotationAngle;
		int err_rotationAngle=JS_ToFloat64(ctx,&double_rotationAngle,argv[3]);
		if(err_rotationAngle<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float rotationAngle=((float)double_rotationAngle);
		Vector3 * ptr_scale=(Vector3 *)JS_GetOpaque(argv[4],js_Vector3_class_id);
		if(ptr_scale==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 scale=*ptr_scale;
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawModelPointsEx(model,position,rotationAxis,rotationAngle,scale,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawBoundingBox(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		BoundingBox * ptr_box=(BoundingBox *)JS_GetOpaque(argv[0],js_BoundingBox_class_id);
		if(ptr_box==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		BoundingBox box=*ptr_box;
		Color * ptr_color=(Color *)JS_GetOpaque(argv[1],js_Color_class_id);
		if(ptr_color==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Color color=*ptr_color;
		DrawBoundingBox(box,color);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawBillboard(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Camera * ptr_camera=(Camera *)JS_GetOpaque(argv[0],js_Camera3D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Camera camera=*ptr_camera;
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[1],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		double double_scale;
		int err_scale=JS_ToFloat64(ctx,&double_scale,argv[3]);
		if(err_scale<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float scale=((float)double_scale);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[4],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawBillboard(camera,texture,position,scale,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawBillboardRec(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Camera * ptr_camera=(Camera *)JS_GetOpaque(argv[0],js_Camera3D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Camera camera=*ptr_camera;
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[1],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		Rectangle * ptr_source=(Rectangle *)JS_GetOpaque(argv[2],js_Rectangle_class_id);
		if(ptr_source==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle source=*ptr_source;
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[3],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		Vector2 * ptr_size=(Vector2 *)JS_GetOpaque(argv[4],js_Vector2_class_id);
		if(ptr_size==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 size=*ptr_size;
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[5],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawBillboardRec(camera,texture,source,position,size,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawBillboardPro(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Camera * ptr_camera=(Camera *)JS_GetOpaque(argv[0],js_Camera3D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Camera camera=*ptr_camera;
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[1],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		Rectangle * ptr_source=(Rectangle *)JS_GetOpaque(argv[2],js_Rectangle_class_id);
		if(ptr_source==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Rectangle source=*ptr_source;
		Vector3 * ptr_position=(Vector3 *)JS_GetOpaque(argv[3],js_Vector3_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 position=*ptr_position;
		Vector3 * ptr_up=(Vector3 *)JS_GetOpaque(argv[4],js_Vector3_class_id);
		if(ptr_up==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 up=*ptr_up;
		Vector2 * ptr_size=(Vector2 *)JS_GetOpaque(argv[5],js_Vector2_class_id);
		if(ptr_size==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[5] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 size=*ptr_size;
		Vector2 * ptr_origin=(Vector2 *)JS_GetOpaque(argv[6],js_Vector2_class_id);
		if(ptr_origin==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[6] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 origin=*ptr_origin;
		double double_rotation;
		int err_rotation=JS_ToFloat64(ctx,&double_rotation,argv[7]);
		if(err_rotation<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[7] is not numeric");
			return JS_EXCEPTION;
		}
		float rotation=((float)double_rotation);
		Color * ptr_tint=(Color *)JS_GetOpaque(argv[8],js_Color_class_id);
		if(ptr_tint==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[8] does not allow null");
			return JS_EXCEPTION;
		}
		Color tint=*ptr_tint;
		DrawBillboardPro(camera,texture,source,position,up,size,origin,rotation,tint);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UploadMesh(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Mesh * mesh=(Mesh *)JS_GetOpaque(argv[0],js_Mesh_class_id);
		if(mesh==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Mesh");
			return JS_EXCEPTION;
		}
		int js_dynamic=JS_ToBool(ctx,argv[1]);
		if(js_dynamic<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not a bool");
			return JS_EXCEPTION;
		}
		bool dynamic=(bool)js_dynamic;
		UploadMesh(mesh,dynamic);
		JS_SetOpaque(argv[0],(void *)mesh);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UpdateMeshBuffer(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Mesh * ptr_mesh=(Mesh *)JS_GetOpaque(argv[0],js_Mesh_class_id);
		if(ptr_mesh==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Mesh mesh=*ptr_mesh;
		int32_t long_index;
		int err_index=JS_ToInt32(ctx,&long_index,argv[1]);
		if(err_index<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int index=((int)long_index);
		void * data;
		int64_t size_data;
		if(JS_IsArrayBuffer(argv[2])==1){
			data =(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[2]);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type void *");
			return JS_EXCEPTION;
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[3]);
		if(err_dataSize<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		int32_t long_offset;
		int err_offset=JS_ToInt32(ctx,&long_offset,argv[4]);
		if(err_offset<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] is not numeric");
			return JS_EXCEPTION;
		}
		int offset=((int)long_offset);
		UpdateMeshBuffer(mesh,index,(const void *)data,dataSize,offset);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UnloadMesh(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Mesh * ptr_mesh=(Mesh *)JS_GetOpaque(argv[0],js_Mesh_class_id);
		if(ptr_mesh==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Mesh mesh=*ptr_mesh;
		UnloadMesh(mesh);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawMesh(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Mesh * ptr_mesh=(Mesh *)JS_GetOpaque(argv[0],js_Mesh_class_id);
		if(ptr_mesh==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Mesh mesh=*ptr_mesh;
		Material * ptr_material=(Material *)JS_GetOpaque(argv[1],js_Material_class_id);
		if(ptr_material==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Material material=*ptr_material;
		Matrix * ptr_transform=(Matrix *)JS_GetOpaque(argv[2],js_Matrix_class_id);
		if(ptr_transform==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Matrix transform=*ptr_transform;
		DrawMesh(mesh,material,transform);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DrawMeshInstanced(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Mesh * ptr_mesh=(Mesh *)JS_GetOpaque(argv[0],js_Mesh_class_id);
		if(ptr_mesh==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Mesh mesh=*ptr_mesh;
		Material * ptr_material=(Material *)JS_GetOpaque(argv[1],js_Material_class_id);
		if(ptr_material==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Material material=*ptr_material;
		Matrix * transforms;
		bool freesrc_transforms=(bool)false;
		int64_t size_transforms;
		JSClassID transforms_class=JS_GetClassID(argv[2]);
		if(transforms_class==js_ArrayProxy_class_id){
			void * opaque_transforms=JS_GetOpaque(argv[2],js_ArrayProxy_class_id);
			ArrayProxy_class AP_transforms=((ArrayProxy_class *)opaque_transforms)[0];
			argv[2] =AP_transforms.values(ctx,AP_transforms.opaque,(int)0,(bool)false);
			freesrc_transforms =(bool)true;
		}
		if(JS_IsArray(argv[2])==1){
			if(JS_GetLength(ctx,argv[2],&size_transforms)==-1){
				return JS_EXCEPTION;
			}
			transforms =(Matrix *)js_malloc(ctx,size_transforms*sizeof(Matrix));
			int i;
			for(i=0;i<size_transforms;i++){
				JSValue js_transforms=JS_GetPropertyUint32(ctx,argv[2],(uint32_t)i);
				Matrix * ptr_transformsi=(Matrix *)JS_GetOpaque(js_transforms,js_Matrix_class_id);
				if(ptr_transformsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_transforms does not allow null");
					return JS_EXCEPTION;
				}
				transforms[i] =*ptr_transformsi;
				JS_FreeValue(ctx,js_transforms);
			}
		}else if(JS_IsArrayBuffer(argv[2])==1){
			transforms =(Matrix *)JS_GetArrayBuffer(ctx,(size_t *)&size_transforms,argv[2]);
		}else{
			if(freesrc_transforms){
				JS_FreeValue(ctx,argv[2]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not match type Matrix *");
			return JS_EXCEPTION;
		}
		int32_t long_instances;
		int err_instances=JS_ToInt32(ctx,&long_instances,argv[3]);
		if(err_instances<0){
			if(JS_IsArray(argv[2])==1){
				js_free(ctx,(void *)transforms);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int instances=((int)long_instances);
		DrawMeshInstanced(mesh,material,(const Matrix *)transforms,instances);
		if(JS_IsArray(argv[2])==1){
			js_free(ctx,(void *)transforms);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetMeshBoundingBox(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Mesh * ptr_mesh=(Mesh *)JS_GetOpaque(argv[0],js_Mesh_class_id);
		if(ptr_mesh==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Mesh mesh=*ptr_mesh;
		BoundingBox returnVal=GetMeshBoundingBox(mesh);
		BoundingBox * ptr_ret=(BoundingBox *)js_malloc(ctx,sizeof(BoundingBox));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_BoundingBox_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenMeshTangents(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Mesh * mesh=(Mesh *)JS_GetOpaque(argv[0],js_Mesh_class_id);
		if(mesh==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Mesh");
			return JS_EXCEPTION;
		}
		GenMeshTangents(mesh);
		JS_SetOpaque(argv[0],(void *)mesh);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ExportMesh(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Mesh * ptr_mesh=(Mesh *)JS_GetOpaque(argv[0],js_Mesh_class_id);
		if(ptr_mesh==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Mesh mesh=*ptr_mesh;
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[1])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[1]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=ExportMesh(mesh,(const char *)fileName);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_ExportMeshAsCode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Mesh * ptr_mesh=(Mesh *)JS_GetOpaque(argv[0],js_Mesh_class_id);
		if(ptr_mesh==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Mesh mesh=*ptr_mesh;
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[1])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[1]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=ExportMeshAsCode(mesh,(const char *)fileName);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_GenMeshPoly(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_sides;
		int err_sides=JS_ToInt32(ctx,&long_sides,argv[0]);
		if(err_sides<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int sides=((int)long_sides);
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[1]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		Mesh returnVal=GenMeshPoly(sides,radius);
		Mesh * ptr_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenMeshPlane(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double double_width;
		int err_width=JS_ToFloat64(ctx,&double_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float width=((float)double_width);
		double double_length;
		int err_length=JS_ToFloat64(ctx,&double_length,argv[1]);
		if(err_length<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float length=((float)double_length);
		int32_t long_resX;
		int err_resX=JS_ToInt32(ctx,&long_resX,argv[2]);
		if(err_resX<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int resX=((int)long_resX);
		int32_t long_resZ;
		int err_resZ=JS_ToInt32(ctx,&long_resZ,argv[3]);
		if(err_resZ<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int resZ=((int)long_resZ);
		Mesh returnVal=GenMeshPlane(width,length,resX,resZ);
		Mesh * ptr_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenMeshCube(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double double_width;
		int err_width=JS_ToFloat64(ctx,&double_width,argv[0]);
		if(err_width<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float width=((float)double_width);
		double double_height;
		int err_height=JS_ToFloat64(ctx,&double_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float height=((float)double_height);
		double double_length;
		int err_length=JS_ToFloat64(ctx,&double_length,argv[2]);
		if(err_length<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float length=((float)double_length);
		Mesh returnVal=GenMeshCube(width,height,length);
		Mesh * ptr_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenMeshSphere(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[0]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		int32_t long_rings;
		int err_rings=JS_ToInt32(ctx,&long_rings,argv[1]);
		if(err_rings<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int rings=((int)long_rings);
		int32_t long_slices;
		int err_slices=JS_ToInt32(ctx,&long_slices,argv[2]);
		if(err_slices<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int slices=((int)long_slices);
		Mesh returnVal=GenMeshSphere(radius,rings,slices);
		Mesh * ptr_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenMeshHemiSphere(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[0]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		int32_t long_rings;
		int err_rings=JS_ToInt32(ctx,&long_rings,argv[1]);
		if(err_rings<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int rings=((int)long_rings);
		int32_t long_slices;
		int err_slices=JS_ToInt32(ctx,&long_slices,argv[2]);
		if(err_slices<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int slices=((int)long_slices);
		Mesh returnVal=GenMeshHemiSphere(radius,rings,slices);
		Mesh * ptr_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenMeshCylinder(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[0]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		double double_height;
		int err_height=JS_ToFloat64(ctx,&double_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float height=((float)double_height);
		int32_t long_slices;
		int err_slices=JS_ToInt32(ctx,&long_slices,argv[2]);
		if(err_slices<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int slices=((int)long_slices);
		Mesh returnVal=GenMeshCylinder(radius,height,slices);
		Mesh * ptr_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenMeshCone(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[0]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		double double_height;
		int err_height=JS_ToFloat64(ctx,&double_height,argv[1]);
		if(err_height<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float height=((float)double_height);
		int32_t long_slices;
		int err_slices=JS_ToInt32(ctx,&long_slices,argv[2]);
		if(err_slices<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int slices=((int)long_slices);
		Mesh returnVal=GenMeshCone(radius,height,slices);
		Mesh * ptr_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenMeshTorus(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[0]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		double double_size;
		int err_size=JS_ToFloat64(ctx,&double_size,argv[1]);
		if(err_size<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float size=((float)double_size);
		int32_t long_radSeg;
		int err_radSeg=JS_ToInt32(ctx,&long_radSeg,argv[2]);
		if(err_radSeg<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int radSeg=((int)long_radSeg);
		int32_t long_sides;
		int err_sides=JS_ToInt32(ctx,&long_sides,argv[3]);
		if(err_sides<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int sides=((int)long_sides);
		Mesh returnVal=GenMeshTorus(radius,size,radSeg,sides);
		Mesh * ptr_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenMeshKnot(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[0]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		double double_size;
		int err_size=JS_ToFloat64(ctx,&double_size,argv[1]);
		if(err_size<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float size=((float)double_size);
		int32_t long_radSeg;
		int err_radSeg=JS_ToInt32(ctx,&long_radSeg,argv[2]);
		if(err_radSeg<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int radSeg=((int)long_radSeg);
		int32_t long_sides;
		int err_sides=JS_ToInt32(ctx,&long_sides,argv[3]);
		if(err_sides<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int sides=((int)long_sides);
		Mesh returnVal=GenMeshKnot(radius,size,radSeg,sides);
		Mesh * ptr_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenMeshHeightmap(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_heightmap=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_heightmap==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image heightmap=*ptr_heightmap;
		Vector3 * ptr_size=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_size==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 size=*ptr_size;
		Mesh returnVal=GenMeshHeightmap(heightmap,size);
		Mesh * ptr_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GenMeshCubicmap(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Image * ptr_cubicmap=(Image *)JS_GetOpaque(argv[0],js_Image_class_id);
		if(ptr_cubicmap==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Image cubicmap=*ptr_cubicmap;
		Vector3 * ptr_cubeSize=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_cubeSize==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 cubeSize=*ptr_cubeSize;
		Mesh returnVal=GenMeshCubicmap(cubicmap,cubeSize);
		Mesh * ptr_ret=(Mesh *)js_malloc(ctx,sizeof(Mesh));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Mesh_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_LoadMaterials(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fileName);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				JSValue da_fileName=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileName);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int * materialCount;
		int64_t size_materialCount;
		JSClassID materialCount_class=JS_GetClassID(argv[1]);
		if(materialCount_class==js_ArrayProxy_class_id){
			void * opaque_materialCount=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_materialCount=((ArrayProxy_class *)opaque_materialCount)[0];
			argv[1] =AP_materialCount.values(ctx,AP_materialCount.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[1]);
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_materialCount)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			materialCount =(int *)js_malloc(ctx,size_materialCount*sizeof(int));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)materialCount);
			int i;
			for(i=0;i<size_materialCount;i++){
				JSValue js_materialCount=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_materialCounti;
				int err_materialCounti=JS_ToInt32(ctx,&long_materialCounti,js_materialCount);
				if(err_materialCounti<0){
					JS_ThrowTypeError(ctx,(const char *)"js_materialCount is not numeric");
					return JS_EXCEPTION;
				}
				materialCount[i] =((int)long_materialCounti);
				JS_FreeValue(ctx,js_materialCount);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			materialCount =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_materialCount,argv[1]);
		}else{
			JSClassID classid_materialCount=JS_GetClassID(argv[1]);
			if(classid_materialCount==JS_CLASS_INT16_ARRAY){
				size_t offset_materialCount;
				JSValue da_materialCount=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_materialCount,(size_t *)&size_materialCount,NULL);
				materialCount =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_materialCount,da_materialCount);
				materialCount +=offset_materialCount;
				size_materialCount -=offset_materialCount;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_materialCount);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		Material * returnVal=LoadMaterials((const char *)fileName,materialCount);
		JSValue ret;
		ret =JS_NewArray(ctx);
		Material * sizeref_ret=returnVal;
		size_t size_ret=sizeof(sizeref_ret);
		size_t size1_ret=sizeof(Material);
		size_ret =size_ret/size1_ret;
		int i;
		for(i=0;i<size_ret;i++){
			Material * ptr_js_ret=(Material *)js_malloc(ctx,sizeof(Material));
			ptr_js_ret[0]=returnVal[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_Material_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_LoadMaterialDefault(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Material returnVal=LoadMaterialDefault();
		Material * ptr_ret=(Material *)js_malloc(ctx,sizeof(Material));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Material_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_IsMaterialValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Material * ptr_material=(Material *)JS_GetOpaque(argv[0],js_Material_class_id);
		if(ptr_material==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Material material=*ptr_material;
		bool returnVal=IsMaterialValid(material);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_UnloadMaterial(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Material * ptr_material=(Material *)JS_GetOpaque(argv[0],js_Material_class_id);
		if(ptr_material==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Material material=*ptr_material;
		UnloadMaterial(material);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetMaterialTexture(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Material * material=(Material *)JS_GetOpaque(argv[0],js_Material_class_id);
		if(material==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Material");
			return JS_EXCEPTION;
		}
		int32_t long_mapType;
		int err_mapType=JS_ToInt32(ctx,&long_mapType,argv[1]);
		if(err_mapType<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int mapType=((int)long_mapType);
		Texture2D * ptr_texture=(Texture2D *)JS_GetOpaque(argv[2],js_Texture_class_id);
		if(ptr_texture==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Texture2D texture=*ptr_texture;
		SetMaterialTexture(material,mapType,texture);
		JS_SetOpaque(argv[0],(void *)material);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetModelMeshMaterial(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Model");
			return JS_EXCEPTION;
		}
		int32_t long_meshId;
		int err_meshId=JS_ToInt32(ctx,&long_meshId,argv[1]);
		if(err_meshId<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int meshId=((int)long_meshId);
		int32_t long_materialId;
		int err_materialId=JS_ToInt32(ctx,&long_materialId,argv[2]);
		if(err_materialId<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int materialId=((int)long_materialId);
		SetModelMeshMaterial(model,meshId,materialId);
		JS_SetOpaque(argv[0],(void *)model);
		return JS_UNDEFINED;
	}
	
	static JSValue js_LoadModelAnimations(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fileName);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				JSValue da_fileName=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileName);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		int * animCount;
		int64_t size_animCount;
		JSClassID animCount_class=JS_GetClassID(argv[1]);
		if(animCount_class==js_ArrayProxy_class_id){
			void * opaque_animCount=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_animCount=((ArrayProxy_class *)opaque_animCount)[0];
			argv[1] =AP_animCount.values(ctx,AP_animCount.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[1]);
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_animCount)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			animCount =(int *)js_malloc(ctx,size_animCount*sizeof(int));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)animCount);
			int i;
			for(i=0;i<size_animCount;i++){
				JSValue js_animCount=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				int32_t long_animCounti;
				int err_animCounti=JS_ToInt32(ctx,&long_animCounti,js_animCount);
				if(err_animCounti<0){
					JS_ThrowTypeError(ctx,(const char *)"js_animCount is not numeric");
					return JS_EXCEPTION;
				}
				animCount[i] =((int)long_animCounti);
				JS_FreeValue(ctx,js_animCount);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			animCount =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_animCount,argv[1]);
		}else{
			JSClassID classid_animCount=JS_GetClassID(argv[1]);
			if(classid_animCount==JS_CLASS_INT16_ARRAY){
				size_t offset_animCount;
				JSValue da_animCount=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_animCount,(size_t *)&size_animCount,NULL);
				animCount =(int *)JS_GetArrayBuffer(ctx,(size_t *)&size_animCount,da_animCount);
				animCount +=offset_animCount;
				size_animCount -=offset_animCount;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_animCount);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type int *");
				return JS_EXCEPTION;
			}
		}
		ModelAnimation * returnVal=LoadModelAnimations((const char *)fileName,animCount);
		JSValue ret;
		ret =JS_NewArray(ctx);
		ModelAnimation * sizeref_ret=returnVal;
		size_t size_ret=sizeof(sizeref_ret);
		size_t size1_ret=sizeof(ModelAnimation);
		size_ret =size_ret/size1_ret;
		int i;
		for(i=0;i<size_ret;i++){
			ModelAnimation * ptr_js_ret=(ModelAnimation *)js_malloc(ctx,sizeof(ModelAnimation));
			ptr_js_ret[0]=returnVal[i];
			JSValue js_ret=JS_NewObjectClass(ctx,(int)js_ModelAnimation_class_id);
			JS_SetOpaque(js_ret,(void *)ptr_js_ret);
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_UpdateModelAnimation(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * ptr_model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(ptr_model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Model model=*ptr_model;
		ModelAnimation * ptr_anim=(ModelAnimation *)JS_GetOpaque(argv[1],js_ModelAnimation_class_id);
		if(ptr_anim==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		ModelAnimation anim=*ptr_anim;
		int32_t long_frame;
		int err_frame=JS_ToInt32(ctx,&long_frame,argv[2]);
		if(err_frame<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int frame=((int)long_frame);
		UpdateModelAnimation(model,anim,frame);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UpdateModelAnimationBones(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * ptr_model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(ptr_model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Model model=*ptr_model;
		ModelAnimation * ptr_anim=(ModelAnimation *)JS_GetOpaque(argv[1],js_ModelAnimation_class_id);
		if(ptr_anim==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		ModelAnimation anim=*ptr_anim;
		int32_t long_frame;
		int err_frame=JS_ToInt32(ctx,&long_frame,argv[2]);
		if(err_frame<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int frame=((int)long_frame);
		UpdateModelAnimationBones(model,anim,frame);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UnloadModelAnimation(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		ModelAnimation * ptr_anim=(ModelAnimation *)JS_GetOpaque(argv[0],js_ModelAnimation_class_id);
		if(ptr_anim==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		ModelAnimation anim=*ptr_anim;
		UnloadModelAnimation(anim);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UnloadModelAnimations(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		ModelAnimation * animations;
		bool freesrc_animations=(bool)false;
		int64_t size_animations;
		JSClassID animations_class=JS_GetClassID(argv[0]);
		if(animations_class==js_ArrayProxy_class_id){
			void * opaque_animations=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_animations=((ArrayProxy_class *)opaque_animations)[0];
			argv[0] =AP_animations.values(ctx,AP_animations.opaque,(int)0,(bool)false);
			freesrc_animations =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_animations)==-1){
				return JS_EXCEPTION;
			}
			animations =(ModelAnimation *)js_malloc(ctx,size_animations*sizeof(ModelAnimation));
			int i;
			for(i=0;i<size_animations;i++){
				JSValue js_animations=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				ModelAnimation * ptr_animationsi=(ModelAnimation *)JS_GetOpaque(js_animations,js_ModelAnimation_class_id);
				if(ptr_animationsi==NULL){
					JS_ThrowTypeError(ctx,(const char *)"js_animations does not allow null");
					return JS_EXCEPTION;
				}
				animations[i] =*ptr_animationsi;
				JS_FreeValue(ctx,js_animations);
			}
		}else if(JS_IsArrayBuffer(argv[0])==1){
			animations =(ModelAnimation *)JS_GetArrayBuffer(ctx,(size_t *)&size_animations,argv[0]);
		}else{
			if(freesrc_animations){
				JS_FreeValue(ctx,argv[0]);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type ModelAnimation *");
			return JS_EXCEPTION;
		}
		int32_t long_animCount;
		int err_animCount=JS_ToInt32(ctx,&long_animCount,argv[1]);
		if(err_animCount<0){
			if(JS_IsArray(argv[0])==1){
				js_free(ctx,(void *)animations);
			}
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int animCount=((int)long_animCount);
		UnloadModelAnimations(animations,animCount);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)animations);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsModelAnimationValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Model * ptr_model=(Model *)JS_GetOpaque(argv[0],js_Model_class_id);
		if(ptr_model==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Model model=*ptr_model;
		ModelAnimation * ptr_anim=(ModelAnimation *)JS_GetOpaque(argv[1],js_ModelAnimation_class_id);
		if(ptr_anim==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		ModelAnimation anim=*ptr_anim;
		bool returnVal=IsModelAnimationValid(model,anim);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_CheckCollisionSpheres(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector3 * ptr_center1=(Vector3 *)JS_GetOpaque(argv[0],js_Vector3_class_id);
		if(ptr_center1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 center1=*ptr_center1;
		double double_radius1;
		int err_radius1=JS_ToFloat64(ctx,&double_radius1,argv[1]);
		if(err_radius1<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float radius1=((float)double_radius1);
		Vector3 * ptr_center2=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_center2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 center2=*ptr_center2;
		double double_radius2;
		int err_radius2=JS_ToFloat64(ctx,&double_radius2,argv[3]);
		if(err_radius2<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		float radius2=((float)double_radius2);
		bool returnVal=CheckCollisionSpheres(center1,radius1,center2,radius2);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_CheckCollisionBoxes(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		BoundingBox * ptr_box1=(BoundingBox *)JS_GetOpaque(argv[0],js_BoundingBox_class_id);
		if(ptr_box1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		BoundingBox box1=*ptr_box1;
		BoundingBox * ptr_box2=(BoundingBox *)JS_GetOpaque(argv[1],js_BoundingBox_class_id);
		if(ptr_box2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		BoundingBox box2=*ptr_box2;
		bool returnVal=CheckCollisionBoxes(box1,box2);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_CheckCollisionBoxSphere(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		BoundingBox * ptr_box=(BoundingBox *)JS_GetOpaque(argv[0],js_BoundingBox_class_id);
		if(ptr_box==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		BoundingBox box=*ptr_box;
		Vector3 * ptr_center=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 center=*ptr_center;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		bool returnVal=CheckCollisionBoxSphere(box,center,radius);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_GetRayCollisionSphere(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Ray * ptr_ray=(Ray *)JS_GetOpaque(argv[0],js_Ray_class_id);
		if(ptr_ray==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Ray ray=*ptr_ray;
		Vector3 * ptr_center=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_center==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 center=*ptr_center;
		double double_radius;
		int err_radius=JS_ToFloat64(ctx,&double_radius,argv[2]);
		if(err_radius<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		float radius=((float)double_radius);
		RayCollision returnVal=GetRayCollisionSphere(ray,center,radius);
		RayCollision * ptr_ret=(RayCollision *)js_malloc(ctx,sizeof(RayCollision));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_RayCollision_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetRayCollisionBox(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Ray * ptr_ray=(Ray *)JS_GetOpaque(argv[0],js_Ray_class_id);
		if(ptr_ray==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Ray ray=*ptr_ray;
		BoundingBox * ptr_box=(BoundingBox *)JS_GetOpaque(argv[1],js_BoundingBox_class_id);
		if(ptr_box==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		BoundingBox box=*ptr_box;
		RayCollision returnVal=GetRayCollisionBox(ray,box);
		RayCollision * ptr_ret=(RayCollision *)js_malloc(ctx,sizeof(RayCollision));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_RayCollision_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetRayCollisionMesh(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Ray * ptr_ray=(Ray *)JS_GetOpaque(argv[0],js_Ray_class_id);
		if(ptr_ray==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Ray ray=*ptr_ray;
		Mesh * ptr_mesh=(Mesh *)JS_GetOpaque(argv[1],js_Mesh_class_id);
		if(ptr_mesh==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Mesh mesh=*ptr_mesh;
		Matrix * ptr_transform=(Matrix *)JS_GetOpaque(argv[2],js_Matrix_class_id);
		if(ptr_transform==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Matrix transform=*ptr_transform;
		RayCollision returnVal=GetRayCollisionMesh(ray,mesh,transform);
		RayCollision * ptr_ret=(RayCollision *)js_malloc(ctx,sizeof(RayCollision));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_RayCollision_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetRayCollisionTriangle(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Ray * ptr_ray=(Ray *)JS_GetOpaque(argv[0],js_Ray_class_id);
		if(ptr_ray==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Ray ray=*ptr_ray;
		Vector3 * ptr_p1=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 p1=*ptr_p1;
		Vector3 * ptr_p2=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_p2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 p2=*ptr_p2;
		Vector3 * ptr_p3=(Vector3 *)JS_GetOpaque(argv[3],js_Vector3_class_id);
		if(ptr_p3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 p3=*ptr_p3;
		RayCollision returnVal=GetRayCollisionTriangle(ray,p1,p2,p3);
		RayCollision * ptr_ret=(RayCollision *)js_malloc(ctx,sizeof(RayCollision));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_RayCollision_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_GetRayCollisionQuad(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Ray * ptr_ray=(Ray *)JS_GetOpaque(argv[0],js_Ray_class_id);
		if(ptr_ray==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Ray ray=*ptr_ray;
		Vector3 * ptr_p1=(Vector3 *)JS_GetOpaque(argv[1],js_Vector3_class_id);
		if(ptr_p1==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 p1=*ptr_p1;
		Vector3 * ptr_p2=(Vector3 *)JS_GetOpaque(argv[2],js_Vector3_class_id);
		if(ptr_p2==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 p2=*ptr_p2;
		Vector3 * ptr_p3=(Vector3 *)JS_GetOpaque(argv[3],js_Vector3_class_id);
		if(ptr_p3==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 p3=*ptr_p3;
		Vector3 * ptr_p4=(Vector3 *)JS_GetOpaque(argv[4],js_Vector3_class_id);
		if(ptr_p4==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[4] does not allow null");
			return JS_EXCEPTION;
		}
		Vector3 p4=*ptr_p4;
		RayCollision returnVal=GetRayCollisionQuad(ray,p1,p2,p3,p4);
		RayCollision * ptr_ret=(RayCollision *)js_malloc(ctx,sizeof(RayCollision));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_RayCollision_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_InitAudioDevice(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		InitAudioDevice();
		return JS_UNDEFINED;
	}
	
	static JSValue js_CloseAudioDevice(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		CloseAudioDevice();
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsAudioDeviceReady(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		bool returnVal=IsAudioDeviceReady();
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_SetMasterVolume(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		double double_volume;
		int err_volume=JS_ToFloat64(ctx,&double_volume,argv[0]);
		if(err_volume<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		float volume=((float)double_volume);
		SetMasterVolume(volume);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetMasterVolume(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		float returnVal=GetMasterVolume();
		JSValue ret=JS_NewFloat64(ctx,((double)returnVal));
		return ret;
	}
	
	static JSValue js_LoadWave(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Wave returnVal=LoadWave((const char *)fileName);
		Wave * ptr_ret=(Wave *)js_malloc(ctx,sizeof(Wave));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Wave_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_LoadWaveFromMemory(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * fileType;
		int64_t size_fileType;
		if(JS_IsString(argv[0])==1){
			fileType =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileType,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fileType);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileType =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileType,argv[0]);
		}else{
			JSClassID classid_fileType=JS_GetClassID(argv[0]);
			if(classid_fileType==JS_CLASS_INT8_ARRAY){
				size_t offset_fileType;
				JSValue da_fileType=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileType,(size_t *)&size_fileType,NULL);
				fileType =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileType,da_fileType);
				fileType +=offset_fileType;
				size_fileType -=offset_fileType;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileType);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		unsigned char * fileData;
		int64_t size_fileData;
		JSClassID fileData_class=JS_GetClassID(argv[1]);
		if(fileData_class==js_ArrayProxy_class_id){
			void * opaque_fileData=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_fileData=((ArrayProxy_class *)opaque_fileData)[0];
			argv[1] =AP_fileData.values(ctx,AP_fileData.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[1]);
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_fileData)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			fileData =(unsigned char *)js_malloc(ctx,size_fileData*sizeof(unsigned char));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)fileData);
			int i;
			for(i=0;i<size_fileData;i++){
				JSValue js_fileData=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				uint32_t long_fileDatai;
				int err_fileDatai=JS_ToUint32(ctx,&long_fileDatai,js_fileData);
				if(err_fileDatai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_fileData is not numeric");
					return JS_EXCEPTION;
				}
				fileData[i] =((unsigned char)long_fileDatai);
				JS_FreeValue(ctx,js_fileData);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileData =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileData,argv[1]);
		}else{
			JSClassID classid_fileData=JS_GetClassID(argv[1]);
			if(classid_fileData==JS_CLASS_UINT8_ARRAY||classid_fileData==JS_CLASS_UINT8C_ARRAY){
				size_t offset_fileData;
				JSValue da_fileData=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileData,(size_t *)&size_fileData,NULL);
				fileData =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileData,da_fileData);
				fileData +=offset_fileData;
				size_fileData -=offset_fileData;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileData);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[2]);
		if(err_dataSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		Wave returnVal=LoadWaveFromMemory((const char *)fileType,(const unsigned char *)fileData,dataSize);
		Wave * ptr_ret=(Wave *)js_malloc(ctx,sizeof(Wave));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Wave_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_IsWaveValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Wave * ptr_wave=(Wave *)JS_GetOpaque(argv[0],js_Wave_class_id);
		if(ptr_wave==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Wave wave=*ptr_wave;
		bool returnVal=IsWaveValid(wave);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_LoadSound(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Sound returnVal=LoadSound((const char *)fileName);
		Sound * ptr_ret=(Sound *)js_malloc(ctx,sizeof(Sound));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Sound_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_LoadSoundFromWave(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Wave * ptr_wave=(Wave *)JS_GetOpaque(argv[0],js_Wave_class_id);
		if(ptr_wave==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Wave wave=*ptr_wave;
		Sound returnVal=LoadSoundFromWave(wave);
		Sound * ptr_ret=(Sound *)js_malloc(ctx,sizeof(Sound));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Sound_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_LoadSoundAlias(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_source=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_source==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound source=*ptr_source;
		Sound returnVal=LoadSoundAlias(source);
		Sound * ptr_ret=(Sound *)js_malloc(ctx,sizeof(Sound));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Sound_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_IsSoundValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_sound=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_sound==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound sound=*ptr_sound;
		bool returnVal=IsSoundValid(sound);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_UpdateSound(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_sound=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_sound==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound sound=*ptr_sound;
		void * data;
		int64_t size_data;
		if(JS_IsArrayBuffer(argv[1])==1){
			data =(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[1]);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type void *");
			return JS_EXCEPTION;
		}
		int32_t long_sampleCount;
		int err_sampleCount=JS_ToInt32(ctx,&long_sampleCount,argv[2]);
		if(err_sampleCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int sampleCount=((int)long_sampleCount);
		UpdateSound(sound,(const void *)data,sampleCount);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UnloadWave(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Wave * ptr_wave=(Wave *)JS_GetOpaque(argv[0],js_Wave_class_id);
		if(ptr_wave==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Wave wave=*ptr_wave;
		UnloadWave(wave);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UnloadSound(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_sound=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_sound==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound sound=*ptr_sound;
		UnloadSound(sound);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UnloadSoundAlias(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_alias=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_alias==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound alias=*ptr_alias;
		UnloadSoundAlias(alias);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ExportWave(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Wave * ptr_wave=(Wave *)JS_GetOpaque(argv[0],js_Wave_class_id);
		if(ptr_wave==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Wave wave=*ptr_wave;
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[1])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[1]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=ExportWave(wave,(const char *)fileName);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_ExportWaveAsCode(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Wave * ptr_wave=(Wave *)JS_GetOpaque(argv[0],js_Wave_class_id);
		if(ptr_wave==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Wave wave=*ptr_wave;
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[1])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[1]);
		}else if(JS_IsArrayBuffer(argv[1])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[1]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[1],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		bool returnVal=ExportWaveAsCode(wave,(const char *)fileName);
		JSValue ret=JS_NewBool(ctx,returnVal);
		if(JS_IsArray(argv[1])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[1])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[1]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_PlaySound(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_sound=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_sound==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound sound=*ptr_sound;
		PlaySound(sound);
		return JS_UNDEFINED;
	}
	
	static JSValue js_StopSound(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_sound=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_sound==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound sound=*ptr_sound;
		StopSound(sound);
		return JS_UNDEFINED;
	}
	
	static JSValue js_PauseSound(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_sound=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_sound==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound sound=*ptr_sound;
		PauseSound(sound);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ResumeSound(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_sound=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_sound==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound sound=*ptr_sound;
		ResumeSound(sound);
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsSoundPlaying(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_sound=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_sound==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound sound=*ptr_sound;
		bool returnVal=IsSoundPlaying(sound);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_SetSoundVolume(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_sound=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_sound==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound sound=*ptr_sound;
		double double_volume;
		int err_volume=JS_ToFloat64(ctx,&double_volume,argv[1]);
		if(err_volume<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float volume=((float)double_volume);
		SetSoundVolume(sound,volume);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetSoundPitch(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_sound=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_sound==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound sound=*ptr_sound;
		double double_pitch;
		int err_pitch=JS_ToFloat64(ctx,&double_pitch,argv[1]);
		if(err_pitch<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float pitch=((float)double_pitch);
		SetSoundPitch(sound,pitch);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetSoundPan(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Sound * ptr_sound=(Sound *)JS_GetOpaque(argv[0],js_Sound_class_id);
		if(ptr_sound==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Sound sound=*ptr_sound;
		double double_pan;
		int err_pan=JS_ToFloat64(ctx,&double_pan,argv[1]);
		if(err_pan<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float pan=((float)double_pan);
		SetSoundPan(sound,pan);
		return JS_UNDEFINED;
	}
	
	static JSValue js_WaveCopy(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Wave * ptr_wave=(Wave *)JS_GetOpaque(argv[0],js_Wave_class_id);
		if(ptr_wave==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Wave wave=*ptr_wave;
		Wave returnVal=WaveCopy(wave);
		Wave * ptr_ret=(Wave *)js_malloc(ctx,sizeof(Wave));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Wave_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_WaveCrop(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Wave * wave=(Wave *)JS_GetOpaque(argv[0],js_Wave_class_id);
		if(wave==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Wave");
			return JS_EXCEPTION;
		}
		int32_t long_initFrame;
		int err_initFrame=JS_ToInt32(ctx,&long_initFrame,argv[1]);
		if(err_initFrame<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int initFrame=((int)long_initFrame);
		int32_t long_finalFrame;
		int err_finalFrame=JS_ToInt32(ctx,&long_finalFrame,argv[2]);
		if(err_finalFrame<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int finalFrame=((int)long_finalFrame);
		WaveCrop(wave,initFrame,finalFrame);
		JS_SetOpaque(argv[0],(void *)wave);
		return JS_UNDEFINED;
	}
	
	static JSValue js_WaveFormat(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Wave * wave=(Wave *)JS_GetOpaque(argv[0],js_Wave_class_id);
		if(wave==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type Wave");
			return JS_EXCEPTION;
		}
		int32_t long_sampleRate;
		int err_sampleRate=JS_ToInt32(ctx,&long_sampleRate,argv[1]);
		if(err_sampleRate<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		int sampleRate=((int)long_sampleRate);
		int32_t long_sampleSize;
		int err_sampleSize=JS_ToInt32(ctx,&long_sampleSize,argv[2]);
		if(err_sampleSize<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int sampleSize=((int)long_sampleSize);
		int32_t long_channels;
		int err_channels=JS_ToInt32(ctx,&long_channels,argv[3]);
		if(err_channels<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[3] is not numeric");
			return JS_EXCEPTION;
		}
		int channels=((int)long_channels);
		WaveFormat(wave,sampleRate,sampleSize,channels);
		JS_SetOpaque(argv[0],(void *)wave);
		return JS_UNDEFINED;
	}
	
	static JSValue js_LoadWaveSamples(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Wave * ptr_wave=(Wave *)JS_GetOpaque(argv[0],js_Wave_class_id);
		if(ptr_wave==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Wave wave=*ptr_wave;
		float * returnVal=LoadWaveSamples(wave);
		JSValue ret;
		ret =JS_NewArray(ctx);
		int i;
		for(i=0;i<wave.frameCount*wave.channels;i++){
			JSValue js_ret=JS_NewFloat64(ctx,((double)returnVal[i]));
			JS_DefinePropertyValueUint32(ctx,ret,(uint32_t)i,js_ret,JS_PROP_C_W_E);
		}
		UnloadWaveSamples(returnVal);
		return ret;
	}
	
	static JSValue js_UnloadWaveSamples(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		float * samples;
		bool freesrc_samples=(bool)false;
		int64_t size_samples;
		JSClassID samples_class=JS_GetClassID(argv[0]);
		if(samples_class==js_ArrayProxy_class_id){
			void * opaque_samples=JS_GetOpaque(argv[0],js_ArrayProxy_class_id);
			ArrayProxy_class AP_samples=((ArrayProxy_class *)opaque_samples)[0];
			argv[0] =AP_samples.values(ctx,AP_samples.opaque,(int)0,(bool)false);
			freesrc_samples =(bool)true;
		}
		if(JS_IsArray(argv[0])==1){
			if(JS_GetLength(ctx,argv[0],&size_samples)==-1){
				return JS_EXCEPTION;
			}
			samples =(float *)js_malloc(ctx,size_samples*sizeof(float));
			int i;
			for(i=0;i<size_samples;i++){
				JSValue js_samples=JS_GetPropertyUint32(ctx,argv[0],(uint32_t)i);
				double double_samplesi;
				int err_samplesi=JS_ToFloat64(ctx,&double_samplesi,js_samples);
				if(err_samplesi<0){
					JS_ThrowTypeError(ctx,(const char *)"js_samples is not numeric");
					return JS_EXCEPTION;
				}
				samples[i] =((float)double_samplesi);
				JS_FreeValue(ctx,js_samples);
			}
		}else{
			double double_js_samples;
			int err_js_samples=JS_ToFloat64(ctx,&double_js_samples,argv[0]);
			if(err_js_samples<0){
				JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
				return JS_EXCEPTION;
			}
			float js_samples=((float)double_js_samples);
			samples =&js_samples;
		}
		UnloadWaveSamples(samples);
		if(JS_IsArray(argv[0])==1){
			JSValue js_argv0=JS_NewFloat64(ctx,((double)samples[0]));
			JS_DefinePropertyValueUint32(ctx,argv[0],(uint32_t)0,js_argv0,JS_PROP_C_W_E);
		}
		return JS_UNDEFINED;
	}
	
	static JSValue js_LoadMusicStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		char * fileName;
		JSValue da_fileName;
		int64_t size_fileName;
		if(JS_IsString(argv[0])==1){
			fileName =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileName,argv[0]);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,argv[0]);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				size_t offset_fileName;
				da_fileName =JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileName,(size_t *)&size_fileName,NULL);
				fileName =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileName,da_fileName);
				fileName +=offset_fileName;
				size_fileName -=offset_fileName;
			}else{
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		Music returnVal=LoadMusicStream((const char *)fileName);
		Music * ptr_ret=(Music *)js_malloc(ctx,sizeof(Music));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Music_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		if(JS_IsArray(argv[0])==1){
			js_free(ctx,(void *)fileName);
		}else if(JS_IsString(argv[0])==1){
			JS_FreeCString(ctx,(const char *)fileName);
		}else{
			JSClassID classid_fileName=JS_GetClassID(argv[0]);
			if(classid_fileName==JS_CLASS_INT8_ARRAY){
				js_free(ctx,(void *)&da_fileName);
			}
		}
		return ret;
	}
	
	static JSValue js_LoadMusicStreamFromMemory(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		memoryNode * memoryHead=(memoryNode *)calloc((size_t)1,sizeof(memoryNode));
		memoryNode * memoryCurrent=memoryHead;
		char * fileType;
		int64_t size_fileType;
		if(JS_IsString(argv[0])==1){
			fileType =(char *)JS_ToCStringLen(ctx,(size_t *)&size_fileType,argv[0]);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeCString,(void *)fileType);
		}else if(JS_IsArrayBuffer(argv[0])==1){
			fileType =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileType,argv[0]);
		}else{
			JSClassID classid_fileType=JS_GetClassID(argv[0]);
			if(classid_fileType==JS_CLASS_INT8_ARRAY){
				size_t offset_fileType;
				JSValue da_fileType=JS_GetTypedArrayBuffer(ctx,argv[0],&offset_fileType,(size_t *)&size_fileType,NULL);
				fileType =(char *)JS_GetArrayBuffer(ctx,(size_t *)&size_fileType,da_fileType);
				fileType +=offset_fileType;
				size_fileType -=offset_fileType;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_fileType);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[0] does not match type char *");
				return JS_EXCEPTION;
			}
		}
		unsigned char * data;
		int64_t size_data;
		JSClassID data_class=JS_GetClassID(argv[1]);
		if(data_class==js_ArrayProxy_class_id){
			void * opaque_data=JS_GetOpaque(argv[1],js_ArrayProxy_class_id);
			ArrayProxy_class AP_data=((ArrayProxy_class *)opaque_data)[0];
			argv[1] =AP_data.values(ctx,AP_data.opaque,(int)0,(bool)false);
			memoryCurrent =memoryStore(memoryCurrent,JS_FreeValue,(void *)&argv[1]);
		}
		if(JS_IsArray(argv[1])==1){
			if(JS_GetLength(ctx,argv[1],&size_data)==-1){
				memoryClear(ctx,memoryHead);
				return JS_EXCEPTION;
			}
			data =(unsigned char *)js_malloc(ctx,size_data*sizeof(unsigned char));
			memoryCurrent =memoryStore(memoryCurrent,js_free,(void *)data);
			int i;
			for(i=0;i<size_data;i++){
				JSValue js_data=JS_GetPropertyUint32(ctx,argv[1],(uint32_t)i);
				uint32_t long_datai;
				int err_datai=JS_ToUint32(ctx,&long_datai,js_data);
				if(err_datai<0){
					JS_ThrowTypeError(ctx,(const char *)"js_data is not numeric");
					return JS_EXCEPTION;
				}
				data[i] =((unsigned char)long_datai);
				JS_FreeValue(ctx,js_data);
			}
		}else if(JS_IsArrayBuffer(argv[1])==1){
			data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[1]);
		}else{
			JSClassID classid_data=JS_GetClassID(argv[1]);
			if(classid_data==JS_CLASS_UINT8_ARRAY||classid_data==JS_CLASS_UINT8C_ARRAY){
				size_t offset_data;
				JSValue da_data=JS_GetTypedArrayBuffer(ctx,argv[1],&offset_data,(size_t *)&size_data,NULL);
				data =(unsigned char *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,da_data);
				data +=offset_data;
				size_data -=offset_data;
				memoryCurrent =memoryStore(memoryCurrent,JS_FreeValuePtr,(void *)&da_data);
			}else{
				memoryClear(ctx,memoryHead);
				JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type unsigned char *");
				return JS_EXCEPTION;
			}
		}
		int32_t long_dataSize;
		int err_dataSize=JS_ToInt32(ctx,&long_dataSize,argv[2]);
		if(err_dataSize<0){
			memoryClear(ctx,memoryHead);
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int dataSize=((int)long_dataSize);
		Music returnVal=LoadMusicStreamFromMemory((const char *)fileType,(const unsigned char *)data,dataSize);
		Music * ptr_ret=(Music *)js_malloc(ctx,sizeof(Music));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Music_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		memoryClear(ctx,memoryHead);
		return ret;
	}
	
	static JSValue js_IsMusicValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		bool returnVal=IsMusicValid(music);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_UnloadMusicStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		UnloadMusicStream(music);
		return JS_UNDEFINED;
	}
	
	static JSValue js_PlayMusicStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		PlayMusicStream(music);
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsMusicStreamPlaying(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		bool returnVal=IsMusicStreamPlaying(music);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_UpdateMusicStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		UpdateMusicStream(music);
		return JS_UNDEFINED;
	}
	
	static JSValue js_StopMusicStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		StopMusicStream(music);
		return JS_UNDEFINED;
	}
	
	static JSValue js_PauseMusicStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		PauseMusicStream(music);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ResumeMusicStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		ResumeMusicStream(music);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SeekMusicStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		double double_position;
		int err_position=JS_ToFloat64(ctx,&double_position,argv[1]);
		if(err_position<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float position=((float)double_position);
		SeekMusicStream(music,position);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetMusicVolume(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		double double_volume;
		int err_volume=JS_ToFloat64(ctx,&double_volume,argv[1]);
		if(err_volume<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float volume=((float)double_volume);
		SetMusicVolume(music,volume);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetMusicPitch(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		double double_pitch;
		int err_pitch=JS_ToFloat64(ctx,&double_pitch,argv[1]);
		if(err_pitch<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float pitch=((float)double_pitch);
		SetMusicPitch(music,pitch);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetMusicPan(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		double double_pan;
		int err_pan=JS_ToFloat64(ctx,&double_pan,argv[1]);
		if(err_pan<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float pan=((float)double_pan);
		SetMusicPan(music,pan);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetMusicTimeLength(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		float returnVal=GetMusicTimeLength(music);
		JSValue ret=JS_NewFloat64(ctx,((double)returnVal));
		return ret;
	}
	
	static JSValue js_GetMusicTimePlayed(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Music * ptr_music=(Music *)JS_GetOpaque(argv[0],js_Music_class_id);
		if(ptr_music==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Music music=*ptr_music;
		float returnVal=GetMusicTimePlayed(music);
		JSValue ret=JS_NewFloat64(ctx,((double)returnVal));
		return ret;
	}
	
	static JSValue js_LoadAudioStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		uint32_t long_sampleRate;
		int err_sampleRate=JS_ToUint32(ctx,&long_sampleRate,argv[0]);
		if(err_sampleRate<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int sampleRate=((unsigned int)long_sampleRate);
		uint32_t long_sampleSize;
		int err_sampleSize=JS_ToUint32(ctx,&long_sampleSize,argv[1]);
		if(err_sampleSize<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int sampleSize=((unsigned int)long_sampleSize);
		uint32_t long_channels;
		int err_channels=JS_ToUint32(ctx,&long_channels,argv[2]);
		if(err_channels<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		unsigned int channels=((unsigned int)long_channels);
		AudioStream returnVal=LoadAudioStream(sampleRate,sampleSize,channels);
		AudioStream * ptr_ret=(AudioStream *)js_malloc(ctx,sizeof(AudioStream));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_AudioStream_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	
	static JSValue js_IsAudioStreamValid(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		bool returnVal=IsAudioStreamValid(stream);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_UnloadAudioStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		UnloadAudioStream(stream);
		return JS_UNDEFINED;
	}
	
	static JSValue js_UpdateAudioStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		void * data;
		int64_t size_data;
		if(JS_IsArrayBuffer(argv[1])==1){
			data =(void *)JS_GetArrayBuffer(ctx,(size_t *)&size_data,argv[1]);
		}else{
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not match type void *");
			return JS_EXCEPTION;
		}
		int32_t long_frameCount;
		int err_frameCount=JS_ToInt32(ctx,&long_frameCount,argv[2]);
		if(err_frameCount<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[2] is not numeric");
			return JS_EXCEPTION;
		}
		int frameCount=((int)long_frameCount);
		UpdateAudioStream(stream,(const void *)data,frameCount);
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsAudioStreamProcessed(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		bool returnVal=IsAudioStreamProcessed(stream);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_PlayAudioStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		PlayAudioStream(stream);
		return JS_UNDEFINED;
	}
	
	static JSValue js_PauseAudioStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		PauseAudioStream(stream);
		return JS_UNDEFINED;
	}
	
	static JSValue js_ResumeAudioStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		ResumeAudioStream(stream);
		return JS_UNDEFINED;
	}
	
	static JSValue js_IsAudioStreamPlaying(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		bool returnVal=IsAudioStreamPlaying(stream);
		JSValue ret=JS_NewBool(ctx,returnVal);
		return ret;
	}
	
	static JSValue js_StopAudioStream(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		StopAudioStream(stream);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetAudioStreamVolume(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		double double_volume;
		int err_volume=JS_ToFloat64(ctx,&double_volume,argv[1]);
		if(err_volume<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float volume=((float)double_volume);
		SetAudioStreamVolume(stream,volume);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetAudioStreamPitch(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		double double_pitch;
		int err_pitch=JS_ToFloat64(ctx,&double_pitch,argv[1]);
		if(err_pitch<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float pitch=((float)double_pitch);
		SetAudioStreamPitch(stream,pitch);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetAudioStreamPan(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		AudioStream * ptr_stream=(AudioStream *)JS_GetOpaque(argv[0],js_AudioStream_class_id);
		if(ptr_stream==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		AudioStream stream=*ptr_stream;
		double double_pan;
		int err_pan=JS_ToFloat64(ctx,&double_pan,argv[1]);
		if(err_pan<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] is not numeric");
			return JS_EXCEPTION;
		}
		float pan=((float)double_pan);
		SetAudioStreamPan(stream,pan);
		return JS_UNDEFINED;
	}
	
	static JSValue js_SetAudioStreamBufferSizeDefault(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int32_t long_size;
		int err_size=JS_ToInt32(ctx,&long_size,argv[0]);
		if(err_size<0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] is not numeric");
			return JS_EXCEPTION;
		}
		int size=((int)long_size);
		SetAudioStreamBufferSizeDefault(size);
		return JS_UNDEFINED;
	}
	
	static JSValue js_AttachAudioMixedProcessor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		trampolineContext ctx_processor;
		ctx_processor.ctx=ctx;
		ctx_processor.func_obj=argv[0];
		void * processor=callback_AudioMixedProcessor;
		if(JS_IsFunction(ctx,argv[0])==0){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] must be a function");
			return JS_EXCEPTION;
		}
		if(AudioMixedProcessor_size==0){
			AudioMixedProcessor_arr =(trampolineContext *)js_malloc(ctx,sizeof(trampolineContext));
		}else{
			AudioMixedProcessor_arr =(trampolineContext *)js_realloc(ctx,(void *)AudioMixedProcessor_arr,sizeof(trampolineContext)*AudioMixedProcessor_size);
		}
		JS_DupValue(ctx,argv[0]);
		AudioMixedProcessor_arr[AudioMixedProcessor_size] =ctx_processor;
		AudioMixedProcessor_size +=1;
		if(AudioMixedProcessor_size>1){
			return JS_UNDEFINED;
		}
		AttachAudioMixedProcessor(processor);
		return JS_UNDEFINED;
	}
	
	static JSValue js_DetachAudioMixedProcessor(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		int processor_pos;
		void * processor=callback_AudioCallback;
		int i;
		for(i=0;i<AudioMixedProcessor_size;i++){
			if(JS_IsEqual(AudioMixedProcessor_arr[i].ctx,AudioMixedProcessor_arr[i].func_obj,argv[0])){
				JS_FreeValue(ctx,AudioMixedProcessor_arr[i].func_obj);
				JS_FreeValue(AudioMixedProcessor_arr[i].ctx,AudioMixedProcessor_arr[i].func_obj);
				JS_FreeContext(AudioMixedProcessor_arr[i].ctx);
				int i0;
				for(i0=i;i0<AudioMixedProcessor_size-1;i0++){
					AudioMixedProcessor_arr[i0]=AudioMixedProcessor_arr[i0+1];
				}
			}
			AudioMixedProcessor_size -=1;
			AudioMixedProcessor_arr =(trampolineContext *)js_realloc(ctx,(void *)AudioMixedProcessor_arr,sizeof(void *)*AudioMixedProcessor_size);
			break;
		}
		if(AudioMixedProcessor_size!=0){
			return JS_UNDEFINED;
		}
		DetachAudioMixedProcessor(processor);
		return JS_UNDEFINED;
	}
	
	static JSValue js_GetMouseRay(JSContext * ctx,JSValue this_val,int argc,JSValue * argv){
		Vector2 * ptr_position=(Vector2 *)JS_GetOpaque(argv[0],js_Vector2_class_id);
		if(ptr_position==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[0] does not allow null");
			return JS_EXCEPTION;
		}
		Vector2 position=*ptr_position;
		Camera * ptr_camera=(Camera *)JS_GetOpaque(argv[1],js_Camera3D_class_id);
		if(ptr_camera==NULL){
			JS_ThrowTypeError(ctx,(const char *)"argv[1] does not allow null");
			return JS_EXCEPTION;
		}
		Camera camera=*ptr_camera;
		Ray returnVal=GetMouseRay(position,camera);
		Ray * ptr_ret=(Ray *)js_malloc(ctx,sizeof(Ray));
		ptr_ret[0]=returnVal;
		JSValue ret=JS_NewObjectClass(ctx,(int)js_Ray_class_id);
		JS_SetOpaque(ret,(void *)ptr_ret);
		return ret;
	}
	static const JSCFunctionListEntry jsraylib_funcs[]={
		JS_CFUNC_DEF("InitWindow",3,js_InitWindow),
		JS_CFUNC_DEF("CloseWindow",0,js_CloseWindow),
		JS_CFUNC_DEF("WindowShouldClose",0,js_WindowShouldClose),
		JS_CFUNC_DEF("IsWindowReady",0,js_IsWindowReady),
		JS_CFUNC_DEF("IsWindowFullscreen",0,js_IsWindowFullscreen),
		JS_CFUNC_DEF("IsWindowHidden",0,js_IsWindowHidden),
		JS_CFUNC_DEF("IsWindowMinimized",0,js_IsWindowMinimized),
		JS_CFUNC_DEF("IsWindowMaximized",0,js_IsWindowMaximized),
		JS_CFUNC_DEF("IsWindowFocused",0,js_IsWindowFocused),
		JS_CFUNC_DEF("IsWindowResized",0,js_IsWindowResized),
		JS_CFUNC_DEF("IsWindowState",1,js_IsWindowState),
		JS_CFUNC_DEF("SetWindowState",1,js_SetWindowState),
		JS_CFUNC_DEF("ClearWindowState",1,js_ClearWindowState),
		JS_CFUNC_DEF("ToggleFullscreen",0,js_ToggleFullscreen),
		JS_CFUNC_DEF("ToggleBorderlessWindowed",0,js_ToggleBorderlessWindowed),
		JS_CFUNC_DEF("MaximizeWindow",0,js_MaximizeWindow),
		JS_CFUNC_DEF("MinimizeWindow",0,js_MinimizeWindow),
		JS_CFUNC_DEF("RestoreWindow",0,js_RestoreWindow),
		JS_CFUNC_DEF("SetWindowIcon",1,js_SetWindowIcon),
		JS_CFUNC_DEF("SetWindowIcons",2,js_SetWindowIcons),
		JS_CFUNC_DEF("SetWindowTitle",1,js_SetWindowTitle),
		JS_CFUNC_DEF("SetWindowPosition",2,js_SetWindowPosition),
		JS_CFUNC_DEF("SetWindowMonitor",1,js_SetWindowMonitor),
		JS_CFUNC_DEF("SetWindowMinSize",2,js_SetWindowMinSize),
		JS_CFUNC_DEF("SetWindowMaxSize",2,js_SetWindowMaxSize),
		JS_CFUNC_DEF("SetWindowSize",2,js_SetWindowSize),
		JS_CFUNC_DEF("SetWindowOpacity",1,js_SetWindowOpacity),
		JS_CFUNC_DEF("SetWindowFocused",0,js_SetWindowFocused),
		JS_CFUNC_DEF("GetScreenWidth",0,js_GetScreenWidth),
		JS_CFUNC_DEF("GetScreenHeight",0,js_GetScreenHeight),
		JS_CFUNC_DEF("GetRenderWidth",0,js_GetRenderWidth),
		JS_CFUNC_DEF("GetRenderHeight",0,js_GetRenderHeight),
		JS_CFUNC_DEF("GetMonitorCount",0,js_GetMonitorCount),
		JS_CFUNC_DEF("GetCurrentMonitor",0,js_GetCurrentMonitor),
		JS_CFUNC_DEF("GetMonitorPosition",1,js_GetMonitorPosition),
		JS_CFUNC_DEF("GetMonitorWidth",1,js_GetMonitorWidth),
		JS_CFUNC_DEF("GetMonitorHeight",1,js_GetMonitorHeight),
		JS_CFUNC_DEF("GetMonitorPhysicalWidth",1,js_GetMonitorPhysicalWidth),
		JS_CFUNC_DEF("GetMonitorPhysicalHeight",1,js_GetMonitorPhysicalHeight),
		JS_CFUNC_DEF("GetMonitorRefreshRate",1,js_GetMonitorRefreshRate),
		JS_CFUNC_DEF("GetWindowPosition",0,js_GetWindowPosition),
		JS_CFUNC_DEF("GetWindowScaleDPI",0,js_GetWindowScaleDPI),
		JS_CFUNC_DEF("GetMonitorName",1,js_GetMonitorName),
		JS_CFUNC_DEF("SetClipboardText",1,js_SetClipboardText),
		JS_CFUNC_DEF("GetClipboardText",0,js_GetClipboardText),
		JS_CFUNC_DEF("GetClipboardImage",0,js_GetClipboardImage),
		JS_CFUNC_DEF("EnableEventWaiting",0,js_EnableEventWaiting),
		JS_CFUNC_DEF("DisableEventWaiting",0,js_DisableEventWaiting),
		JS_CFUNC_DEF("ShowCursor",0,js_ShowCursor),
		JS_CFUNC_DEF("HideCursor",0,js_HideCursor),
		JS_CFUNC_DEF("IsCursorHidden",0,js_IsCursorHidden),
		JS_CFUNC_DEF("EnableCursor",0,js_EnableCursor),
		JS_CFUNC_DEF("DisableCursor",0,js_DisableCursor),
		JS_CFUNC_DEF("IsCursorOnScreen",0,js_IsCursorOnScreen),
		JS_CFUNC_DEF("ClearBackground",1,js_ClearBackground),
		JS_CFUNC_DEF("BeginDrawing",0,js_BeginDrawing),
		JS_CFUNC_DEF("EndDrawing",0,js_EndDrawing),
		JS_CFUNC_DEF("BeginMode2D",1,js_BeginMode2D),
		JS_CFUNC_DEF("EndMode2D",0,js_EndMode2D),
		JS_CFUNC_DEF("BeginMode3D",1,js_BeginMode3D),
		JS_CFUNC_DEF("EndMode3D",0,js_EndMode3D),
		JS_CFUNC_DEF("BeginTextureMode",1,js_BeginTextureMode),
		JS_CFUNC_DEF("EndTextureMode",0,js_EndTextureMode),
		JS_CFUNC_DEF("BeginShaderMode",1,js_BeginShaderMode),
		JS_CFUNC_DEF("EndShaderMode",0,js_EndShaderMode),
		JS_CFUNC_DEF("BeginBlendMode",1,js_BeginBlendMode),
		JS_CFUNC_DEF("EndBlendMode",0,js_EndBlendMode),
		JS_CFUNC_DEF("BeginScissorMode",4,js_BeginScissorMode),
		JS_CFUNC_DEF("EndScissorMode",0,js_EndScissorMode),
		JS_CFUNC_DEF("BeginVrStereoMode",1,js_BeginVrStereoMode),
		JS_CFUNC_DEF("EndVrStereoMode",0,js_EndVrStereoMode),
		JS_CFUNC_DEF("LoadVrStereoConfig",1,js_LoadVrStereoConfig),
		JS_CFUNC_DEF("UnloadVrStereoConfig",1,js_UnloadVrStereoConfig),
		JS_CFUNC_DEF("LoadShader",2,js_LoadShader),
		JS_CFUNC_DEF("LoadShaderFromMemory",2,js_LoadShaderFromMemory),
		JS_CFUNC_DEF("IsShaderValid",1,js_IsShaderValid),
		JS_CFUNC_DEF("GetShaderLocation",2,js_GetShaderLocation),
		JS_CFUNC_DEF("GetShaderLocationAttrib",2,js_GetShaderLocationAttrib),
		JS_CFUNC_DEF("SetShaderValue",4,js_SetShaderValue),
		JS_CFUNC_DEF("SetShaderValueV",5,js_SetShaderValueV),
		JS_CFUNC_DEF("SetShaderValueMatrix",3,js_SetShaderValueMatrix),
		JS_CFUNC_DEF("SetShaderValueTexture",3,js_SetShaderValueTexture),
		JS_CFUNC_DEF("UnloadShader",1,js_UnloadShader),
		JS_CFUNC_DEF("GetScreenToWorldRay",2,js_GetScreenToWorldRay),
		JS_CFUNC_DEF("GetScreenToWorldRayEx",4,js_GetScreenToWorldRayEx),
		JS_CFUNC_DEF("GetWorldToScreen",2,js_GetWorldToScreen),
		JS_CFUNC_DEF("GetWorldToScreenEx",4,js_GetWorldToScreenEx),
		JS_CFUNC_DEF("GetWorldToScreen2D",2,js_GetWorldToScreen2D),
		JS_CFUNC_DEF("GetScreenToWorld2D",2,js_GetScreenToWorld2D),
		JS_CFUNC_DEF("GetCameraMatrix",1,js_GetCameraMatrix),
		JS_CFUNC_DEF("GetCameraMatrix2D",1,js_GetCameraMatrix2D),
		JS_CFUNC_DEF("SetTargetFPS",1,js_SetTargetFPS),
		JS_CFUNC_DEF("GetFrameTime",0,js_GetFrameTime),
		JS_CFUNC_DEF("GetTime",0,js_GetTime),
		JS_CFUNC_DEF("GetFPS",0,js_GetFPS),
		JS_CFUNC_DEF("SetRandomSeed",1,js_SetRandomSeed),
		JS_CFUNC_DEF("GetRandomValue",2,js_GetRandomValue),
		JS_CFUNC_DEF("LoadRandomSequence",3,js_LoadRandomSequence),
		JS_CFUNC_DEF("UnloadRandomSequence",1,js_UnloadRandomSequence),
		JS_CFUNC_DEF("TakeScreenshot",1,js_TakeScreenshot),
		JS_CFUNC_DEF("SetConfigFlags",1,js_SetConfigFlags),
		JS_CFUNC_DEF("OpenURL",1,js_OpenURL),
		JS_CFUNC_DEF("TraceLog",2,js_TraceLog),
		JS_CFUNC_DEF("SetTraceLogLevel",1,js_SetTraceLogLevel),
		JS_CFUNC_DEF("SetLoadFileDataCallback",1,js_SetLoadFileDataCallback),
		JS_CFUNC_DEF("SetSaveFileDataCallback",1,js_SetSaveFileDataCallback),
		JS_CFUNC_DEF("SetLoadFileTextCallback",1,js_SetLoadFileTextCallback),
		JS_CFUNC_DEF("SetSaveFileTextCallback",1,js_SetSaveFileTextCallback),
		JS_CFUNC_DEF("LoadFileData",2,js_LoadFileData),
		JS_CFUNC_DEF("SaveFileData",3,js_SaveFileData),
		JS_CFUNC_DEF("ExportDataAsCode",3,js_ExportDataAsCode),
		JS_CFUNC_DEF("LoadFileText",1,js_LoadFileText),
		JS_CFUNC_DEF("SaveFileText",2,js_SaveFileText),
		JS_CFUNC_DEF("FileExists",1,js_FileExists),
		JS_CFUNC_DEF("DirectoryExists",1,js_DirectoryExists),
		JS_CFUNC_DEF("IsFileExtension",2,js_IsFileExtension),
		JS_CFUNC_DEF("GetFileLength",1,js_GetFileLength),
		JS_CFUNC_DEF("GetFileExtension",1,js_GetFileExtension),
		JS_CFUNC_DEF("GetFileName",1,js_GetFileName),
		JS_CFUNC_DEF("GetFileNameWithoutExt",1,js_GetFileNameWithoutExt),
		JS_CFUNC_DEF("GetDirectoryPath",1,js_GetDirectoryPath),
		JS_CFUNC_DEF("GetPrevDirectoryPath",1,js_GetPrevDirectoryPath),
		JS_CFUNC_DEF("GetWorkingDirectory",0,js_GetWorkingDirectory),
		JS_CFUNC_DEF("GetApplicationDirectory",0,js_GetApplicationDirectory),
		JS_CFUNC_DEF("MakeDirectory",1,js_MakeDirectory),
		JS_CFUNC_DEF("ChangeDirectory",1,js_ChangeDirectory),
		JS_CFUNC_DEF("IsPathFile",1,js_IsPathFile),
		JS_CFUNC_DEF("IsFileNameValid",1,js_IsFileNameValid),
		JS_CFUNC_DEF("LoadDirectoryFiles",1,js_LoadDirectoryFiles),
		JS_CFUNC_DEF("LoadDirectoryFilesEx",3,js_LoadDirectoryFilesEx),
		JS_CFUNC_DEF("IsFileDropped",0,js_IsFileDropped),
		JS_CFUNC_DEF("LoadDroppedFiles",0,js_LoadDroppedFiles),
		JS_CFUNC_DEF("GetFileModTime",1,js_GetFileModTime),
		JS_CFUNC_DEF("CompressData",3,js_CompressData),
		JS_CFUNC_DEF("DecompressData",3,js_DecompressData),
		JS_CFUNC_DEF("EncodeDataBase64",3,js_EncodeDataBase64),
		JS_CFUNC_DEF("DecodeDataBase64",2,js_DecodeDataBase64),
		JS_CFUNC_DEF("ComputeCRC32",2,js_ComputeCRC32),
		JS_CFUNC_DEF("ComputeMD5",2,js_ComputeMD5),
		JS_CFUNC_DEF("ComputeSHA1",2,js_ComputeSHA1),
		JS_CFUNC_DEF("LoadAutomationEventList",1,js_LoadAutomationEventList),
		JS_CFUNC_DEF("UnloadAutomationEventList",1,js_UnloadAutomationEventList),
		JS_CFUNC_DEF("ExportAutomationEventList",2,js_ExportAutomationEventList),
		JS_CFUNC_DEF("SetAutomationEventList",1,js_SetAutomationEventList),
		JS_CFUNC_DEF("SetAutomationEventBaseFrame",1,js_SetAutomationEventBaseFrame),
		JS_CFUNC_DEF("StartAutomationEventRecording",0,js_StartAutomationEventRecording),
		JS_CFUNC_DEF("StopAutomationEventRecording",0,js_StopAutomationEventRecording),
		JS_CFUNC_DEF("PlayAutomationEvent",1,js_PlayAutomationEvent),
		JS_CFUNC_DEF("IsKeyPressed",1,js_IsKeyPressed),
		JS_CFUNC_DEF("IsKeyPressedRepeat",1,js_IsKeyPressedRepeat),
		JS_CFUNC_DEF("IsKeyDown",1,js_IsKeyDown),
		JS_CFUNC_DEF("IsKeyReleased",1,js_IsKeyReleased),
		JS_CFUNC_DEF("IsKeyUp",1,js_IsKeyUp),
		JS_CFUNC_DEF("GetKeyPressed",0,js_GetKeyPressed),
		JS_CFUNC_DEF("GetCharPressed",0,js_GetCharPressed),
		JS_CFUNC_DEF("GetKeyName",1,js_GetKeyName),
		JS_CFUNC_DEF("SetExitKey",1,js_SetExitKey),
		JS_CFUNC_DEF("IsGamepadAvailable",1,js_IsGamepadAvailable),
		JS_CFUNC_DEF("GetGamepadName",1,js_GetGamepadName),
		JS_CFUNC_DEF("IsGamepadButtonPressed",2,js_IsGamepadButtonPressed),
		JS_CFUNC_DEF("IsGamepadButtonDown",2,js_IsGamepadButtonDown),
		JS_CFUNC_DEF("IsGamepadButtonReleased",2,js_IsGamepadButtonReleased),
		JS_CFUNC_DEF("IsGamepadButtonUp",2,js_IsGamepadButtonUp),
		JS_CFUNC_DEF("GetGamepadButtonPressed",0,js_GetGamepadButtonPressed),
		JS_CFUNC_DEF("GetGamepadAxisCount",1,js_GetGamepadAxisCount),
		JS_CFUNC_DEF("GetGamepadAxisMovement",2,js_GetGamepadAxisMovement),
		JS_CFUNC_DEF("SetGamepadMappings",1,js_SetGamepadMappings),
		JS_CFUNC_DEF("SetGamepadVibration",4,js_SetGamepadVibration),
		JS_CFUNC_DEF("IsMouseButtonPressed",1,js_IsMouseButtonPressed),
		JS_CFUNC_DEF("IsMouseButtonDown",1,js_IsMouseButtonDown),
		JS_CFUNC_DEF("IsMouseButtonReleased",1,js_IsMouseButtonReleased),
		JS_CFUNC_DEF("IsMouseButtonUp",1,js_IsMouseButtonUp),
		JS_CFUNC_DEF("GetMouseX",0,js_GetMouseX),
		JS_CFUNC_DEF("GetMouseY",0,js_GetMouseY),
		JS_CFUNC_DEF("GetMousePosition",0,js_GetMousePosition),
		JS_CFUNC_DEF("GetMouseDelta",0,js_GetMouseDelta),
		JS_CFUNC_DEF("SetMousePosition",2,js_SetMousePosition),
		JS_CFUNC_DEF("SetMouseOffset",2,js_SetMouseOffset),
		JS_CFUNC_DEF("SetMouseScale",2,js_SetMouseScale),
		JS_CFUNC_DEF("GetMouseWheelMove",0,js_GetMouseWheelMove),
		JS_CFUNC_DEF("GetMouseWheelMoveV",0,js_GetMouseWheelMoveV),
		JS_CFUNC_DEF("SetMouseCursor",1,js_SetMouseCursor),
		JS_CFUNC_DEF("GetTouchX",0,js_GetTouchX),
		JS_CFUNC_DEF("GetTouchY",0,js_GetTouchY),
		JS_CFUNC_DEF("GetTouchPosition",1,js_GetTouchPosition),
		JS_CFUNC_DEF("GetTouchPointId",1,js_GetTouchPointId),
		JS_CFUNC_DEF("GetTouchPointCount",0,js_GetTouchPointCount),
		JS_CFUNC_DEF("SetGesturesEnabled",1,js_SetGesturesEnabled),
		JS_CFUNC_DEF("IsGestureDetected",1,js_IsGestureDetected),
		JS_CFUNC_DEF("GetGestureDetected",0,js_GetGestureDetected),
		JS_CFUNC_DEF("GetGestureHoldDuration",0,js_GetGestureHoldDuration),
		JS_CFUNC_DEF("GetGestureDragVector",0,js_GetGestureDragVector),
		JS_CFUNC_DEF("GetGestureDragAngle",0,js_GetGestureDragAngle),
		JS_CFUNC_DEF("GetGesturePinchVector",0,js_GetGesturePinchVector),
		JS_CFUNC_DEF("GetGesturePinchAngle",0,js_GetGesturePinchAngle),
		JS_CFUNC_DEF("UpdateCamera",2,js_UpdateCamera),
		JS_CFUNC_DEF("UpdateCameraPro",4,js_UpdateCameraPro),
		JS_CFUNC_DEF("SetShapesTexture",2,js_SetShapesTexture),
		JS_CFUNC_DEF("GetShapesTexture",0,js_GetShapesTexture),
		JS_CFUNC_DEF("GetShapesTextureRectangle",0,js_GetShapesTextureRectangle),
		JS_CFUNC_DEF("DrawPixel",3,js_DrawPixel),
		JS_CFUNC_DEF("DrawPixelV",2,js_DrawPixelV),
		JS_CFUNC_DEF("DrawLine",5,js_DrawLine),
		JS_CFUNC_DEF("DrawLineV",3,js_DrawLineV),
		JS_CFUNC_DEF("DrawLineEx",4,js_DrawLineEx),
		JS_CFUNC_DEF("DrawLineStrip",3,js_DrawLineStrip),
		JS_CFUNC_DEF("DrawLineBezier",4,js_DrawLineBezier),
		JS_CFUNC_DEF("DrawCircle",4,js_DrawCircle),
		JS_CFUNC_DEF("DrawCircleSector",6,js_DrawCircleSector),
		JS_CFUNC_DEF("DrawCircleSectorLines",6,js_DrawCircleSectorLines),
		JS_CFUNC_DEF("DrawCircleGradient",5,js_DrawCircleGradient),
		JS_CFUNC_DEF("DrawCircleV",3,js_DrawCircleV),
		JS_CFUNC_DEF("DrawCircleLines",4,js_DrawCircleLines),
		JS_CFUNC_DEF("DrawCircleLinesV",3,js_DrawCircleLinesV),
		JS_CFUNC_DEF("DrawEllipse",5,js_DrawEllipse),
		JS_CFUNC_DEF("DrawEllipseV",4,js_DrawEllipseV),
		JS_CFUNC_DEF("DrawEllipseLines",5,js_DrawEllipseLines),
		JS_CFUNC_DEF("DrawEllipseLinesV",4,js_DrawEllipseLinesV),
		JS_CFUNC_DEF("DrawRing",7,js_DrawRing),
		JS_CFUNC_DEF("DrawRingLines",7,js_DrawRingLines),
		JS_CFUNC_DEF("DrawRectangle",5,js_DrawRectangle),
		JS_CFUNC_DEF("DrawRectangleV",3,js_DrawRectangleV),
		JS_CFUNC_DEF("DrawRectangleRec",2,js_DrawRectangleRec),
		JS_CFUNC_DEF("DrawRectanglePro",4,js_DrawRectanglePro),
		JS_CFUNC_DEF("DrawRectangleGradientV",6,js_DrawRectangleGradientV),
		JS_CFUNC_DEF("DrawRectangleGradientH",6,js_DrawRectangleGradientH),
		JS_CFUNC_DEF("DrawRectangleGradientEx",5,js_DrawRectangleGradientEx),
		JS_CFUNC_DEF("DrawRectangleLines",5,js_DrawRectangleLines),
		JS_CFUNC_DEF("DrawRectangleLinesEx",3,js_DrawRectangleLinesEx),
		JS_CFUNC_DEF("DrawRectangleRounded",4,js_DrawRectangleRounded),
		JS_CFUNC_DEF("DrawRectangleRoundedLines",4,js_DrawRectangleRoundedLines),
		JS_CFUNC_DEF("DrawRectangleRoundedLinesEx",5,js_DrawRectangleRoundedLinesEx),
		JS_CFUNC_DEF("DrawTriangle",4,js_DrawTriangle),
		JS_CFUNC_DEF("DrawTriangleLines",4,js_DrawTriangleLines),
		JS_CFUNC_DEF("DrawTriangleFan",3,js_DrawTriangleFan),
		JS_CFUNC_DEF("DrawTriangleStrip",3,js_DrawTriangleStrip),
		JS_CFUNC_DEF("DrawPoly",5,js_DrawPoly),
		JS_CFUNC_DEF("DrawPolyLines",5,js_DrawPolyLines),
		JS_CFUNC_DEF("DrawPolyLinesEx",6,js_DrawPolyLinesEx),
		JS_CFUNC_DEF("DrawSplineLinear",4,js_DrawSplineLinear),
		JS_CFUNC_DEF("DrawSplineBasis",4,js_DrawSplineBasis),
		JS_CFUNC_DEF("DrawSplineCatmullRom",4,js_DrawSplineCatmullRom),
		JS_CFUNC_DEF("DrawSplineBezierQuadratic",4,js_DrawSplineBezierQuadratic),
		JS_CFUNC_DEF("DrawSplineBezierCubic",4,js_DrawSplineBezierCubic),
		JS_CFUNC_DEF("DrawSplineSegmentLinear",4,js_DrawSplineSegmentLinear),
		JS_CFUNC_DEF("DrawSplineSegmentBasis",6,js_DrawSplineSegmentBasis),
		JS_CFUNC_DEF("DrawSplineSegmentCatmullRom",6,js_DrawSplineSegmentCatmullRom),
		JS_CFUNC_DEF("DrawSplineSegmentBezierQuadratic",5,js_DrawSplineSegmentBezierQuadratic),
		JS_CFUNC_DEF("DrawSplineSegmentBezierCubic",6,js_DrawSplineSegmentBezierCubic),
		JS_CFUNC_DEF("GetSplinePointLinear",3,js_GetSplinePointLinear),
		JS_CFUNC_DEF("GetSplinePointBasis",5,js_GetSplinePointBasis),
		JS_CFUNC_DEF("GetSplinePointCatmullRom",5,js_GetSplinePointCatmullRom),
		JS_CFUNC_DEF("GetSplinePointBezierQuad",4,js_GetSplinePointBezierQuad),
		JS_CFUNC_DEF("GetSplinePointBezierCubic",5,js_GetSplinePointBezierCubic),
		JS_CFUNC_DEF("CheckCollisionRecs",2,js_CheckCollisionRecs),
		JS_CFUNC_DEF("CheckCollisionCircles",4,js_CheckCollisionCircles),
		JS_CFUNC_DEF("CheckCollisionCircleRec",3,js_CheckCollisionCircleRec),
		JS_CFUNC_DEF("CheckCollisionCircleLine",4,js_CheckCollisionCircleLine),
		JS_CFUNC_DEF("CheckCollisionPointRec",2,js_CheckCollisionPointRec),
		JS_CFUNC_DEF("CheckCollisionPointCircle",3,js_CheckCollisionPointCircle),
		JS_CFUNC_DEF("CheckCollisionPointTriangle",4,js_CheckCollisionPointTriangle),
		JS_CFUNC_DEF("CheckCollisionPointLine",4,js_CheckCollisionPointLine),
		JS_CFUNC_DEF("CheckCollisionPointPoly",3,js_CheckCollisionPointPoly),
		JS_CFUNC_DEF("CheckCollisionLines",5,js_CheckCollisionLines),
		JS_CFUNC_DEF("GetCollisionRec",2,js_GetCollisionRec),
		JS_CFUNC_DEF("LoadImage",1,js_LoadImage),
		JS_CFUNC_DEF("LoadImageRaw",5,js_LoadImageRaw),
		JS_CFUNC_DEF("LoadImageAnim",2,js_LoadImageAnim),
		JS_CFUNC_DEF("LoadImageAnimFromMemory",4,js_LoadImageAnimFromMemory),
		JS_CFUNC_DEF("LoadImageFromMemory",3,js_LoadImageFromMemory),
		JS_CFUNC_DEF("LoadImageFromTexture",1,js_LoadImageFromTexture),
		JS_CFUNC_DEF("LoadImageFromScreen",0,js_LoadImageFromScreen),
		JS_CFUNC_DEF("IsImageValid",1,js_IsImageValid),
		JS_CFUNC_DEF("UnloadImage",1,js_UnloadImage),
		JS_CFUNC_DEF("ExportImage",2,js_ExportImage),
		JS_CFUNC_DEF("ExportImageToMemory",3,js_ExportImageToMemory),
		JS_CFUNC_DEF("ExportImageAsCode",2,js_ExportImageAsCode),
		JS_CFUNC_DEF("GenImageColor",3,js_GenImageColor),
		JS_CFUNC_DEF("GenImageGradientLinear",5,js_GenImageGradientLinear),
		JS_CFUNC_DEF("GenImageGradientRadial",5,js_GenImageGradientRadial),
		JS_CFUNC_DEF("GenImageGradientSquare",5,js_GenImageGradientSquare),
		JS_CFUNC_DEF("GenImageChecked",6,js_GenImageChecked),
		JS_CFUNC_DEF("GenImageWhiteNoise",3,js_GenImageWhiteNoise),
		JS_CFUNC_DEF("GenImagePerlinNoise",5,js_GenImagePerlinNoise),
		JS_CFUNC_DEF("GenImageCellular",3,js_GenImageCellular),
		JS_CFUNC_DEF("GenImageText",3,js_GenImageText),
		JS_CFUNC_DEF("ImageCopy",1,js_ImageCopy),
		JS_CFUNC_DEF("ImageFromImage",2,js_ImageFromImage),
		JS_CFUNC_DEF("ImageFromChannel",2,js_ImageFromChannel),
		JS_CFUNC_DEF("ImageText",3,js_ImageText),
		JS_CFUNC_DEF("ImageTextEx",5,js_ImageTextEx),
		JS_CFUNC_DEF("ImageFormat",2,js_ImageFormat),
		JS_CFUNC_DEF("ImageToPOT",2,js_ImageToPOT),
		JS_CFUNC_DEF("ImageCrop",2,js_ImageCrop),
		JS_CFUNC_DEF("ImageAlphaCrop",2,js_ImageAlphaCrop),
		JS_CFUNC_DEF("ImageAlphaClear",3,js_ImageAlphaClear),
		JS_CFUNC_DEF("ImageAlphaMask",2,js_ImageAlphaMask),
		JS_CFUNC_DEF("ImageAlphaPremultiply",1,js_ImageAlphaPremultiply),
		JS_CFUNC_DEF("ImageBlurGaussian",2,js_ImageBlurGaussian),
		JS_CFUNC_DEF("ImageKernelConvolution",3,js_ImageKernelConvolution),
		JS_CFUNC_DEF("ImageResize",3,js_ImageResize),
		JS_CFUNC_DEF("ImageResizeNN",3,js_ImageResizeNN),
		JS_CFUNC_DEF("ImageResizeCanvas",6,js_ImageResizeCanvas),
		JS_CFUNC_DEF("ImageMipmaps",1,js_ImageMipmaps),
		JS_CFUNC_DEF("ImageDither",5,js_ImageDither),
		JS_CFUNC_DEF("ImageFlipVertical",1,js_ImageFlipVertical),
		JS_CFUNC_DEF("ImageFlipHorizontal",1,js_ImageFlipHorizontal),
		JS_CFUNC_DEF("ImageRotate",2,js_ImageRotate),
		JS_CFUNC_DEF("ImageRotateCW",1,js_ImageRotateCW),
		JS_CFUNC_DEF("ImageRotateCCW",1,js_ImageRotateCCW),
		JS_CFUNC_DEF("ImageColorTint",2,js_ImageColorTint),
		JS_CFUNC_DEF("ImageColorInvert",1,js_ImageColorInvert),
		JS_CFUNC_DEF("ImageColorGrayscale",1,js_ImageColorGrayscale),
		JS_CFUNC_DEF("ImageColorContrast",2,js_ImageColorContrast),
		JS_CFUNC_DEF("ImageColorBrightness",2,js_ImageColorBrightness),
		JS_CFUNC_DEF("ImageColorReplace",3,js_ImageColorReplace),
		JS_CFUNC_DEF("LoadImageColors",1,js_LoadImageColors),
		JS_CFUNC_DEF("LoadImagePalette",3,js_LoadImagePalette),
		JS_CFUNC_DEF("UnloadImageColors",1,js_UnloadImageColors),
		JS_CFUNC_DEF("UnloadImagePalette",1,js_UnloadImagePalette),
		JS_CFUNC_DEF("GetImageAlphaBorder",2,js_GetImageAlphaBorder),
		JS_CFUNC_DEF("GetImageColor",3,js_GetImageColor),
		JS_CFUNC_DEF("ImageClearBackground",2,js_ImageClearBackground),
		JS_CFUNC_DEF("ImageDrawPixel",4,js_ImageDrawPixel),
		JS_CFUNC_DEF("ImageDrawPixelV",3,js_ImageDrawPixelV),
		JS_CFUNC_DEF("ImageDrawLine",6,js_ImageDrawLine),
		JS_CFUNC_DEF("ImageDrawLineV",4,js_ImageDrawLineV),
		JS_CFUNC_DEF("ImageDrawLineEx",5,js_ImageDrawLineEx),
		JS_CFUNC_DEF("ImageDrawCircle",5,js_ImageDrawCircle),
		JS_CFUNC_DEF("ImageDrawCircleV",4,js_ImageDrawCircleV),
		JS_CFUNC_DEF("ImageDrawCircleLines",5,js_ImageDrawCircleLines),
		JS_CFUNC_DEF("ImageDrawCircleLinesV",4,js_ImageDrawCircleLinesV),
		JS_CFUNC_DEF("ImageDrawRectangle",6,js_ImageDrawRectangle),
		JS_CFUNC_DEF("ImageDrawRectangleV",4,js_ImageDrawRectangleV),
		JS_CFUNC_DEF("ImageDrawRectangleRec",3,js_ImageDrawRectangleRec),
		JS_CFUNC_DEF("ImageDrawRectangleLines",4,js_ImageDrawRectangleLines),
		JS_CFUNC_DEF("ImageDrawTriangle",5,js_ImageDrawTriangle),
		JS_CFUNC_DEF("ImageDrawTriangleEx",7,js_ImageDrawTriangleEx),
		JS_CFUNC_DEF("ImageDrawTriangleLines",5,js_ImageDrawTriangleLines),
		JS_CFUNC_DEF("ImageDrawTriangleFan",4,js_ImageDrawTriangleFan),
		JS_CFUNC_DEF("ImageDrawTriangleStrip",4,js_ImageDrawTriangleStrip),
		JS_CFUNC_DEF("ImageDraw",5,js_ImageDraw),
		JS_CFUNC_DEF("ImageDrawText",6,js_ImageDrawText),
		JS_CFUNC_DEF("ImageDrawTextEx",7,js_ImageDrawTextEx),
		JS_CFUNC_DEF("LoadTexture",1,js_LoadTexture),
		JS_CFUNC_DEF("LoadTextureFromImage",1,js_LoadTextureFromImage),
		JS_CFUNC_DEF("LoadTextureCubemap",2,js_LoadTextureCubemap),
		JS_CFUNC_DEF("LoadRenderTexture",2,js_LoadRenderTexture),
		JS_CFUNC_DEF("IsTextureValid",1,js_IsTextureValid),
		JS_CFUNC_DEF("UnloadTexture",1,js_UnloadTexture),
		JS_CFUNC_DEF("IsRenderTextureValid",1,js_IsRenderTextureValid),
		JS_CFUNC_DEF("UnloadRenderTexture",1,js_UnloadRenderTexture),
		JS_CFUNC_DEF("UpdateTexture",2,js_UpdateTexture),
		JS_CFUNC_DEF("UpdateTextureRec",3,js_UpdateTextureRec),
		JS_CFUNC_DEF("GenTextureMipmaps",1,js_GenTextureMipmaps),
		JS_CFUNC_DEF("SetTextureFilter",2,js_SetTextureFilter),
		JS_CFUNC_DEF("SetTextureWrap",2,js_SetTextureWrap),
		JS_CFUNC_DEF("DrawTexture",4,js_DrawTexture),
		JS_CFUNC_DEF("DrawTextureV",3,js_DrawTextureV),
		JS_CFUNC_DEF("DrawTextureEx",5,js_DrawTextureEx),
		JS_CFUNC_DEF("DrawTextureRec",4,js_DrawTextureRec),
		JS_CFUNC_DEF("DrawTexturePro",6,js_DrawTexturePro),
		JS_CFUNC_DEF("DrawTextureNPatch",6,js_DrawTextureNPatch),
		JS_CFUNC_DEF("ColorIsEqual",2,js_ColorIsEqual),
		JS_CFUNC_DEF("Fade",2,js_Fade),
		JS_CFUNC_DEF("ColorToInt",1,js_ColorToInt),
		JS_CFUNC_DEF("ColorNormalize",1,js_ColorNormalize),
		JS_CFUNC_DEF("ColorFromNormalized",1,js_ColorFromNormalized),
		JS_CFUNC_DEF("ColorToHSV",1,js_ColorToHSV),
		JS_CFUNC_DEF("ColorFromHSV",3,js_ColorFromHSV),
		JS_CFUNC_DEF("ColorTint",2,js_ColorTint),
		JS_CFUNC_DEF("ColorBrightness",2,js_ColorBrightness),
		JS_CFUNC_DEF("ColorContrast",2,js_ColorContrast),
		JS_CFUNC_DEF("ColorAlpha",2,js_ColorAlpha),
		JS_CFUNC_DEF("ColorAlphaBlend",3,js_ColorAlphaBlend),
		JS_CFUNC_DEF("ColorLerp",3,js_ColorLerp),
		JS_CFUNC_DEF("GetColor",1,js_GetColor),
		JS_CFUNC_DEF("GetPixelColor",2,js_GetPixelColor),
		JS_CFUNC_DEF("SetPixelColor",3,js_SetPixelColor),
		JS_CFUNC_DEF("GetPixelDataSize",3,js_GetPixelDataSize),
		JS_CFUNC_DEF("GetFontDefault",0,js_GetFontDefault),
		JS_CFUNC_DEF("LoadFont",1,js_LoadFont),
		JS_CFUNC_DEF("LoadFontEx",4,js_LoadFontEx),
		JS_CFUNC_DEF("LoadFontFromImage",3,js_LoadFontFromImage),
		JS_CFUNC_DEF("LoadFontFromMemory",6,js_LoadFontFromMemory),
		JS_CFUNC_DEF("IsFontValid",1,js_IsFontValid),
		JS_CFUNC_DEF("LoadFontData",6,js_LoadFontData),
		JS_CFUNC_DEF("GenImageFontAtlas",6,js_GenImageFontAtlas),
		JS_CFUNC_DEF("UnloadFontData",2,js_UnloadFontData),
		JS_CFUNC_DEF("UnloadFont",1,js_UnloadFont),
		JS_CFUNC_DEF("ExportFontAsCode",2,js_ExportFontAsCode),
		JS_CFUNC_DEF("DrawFPS",2,js_DrawFPS),
		JS_CFUNC_DEF("DrawText",5,js_DrawText),
		JS_CFUNC_DEF("DrawTextEx",6,js_DrawTextEx),
		JS_CFUNC_DEF("DrawTextPro",8,js_DrawTextPro),
		JS_CFUNC_DEF("DrawTextCodepoint",5,js_DrawTextCodepoint),
		JS_CFUNC_DEF("DrawTextCodepoints",7,js_DrawTextCodepoints),
		JS_CFUNC_DEF("SetTextLineSpacing",1,js_SetTextLineSpacing),
		JS_CFUNC_DEF("MeasureText",2,js_MeasureText),
		JS_CFUNC_DEF("MeasureTextEx",4,js_MeasureTextEx),
		JS_CFUNC_DEF("GetGlyphIndex",2,js_GetGlyphIndex),
		JS_CFUNC_DEF("GetGlyphInfo",2,js_GetGlyphInfo),
		JS_CFUNC_DEF("GetGlyphAtlasRec",2,js_GetGlyphAtlasRec),
		JS_CFUNC_DEF("LoadUTF8",2,js_LoadUTF8),
		JS_CFUNC_DEF("UnloadUTF8",1,js_UnloadUTF8),
		JS_CFUNC_DEF("LoadCodepoints",2,js_LoadCodepoints),
		JS_CFUNC_DEF("UnloadCodepoints",1,js_UnloadCodepoints),
		JS_CFUNC_DEF("GetCodepointCount",1,js_GetCodepointCount),
		JS_CFUNC_DEF("GetCodepoint",2,js_GetCodepoint),
		JS_CFUNC_DEF("GetCodepointNext",2,js_GetCodepointNext),
		JS_CFUNC_DEF("GetCodepointPrevious",2,js_GetCodepointPrevious),
		JS_CFUNC_DEF("CodepointToUTF8",2,js_CodepointToUTF8),
		JS_CFUNC_DEF("LoadTextLines",2,js_LoadTextLines),
		JS_CFUNC_DEF("UnloadTextLines",1,js_UnloadTextLines),
		JS_CFUNC_DEF("TextIsEqual",2,js_TextIsEqual),
		JS_CFUNC_DEF("TextLength",1,js_TextLength),
		JS_CFUNC_DEF("TextFormat",2,js_TextFormat),
		JS_CFUNC_DEF("TextSubtext",3,js_TextSubtext),
		JS_CFUNC_DEF("TextReplace",3,js_TextReplace),
		JS_CFUNC_DEF("TextInsert",3,js_TextInsert),
		JS_CFUNC_DEF("TextJoin",3,js_TextJoin),
		JS_CFUNC_DEF("TextSplit",3,js_TextSplit),
		JS_CFUNC_DEF("TextAppend",3,js_TextAppend),
		JS_CFUNC_DEF("TextFindIndex",2,js_TextFindIndex),
		JS_CFUNC_DEF("TextToUpper",1,js_TextToUpper),
		JS_CFUNC_DEF("TextToLower",1,js_TextToLower),
		JS_CFUNC_DEF("TextToPascal",1,js_TextToPascal),
		JS_CFUNC_DEF("TextToSnake",1,js_TextToSnake),
		JS_CFUNC_DEF("TextToCamel",1,js_TextToCamel),
		JS_CFUNC_DEF("TextToInteger",1,js_TextToInteger),
		JS_CFUNC_DEF("TextToFloat",1,js_TextToFloat),
		JS_CFUNC_DEF("DrawLine3D",3,js_DrawLine3D),
		JS_CFUNC_DEF("DrawPoint3D",2,js_DrawPoint3D),
		JS_CFUNC_DEF("DrawCircle3D",5,js_DrawCircle3D),
		JS_CFUNC_DEF("DrawTriangle3D",4,js_DrawTriangle3D),
		JS_CFUNC_DEF("DrawTriangleStrip3D",3,js_DrawTriangleStrip3D),
		JS_CFUNC_DEF("DrawCube",5,js_DrawCube),
		JS_CFUNC_DEF("DrawCubeV",3,js_DrawCubeV),
		JS_CFUNC_DEF("DrawCubeWires",5,js_DrawCubeWires),
		JS_CFUNC_DEF("DrawCubeWiresV",3,js_DrawCubeWiresV),
		JS_CFUNC_DEF("DrawSphere",3,js_DrawSphere),
		JS_CFUNC_DEF("DrawSphereEx",5,js_DrawSphereEx),
		JS_CFUNC_DEF("DrawSphereWires",5,js_DrawSphereWires),
		JS_CFUNC_DEF("DrawCylinder",6,js_DrawCylinder),
		JS_CFUNC_DEF("DrawCylinderEx",6,js_DrawCylinderEx),
		JS_CFUNC_DEF("DrawCylinderWires",6,js_DrawCylinderWires),
		JS_CFUNC_DEF("DrawCylinderWiresEx",6,js_DrawCylinderWiresEx),
		JS_CFUNC_DEF("DrawCapsule",6,js_DrawCapsule),
		JS_CFUNC_DEF("DrawCapsuleWires",6,js_DrawCapsuleWires),
		JS_CFUNC_DEF("DrawPlane",3,js_DrawPlane),
		JS_CFUNC_DEF("DrawRay",2,js_DrawRay),
		JS_CFUNC_DEF("DrawGrid",2,js_DrawGrid),
		JS_CFUNC_DEF("LoadModel",1,js_LoadModel),
		JS_CFUNC_DEF("LoadModelFromMesh",1,js_LoadModelFromMesh),
		JS_CFUNC_DEF("IsModelValid",1,js_IsModelValid),
		JS_CFUNC_DEF("UnloadModel",1,js_UnloadModel),
		JS_CFUNC_DEF("GetModelBoundingBox",1,js_GetModelBoundingBox),
		JS_CFUNC_DEF("DrawModel",4,js_DrawModel),
		JS_CFUNC_DEF("DrawModelEx",6,js_DrawModelEx),
		JS_CFUNC_DEF("DrawModelWires",4,js_DrawModelWires),
		JS_CFUNC_DEF("DrawModelWiresEx",6,js_DrawModelWiresEx),
		JS_CFUNC_DEF("DrawModelPoints",4,js_DrawModelPoints),
		JS_CFUNC_DEF("DrawModelPointsEx",6,js_DrawModelPointsEx),
		JS_CFUNC_DEF("DrawBoundingBox",2,js_DrawBoundingBox),
		JS_CFUNC_DEF("DrawBillboard",5,js_DrawBillboard),
		JS_CFUNC_DEF("DrawBillboardRec",6,js_DrawBillboardRec),
		JS_CFUNC_DEF("DrawBillboardPro",9,js_DrawBillboardPro),
		JS_CFUNC_DEF("UploadMesh",2,js_UploadMesh),
		JS_CFUNC_DEF("UpdateMeshBuffer",5,js_UpdateMeshBuffer),
		JS_CFUNC_DEF("UnloadMesh",1,js_UnloadMesh),
		JS_CFUNC_DEF("DrawMesh",3,js_DrawMesh),
		JS_CFUNC_DEF("DrawMeshInstanced",4,js_DrawMeshInstanced),
		JS_CFUNC_DEF("GetMeshBoundingBox",1,js_GetMeshBoundingBox),
		JS_CFUNC_DEF("GenMeshTangents",1,js_GenMeshTangents),
		JS_CFUNC_DEF("ExportMesh",2,js_ExportMesh),
		JS_CFUNC_DEF("ExportMeshAsCode",2,js_ExportMeshAsCode),
		JS_CFUNC_DEF("GenMeshPoly",2,js_GenMeshPoly),
		JS_CFUNC_DEF("GenMeshPlane",4,js_GenMeshPlane),
		JS_CFUNC_DEF("GenMeshCube",3,js_GenMeshCube),
		JS_CFUNC_DEF("GenMeshSphere",3,js_GenMeshSphere),
		JS_CFUNC_DEF("GenMeshHemiSphere",3,js_GenMeshHemiSphere),
		JS_CFUNC_DEF("GenMeshCylinder",3,js_GenMeshCylinder),
		JS_CFUNC_DEF("GenMeshCone",3,js_GenMeshCone),
		JS_CFUNC_DEF("GenMeshTorus",4,js_GenMeshTorus),
		JS_CFUNC_DEF("GenMeshKnot",4,js_GenMeshKnot),
		JS_CFUNC_DEF("GenMeshHeightmap",2,js_GenMeshHeightmap),
		JS_CFUNC_DEF("GenMeshCubicmap",2,js_GenMeshCubicmap),
		JS_CFUNC_DEF("LoadMaterials",2,js_LoadMaterials),
		JS_CFUNC_DEF("LoadMaterialDefault",0,js_LoadMaterialDefault),
		JS_CFUNC_DEF("IsMaterialValid",1,js_IsMaterialValid),
		JS_CFUNC_DEF("UnloadMaterial",1,js_UnloadMaterial),
		JS_CFUNC_DEF("SetMaterialTexture",3,js_SetMaterialTexture),
		JS_CFUNC_DEF("SetModelMeshMaterial",3,js_SetModelMeshMaterial),
		JS_CFUNC_DEF("LoadModelAnimations",2,js_LoadModelAnimations),
		JS_CFUNC_DEF("UpdateModelAnimation",3,js_UpdateModelAnimation),
		JS_CFUNC_DEF("UpdateModelAnimationBones",3,js_UpdateModelAnimationBones),
		JS_CFUNC_DEF("UnloadModelAnimation",1,js_UnloadModelAnimation),
		JS_CFUNC_DEF("UnloadModelAnimations",2,js_UnloadModelAnimations),
		JS_CFUNC_DEF("IsModelAnimationValid",2,js_IsModelAnimationValid),
		JS_CFUNC_DEF("CheckCollisionSpheres",4,js_CheckCollisionSpheres),
		JS_CFUNC_DEF("CheckCollisionBoxes",2,js_CheckCollisionBoxes),
		JS_CFUNC_DEF("CheckCollisionBoxSphere",3,js_CheckCollisionBoxSphere),
		JS_CFUNC_DEF("GetRayCollisionSphere",3,js_GetRayCollisionSphere),
		JS_CFUNC_DEF("GetRayCollisionBox",2,js_GetRayCollisionBox),
		JS_CFUNC_DEF("GetRayCollisionMesh",3,js_GetRayCollisionMesh),
		JS_CFUNC_DEF("GetRayCollisionTriangle",4,js_GetRayCollisionTriangle),
		JS_CFUNC_DEF("GetRayCollisionQuad",5,js_GetRayCollisionQuad),
		JS_CFUNC_DEF("InitAudioDevice",0,js_InitAudioDevice),
		JS_CFUNC_DEF("CloseAudioDevice",0,js_CloseAudioDevice),
		JS_CFUNC_DEF("IsAudioDeviceReady",0,js_IsAudioDeviceReady),
		JS_CFUNC_DEF("SetMasterVolume",1,js_SetMasterVolume),
		JS_CFUNC_DEF("GetMasterVolume",0,js_GetMasterVolume),
		JS_CFUNC_DEF("LoadWave",1,js_LoadWave),
		JS_CFUNC_DEF("LoadWaveFromMemory",3,js_LoadWaveFromMemory),
		JS_CFUNC_DEF("IsWaveValid",1,js_IsWaveValid),
		JS_CFUNC_DEF("LoadSound",1,js_LoadSound),
		JS_CFUNC_DEF("LoadSoundFromWave",1,js_LoadSoundFromWave),
		JS_CFUNC_DEF("LoadSoundAlias",1,js_LoadSoundAlias),
		JS_CFUNC_DEF("IsSoundValid",1,js_IsSoundValid),
		JS_CFUNC_DEF("UpdateSound",3,js_UpdateSound),
		JS_CFUNC_DEF("UnloadWave",1,js_UnloadWave),
		JS_CFUNC_DEF("UnloadSound",1,js_UnloadSound),
		JS_CFUNC_DEF("UnloadSoundAlias",1,js_UnloadSoundAlias),
		JS_CFUNC_DEF("ExportWave",2,js_ExportWave),
		JS_CFUNC_DEF("ExportWaveAsCode",2,js_ExportWaveAsCode),
		JS_CFUNC_DEF("PlaySound",1,js_PlaySound),
		JS_CFUNC_DEF("StopSound",1,js_StopSound),
		JS_CFUNC_DEF("PauseSound",1,js_PauseSound),
		JS_CFUNC_DEF("ResumeSound",1,js_ResumeSound),
		JS_CFUNC_DEF("IsSoundPlaying",1,js_IsSoundPlaying),
		JS_CFUNC_DEF("SetSoundVolume",2,js_SetSoundVolume),
		JS_CFUNC_DEF("SetSoundPitch",2,js_SetSoundPitch),
		JS_CFUNC_DEF("SetSoundPan",2,js_SetSoundPan),
		JS_CFUNC_DEF("WaveCopy",1,js_WaveCopy),
		JS_CFUNC_DEF("WaveCrop",3,js_WaveCrop),
		JS_CFUNC_DEF("WaveFormat",4,js_WaveFormat),
		JS_CFUNC_DEF("LoadWaveSamples",1,js_LoadWaveSamples),
		JS_CFUNC_DEF("UnloadWaveSamples",1,js_UnloadWaveSamples),
		JS_CFUNC_DEF("LoadMusicStream",1,js_LoadMusicStream),
		JS_CFUNC_DEF("LoadMusicStreamFromMemory",3,js_LoadMusicStreamFromMemory),
		JS_CFUNC_DEF("IsMusicValid",1,js_IsMusicValid),
		JS_CFUNC_DEF("UnloadMusicStream",1,js_UnloadMusicStream),
		JS_CFUNC_DEF("PlayMusicStream",1,js_PlayMusicStream),
		JS_CFUNC_DEF("IsMusicStreamPlaying",1,js_IsMusicStreamPlaying),
		JS_CFUNC_DEF("UpdateMusicStream",1,js_UpdateMusicStream),
		JS_CFUNC_DEF("StopMusicStream",1,js_StopMusicStream),
		JS_CFUNC_DEF("PauseMusicStream",1,js_PauseMusicStream),
		JS_CFUNC_DEF("ResumeMusicStream",1,js_ResumeMusicStream),
		JS_CFUNC_DEF("SeekMusicStream",2,js_SeekMusicStream),
		JS_CFUNC_DEF("SetMusicVolume",2,js_SetMusicVolume),
		JS_CFUNC_DEF("SetMusicPitch",2,js_SetMusicPitch),
		JS_CFUNC_DEF("SetMusicPan",2,js_SetMusicPan),
		JS_CFUNC_DEF("GetMusicTimeLength",1,js_GetMusicTimeLength),
		JS_CFUNC_DEF("GetMusicTimePlayed",1,js_GetMusicTimePlayed),
		JS_CFUNC_DEF("LoadAudioStream",3,js_LoadAudioStream),
		JS_CFUNC_DEF("IsAudioStreamValid",1,js_IsAudioStreamValid),
		JS_CFUNC_DEF("UnloadAudioStream",1,js_UnloadAudioStream),
		JS_CFUNC_DEF("UpdateAudioStream",3,js_UpdateAudioStream),
		JS_CFUNC_DEF("IsAudioStreamProcessed",1,js_IsAudioStreamProcessed),
		JS_CFUNC_DEF("PlayAudioStream",1,js_PlayAudioStream),
		JS_CFUNC_DEF("PauseAudioStream",1,js_PauseAudioStream),
		JS_CFUNC_DEF("ResumeAudioStream",1,js_ResumeAudioStream),
		JS_CFUNC_DEF("IsAudioStreamPlaying",1,js_IsAudioStreamPlaying),
		JS_CFUNC_DEF("StopAudioStream",1,js_StopAudioStream),
		JS_CFUNC_DEF("SetAudioStreamVolume",2,js_SetAudioStreamVolume),
		JS_CFUNC_DEF("SetAudioStreamPitch",2,js_SetAudioStreamPitch),
		JS_CFUNC_DEF("SetAudioStreamPan",2,js_SetAudioStreamPan),
		JS_CFUNC_DEF("SetAudioStreamBufferSizeDefault",1,js_SetAudioStreamBufferSizeDefault),
		JS_CFUNC_DEF("AttachAudioMixedProcessor",1,js_AttachAudioMixedProcessor),
		JS_CFUNC_DEF("DetachAudioMixedProcessor",1,js_DetachAudioMixedProcessor),
		JS_CFUNC_DEF("GetMouseRay",2,js_GetMouseRay)
	};
	
	static int js_js_raylib_init(JSContext * ctx,JSModuleDef * m){
		size_t listcount=countof(jsraylib_funcs);
		JS_SetModuleExportList(ctx,m,jsraylib_funcs,(int)listcount);
		js_declare_Vector2(ctx,m);
		JSValue Vector2_constr=JS_NewCFunction2(ctx,js_Vector2_constructor,(const char *)"Vector2",(int)2,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Vector2",Vector2_constr);
		js_declare_Vector3(ctx,m);
		JSValue Vector3_constr=JS_NewCFunction2(ctx,js_Vector3_constructor,(const char *)"Vector3",(int)3,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Vector3",Vector3_constr);
		js_declare_Vector4(ctx,m);
		JSValue Vector4_constr=JS_NewCFunction2(ctx,js_Vector4_constructor,(const char *)"Vector4",(int)4,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Vector4",Vector4_constr);
		js_declare_Matrix(ctx,m);
		JSValue Matrix_constr=JS_NewCFunction2(ctx,js_Matrix_constructor,(const char *)"Matrix",(int)16,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Matrix",Matrix_constr);
		js_declare_Color(ctx,m);
		JSValue Color_constr=JS_NewCFunction2(ctx,js_Color_constructor,(const char *)"Color",(int)4,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Color",Color_constr);
		js_declare_Rectangle(ctx,m);
		JSValue Rectangle_constr=JS_NewCFunction2(ctx,js_Rectangle_constructor,(const char *)"Rectangle",(int)4,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Rectangle",Rectangle_constr);
		js_declare_Image(ctx,m);
		JSValue Image_constr=JS_NewCFunction2(ctx,js_Image_constructor,(const char *)"Image",(int)5,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Image",Image_constr);
		js_declare_Texture(ctx,m);
		JSValue Texture_constr=JS_NewCFunction2(ctx,js_Texture_constructor,(const char *)"Texture",(int)5,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Texture",Texture_constr);
		js_declare_RenderTexture(ctx,m);
		JSValue RenderTexture_constr=JS_NewCFunction2(ctx,js_RenderTexture_constructor,(const char *)"RenderTexture",(int)3,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"RenderTexture",RenderTexture_constr);
		js_declare_NPatchInfo(ctx,m);
		JSValue NPatchInfo_constr=JS_NewCFunction2(ctx,js_NPatchInfo_constructor,(const char *)"NPatchInfo",(int)6,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"NPatchInfo",NPatchInfo_constr);
		js_declare_GlyphInfo(ctx,m);
		JSValue GlyphInfo_constr=JS_NewCFunction2(ctx,js_GlyphInfo_constructor,(const char *)"GlyphInfo",(int)5,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"GlyphInfo",GlyphInfo_constr);
		js_declare_Font(ctx,m);
		JSValue Font_constr=JS_NewCFunction2(ctx,js_Font_constructor,(const char *)"Font",(int)6,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Font",Font_constr);
		js_declare_Camera3D(ctx,m);
		JSValue Camera3D_constr=JS_NewCFunction2(ctx,js_Camera3D_constructor,(const char *)"Camera3D",(int)5,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Camera3D",Camera3D_constr);
		js_declare_Camera2D(ctx,m);
		JSValue Camera2D_constr=JS_NewCFunction2(ctx,js_Camera2D_constructor,(const char *)"Camera2D",(int)4,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Camera2D",Camera2D_constr);
		js_declare_Mesh(ctx,m);
		JSValue Mesh_constr=JS_NewCFunction2(ctx,js_Mesh_constructor,(const char *)"Mesh",(int)17,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Mesh",Mesh_constr);
		js_declare_Shader(ctx,m);
		JSValue Shader_constr=JS_NewCFunction2(ctx,js_Shader_constructor,(const char *)"Shader",(int)2,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Shader",Shader_constr);
		js_declare_MaterialMap(ctx,m);
		JSValue MaterialMap_constr=JS_NewCFunction2(ctx,js_MaterialMap_constructor,(const char *)"MaterialMap",(int)3,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"MaterialMap",MaterialMap_constr);
		js_declare_Material(ctx,m);
		JSValue Material_constr=JS_NewCFunction2(ctx,js_Material_constructor,(const char *)"Material",(int)3,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Material",Material_constr);
		js_declare_Transform(ctx,m);
		JSValue Transform_constr=JS_NewCFunction2(ctx,js_Transform_constructor,(const char *)"Transform",(int)3,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Transform",Transform_constr);
		js_declare_BoneInfo(ctx,m);
		JSValue BoneInfo_constr=JS_NewCFunction2(ctx,js_BoneInfo_constructor,(const char *)"BoneInfo",(int)2,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"BoneInfo",BoneInfo_constr);
		js_declare_Model(ctx,m);
		JSValue Model_constr=JS_NewCFunction2(ctx,js_Model_constructor,(const char *)"Model",(int)9,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Model",Model_constr);
		js_declare_ModelAnimation(ctx,m);
		JSValue ModelAnimation_constr=JS_NewCFunction2(ctx,js_ModelAnimation_constructor,(const char *)"ModelAnimation",(int)5,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"ModelAnimation",ModelAnimation_constr);
		js_declare_Ray(ctx,m);
		JSValue Ray_constr=JS_NewCFunction2(ctx,js_Ray_constructor,(const char *)"Ray",(int)2,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Ray",Ray_constr);
		js_declare_RayCollision(ctx,m);
		JSValue RayCollision_constr=JS_NewCFunction2(ctx,js_RayCollision_constructor,(const char *)"RayCollision",(int)4,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"RayCollision",RayCollision_constr);
		js_declare_BoundingBox(ctx,m);
		JSValue BoundingBox_constr=JS_NewCFunction2(ctx,js_BoundingBox_constructor,(const char *)"BoundingBox",(int)2,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"BoundingBox",BoundingBox_constr);
		js_declare_Wave(ctx,m);
		JSValue Wave_constr=JS_NewCFunction2(ctx,js_Wave_constructor,(const char *)"Wave",(int)5,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Wave",Wave_constr);
		js_declare_rAudioBuffer(ctx,m);
		js_declare_rAudioProcessor(ctx,m);
		js_declare_AudioStream(ctx,m);
		JSValue AudioStream_constr=JS_NewCFunction2(ctx,js_AudioStream_constructor,(const char *)"AudioStream",(int)5,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"AudioStream",AudioStream_constr);
		js_declare_Sound(ctx,m);
		JSValue Sound_constr=JS_NewCFunction2(ctx,js_Sound_constructor,(const char *)"Sound",(int)2,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Sound",Sound_constr);
		js_declare_Music(ctx,m);
		JSValue Music_constr=JS_NewCFunction2(ctx,js_Music_constructor,(const char *)"Music",(int)5,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"Music",Music_constr);
		js_declare_VrDeviceInfo(ctx,m);
		JSValue VrDeviceInfo_constr=JS_NewCFunction2(ctx,js_VrDeviceInfo_constructor,(const char *)"VrDeviceInfo",(int)9,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"VrDeviceInfo",VrDeviceInfo_constr);
		js_declare_VrStereoConfig(ctx,m);
		JSValue VrStereoConfig_constr=JS_NewCFunction2(ctx,js_VrStereoConfig_constructor,(const char *)"VrStereoConfig",(int)8,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"VrStereoConfig",VrStereoConfig_constr);
		js_declare_FilePathList(ctx,m);
		JSValue FilePathList_constr=JS_NewCFunction2(ctx,js_FilePathList_constructor,(const char *)"FilePathList",(int)3,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"FilePathList",FilePathList_constr);
		js_declare_AutomationEvent(ctx,m);
		JSValue AutomationEvent_constr=JS_NewCFunction2(ctx,js_AutomationEvent_constructor,(const char *)"AutomationEvent",(int)3,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"AutomationEvent",AutomationEvent_constr);
		js_declare_AutomationEventList(ctx,m);
		JSValue AutomationEventList_constr=JS_NewCFunction2(ctx,js_AutomationEventList_constructor,(const char *)"AutomationEventList",(int)3,(JSCFunctionEnum)JS_CFUNC_constructor,(int)0);
		JS_SetModuleExport(ctx,m,(const char *)"AutomationEventList",AutomationEventList_constr);
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_VSYNC_HINT",JS_NewInt32(ctx,(int32_t)FLAG_VSYNC_HINT));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_FULLSCREEN_MODE",JS_NewInt32(ctx,(int32_t)FLAG_FULLSCREEN_MODE));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_WINDOW_RESIZABLE",JS_NewInt32(ctx,(int32_t)FLAG_WINDOW_RESIZABLE));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_WINDOW_UNDECORATED",JS_NewInt32(ctx,(int32_t)FLAG_WINDOW_UNDECORATED));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_WINDOW_HIDDEN",JS_NewInt32(ctx,(int32_t)FLAG_WINDOW_HIDDEN));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_WINDOW_MINIMIZED",JS_NewInt32(ctx,(int32_t)FLAG_WINDOW_MINIMIZED));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_WINDOW_MAXIMIZED",JS_NewInt32(ctx,(int32_t)FLAG_WINDOW_MAXIMIZED));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_WINDOW_UNFOCUSED",JS_NewInt32(ctx,(int32_t)FLAG_WINDOW_UNFOCUSED));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_WINDOW_TOPMOST",JS_NewInt32(ctx,(int32_t)FLAG_WINDOW_TOPMOST));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_WINDOW_ALWAYS_RUN",JS_NewInt32(ctx,(int32_t)FLAG_WINDOW_ALWAYS_RUN));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_WINDOW_TRANSPARENT",JS_NewInt32(ctx,(int32_t)FLAG_WINDOW_TRANSPARENT));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_WINDOW_HIGHDPI",JS_NewInt32(ctx,(int32_t)FLAG_WINDOW_HIGHDPI));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_WINDOW_MOUSE_PASSTHROUGH",JS_NewInt32(ctx,(int32_t)FLAG_WINDOW_MOUSE_PASSTHROUGH));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_BORDERLESS_WINDOWED_MODE",JS_NewInt32(ctx,(int32_t)FLAG_BORDERLESS_WINDOWED_MODE));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_MSAA_4X_HINT",JS_NewInt32(ctx,(int32_t)FLAG_MSAA_4X_HINT));
		JS_SetModuleExport(ctx,m,(const char *)"FLAG_INTERLACED_HINT",JS_NewInt32(ctx,(int32_t)FLAG_INTERLACED_HINT));
		JS_SetModuleExport(ctx,m,(const char *)"LOG_ALL",JS_NewInt32(ctx,(int32_t)LOG_ALL));
		JS_SetModuleExport(ctx,m,(const char *)"LOG_TRACE",JS_NewInt32(ctx,(int32_t)LOG_TRACE));
		JS_SetModuleExport(ctx,m,(const char *)"LOG_DEBUG",JS_NewInt32(ctx,(int32_t)LOG_DEBUG));
		JS_SetModuleExport(ctx,m,(const char *)"LOG_INFO",JS_NewInt32(ctx,(int32_t)LOG_INFO));
		JS_SetModuleExport(ctx,m,(const char *)"LOG_WARNING",JS_NewInt32(ctx,(int32_t)LOG_WARNING));
		JS_SetModuleExport(ctx,m,(const char *)"LOG_ERROR",JS_NewInt32(ctx,(int32_t)LOG_ERROR));
		JS_SetModuleExport(ctx,m,(const char *)"LOG_FATAL",JS_NewInt32(ctx,(int32_t)LOG_FATAL));
		JS_SetModuleExport(ctx,m,(const char *)"LOG_NONE",JS_NewInt32(ctx,(int32_t)LOG_NONE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_NULL",JS_NewInt32(ctx,(int32_t)KEY_NULL));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_APOSTROPHE",JS_NewInt32(ctx,(int32_t)KEY_APOSTROPHE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_COMMA",JS_NewInt32(ctx,(int32_t)KEY_COMMA));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_MINUS",JS_NewInt32(ctx,(int32_t)KEY_MINUS));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_PERIOD",JS_NewInt32(ctx,(int32_t)KEY_PERIOD));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_SLASH",JS_NewInt32(ctx,(int32_t)KEY_SLASH));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_ZERO",JS_NewInt32(ctx,(int32_t)KEY_ZERO));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_ONE",JS_NewInt32(ctx,(int32_t)KEY_ONE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_TWO",JS_NewInt32(ctx,(int32_t)KEY_TWO));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_THREE",JS_NewInt32(ctx,(int32_t)KEY_THREE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_FOUR",JS_NewInt32(ctx,(int32_t)KEY_FOUR));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_FIVE",JS_NewInt32(ctx,(int32_t)KEY_FIVE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_SIX",JS_NewInt32(ctx,(int32_t)KEY_SIX));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_SEVEN",JS_NewInt32(ctx,(int32_t)KEY_SEVEN));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_EIGHT",JS_NewInt32(ctx,(int32_t)KEY_EIGHT));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_NINE",JS_NewInt32(ctx,(int32_t)KEY_NINE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_SEMICOLON",JS_NewInt32(ctx,(int32_t)KEY_SEMICOLON));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_EQUAL",JS_NewInt32(ctx,(int32_t)KEY_EQUAL));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_A",JS_NewInt32(ctx,(int32_t)KEY_A));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_B",JS_NewInt32(ctx,(int32_t)KEY_B));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_C",JS_NewInt32(ctx,(int32_t)KEY_C));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_D",JS_NewInt32(ctx,(int32_t)KEY_D));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_E",JS_NewInt32(ctx,(int32_t)KEY_E));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F",JS_NewInt32(ctx,(int32_t)KEY_F));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_G",JS_NewInt32(ctx,(int32_t)KEY_G));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_H",JS_NewInt32(ctx,(int32_t)KEY_H));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_I",JS_NewInt32(ctx,(int32_t)KEY_I));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_J",JS_NewInt32(ctx,(int32_t)KEY_J));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_K",JS_NewInt32(ctx,(int32_t)KEY_K));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_L",JS_NewInt32(ctx,(int32_t)KEY_L));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_M",JS_NewInt32(ctx,(int32_t)KEY_M));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_N",JS_NewInt32(ctx,(int32_t)KEY_N));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_O",JS_NewInt32(ctx,(int32_t)KEY_O));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_P",JS_NewInt32(ctx,(int32_t)KEY_P));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_Q",JS_NewInt32(ctx,(int32_t)KEY_Q));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_R",JS_NewInt32(ctx,(int32_t)KEY_R));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_S",JS_NewInt32(ctx,(int32_t)KEY_S));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_T",JS_NewInt32(ctx,(int32_t)KEY_T));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_U",JS_NewInt32(ctx,(int32_t)KEY_U));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_V",JS_NewInt32(ctx,(int32_t)KEY_V));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_W",JS_NewInt32(ctx,(int32_t)KEY_W));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_X",JS_NewInt32(ctx,(int32_t)KEY_X));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_Y",JS_NewInt32(ctx,(int32_t)KEY_Y));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_Z",JS_NewInt32(ctx,(int32_t)KEY_Z));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_LEFT_BRACKET",JS_NewInt32(ctx,(int32_t)KEY_LEFT_BRACKET));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_BACKSLASH",JS_NewInt32(ctx,(int32_t)KEY_BACKSLASH));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_RIGHT_BRACKET",JS_NewInt32(ctx,(int32_t)KEY_RIGHT_BRACKET));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_GRAVE",JS_NewInt32(ctx,(int32_t)KEY_GRAVE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_SPACE",JS_NewInt32(ctx,(int32_t)KEY_SPACE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_ESCAPE",JS_NewInt32(ctx,(int32_t)KEY_ESCAPE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_ENTER",JS_NewInt32(ctx,(int32_t)KEY_ENTER));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_TAB",JS_NewInt32(ctx,(int32_t)KEY_TAB));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_BACKSPACE",JS_NewInt32(ctx,(int32_t)KEY_BACKSPACE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_INSERT",JS_NewInt32(ctx,(int32_t)KEY_INSERT));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_DELETE",JS_NewInt32(ctx,(int32_t)KEY_DELETE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_RIGHT",JS_NewInt32(ctx,(int32_t)KEY_RIGHT));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_LEFT",JS_NewInt32(ctx,(int32_t)KEY_LEFT));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_DOWN",JS_NewInt32(ctx,(int32_t)KEY_DOWN));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_UP",JS_NewInt32(ctx,(int32_t)KEY_UP));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_PAGE_UP",JS_NewInt32(ctx,(int32_t)KEY_PAGE_UP));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_PAGE_DOWN",JS_NewInt32(ctx,(int32_t)KEY_PAGE_DOWN));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_HOME",JS_NewInt32(ctx,(int32_t)KEY_HOME));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_END",JS_NewInt32(ctx,(int32_t)KEY_END));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_CAPS_LOCK",JS_NewInt32(ctx,(int32_t)KEY_CAPS_LOCK));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_SCROLL_LOCK",JS_NewInt32(ctx,(int32_t)KEY_SCROLL_LOCK));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_NUM_LOCK",JS_NewInt32(ctx,(int32_t)KEY_NUM_LOCK));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_PRINT_SCREEN",JS_NewInt32(ctx,(int32_t)KEY_PRINT_SCREEN));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_PAUSE",JS_NewInt32(ctx,(int32_t)KEY_PAUSE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F1",JS_NewInt32(ctx,(int32_t)KEY_F1));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F2",JS_NewInt32(ctx,(int32_t)KEY_F2));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F3",JS_NewInt32(ctx,(int32_t)KEY_F3));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F4",JS_NewInt32(ctx,(int32_t)KEY_F4));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F5",JS_NewInt32(ctx,(int32_t)KEY_F5));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F6",JS_NewInt32(ctx,(int32_t)KEY_F6));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F7",JS_NewInt32(ctx,(int32_t)KEY_F7));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F8",JS_NewInt32(ctx,(int32_t)KEY_F8));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F9",JS_NewInt32(ctx,(int32_t)KEY_F9));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F10",JS_NewInt32(ctx,(int32_t)KEY_F10));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F11",JS_NewInt32(ctx,(int32_t)KEY_F11));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_F12",JS_NewInt32(ctx,(int32_t)KEY_F12));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_LEFT_SHIFT",JS_NewInt32(ctx,(int32_t)KEY_LEFT_SHIFT));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_LEFT_CONTROL",JS_NewInt32(ctx,(int32_t)KEY_LEFT_CONTROL));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_LEFT_ALT",JS_NewInt32(ctx,(int32_t)KEY_LEFT_ALT));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_LEFT_SUPER",JS_NewInt32(ctx,(int32_t)KEY_LEFT_SUPER));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_RIGHT_SHIFT",JS_NewInt32(ctx,(int32_t)KEY_RIGHT_SHIFT));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_RIGHT_CONTROL",JS_NewInt32(ctx,(int32_t)KEY_RIGHT_CONTROL));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_RIGHT_ALT",JS_NewInt32(ctx,(int32_t)KEY_RIGHT_ALT));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_RIGHT_SUPER",JS_NewInt32(ctx,(int32_t)KEY_RIGHT_SUPER));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KB_MENU",JS_NewInt32(ctx,(int32_t)KEY_KB_MENU));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_0",JS_NewInt32(ctx,(int32_t)KEY_KP_0));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_1",JS_NewInt32(ctx,(int32_t)KEY_KP_1));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_2",JS_NewInt32(ctx,(int32_t)KEY_KP_2));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_3",JS_NewInt32(ctx,(int32_t)KEY_KP_3));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_4",JS_NewInt32(ctx,(int32_t)KEY_KP_4));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_5",JS_NewInt32(ctx,(int32_t)KEY_KP_5));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_6",JS_NewInt32(ctx,(int32_t)KEY_KP_6));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_7",JS_NewInt32(ctx,(int32_t)KEY_KP_7));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_8",JS_NewInt32(ctx,(int32_t)KEY_KP_8));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_9",JS_NewInt32(ctx,(int32_t)KEY_KP_9));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_DECIMAL",JS_NewInt32(ctx,(int32_t)KEY_KP_DECIMAL));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_DIVIDE",JS_NewInt32(ctx,(int32_t)KEY_KP_DIVIDE));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_MULTIPLY",JS_NewInt32(ctx,(int32_t)KEY_KP_MULTIPLY));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_SUBTRACT",JS_NewInt32(ctx,(int32_t)KEY_KP_SUBTRACT));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_ADD",JS_NewInt32(ctx,(int32_t)KEY_KP_ADD));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_ENTER",JS_NewInt32(ctx,(int32_t)KEY_KP_ENTER));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_KP_EQUAL",JS_NewInt32(ctx,(int32_t)KEY_KP_EQUAL));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_BACK",JS_NewInt32(ctx,(int32_t)KEY_BACK));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_MENU",JS_NewInt32(ctx,(int32_t)KEY_MENU));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_VOLUME_UP",JS_NewInt32(ctx,(int32_t)KEY_VOLUME_UP));
		JS_SetModuleExport(ctx,m,(const char *)"KEY_VOLUME_DOWN",JS_NewInt32(ctx,(int32_t)KEY_VOLUME_DOWN));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_LEFT",JS_NewInt32(ctx,(int32_t)MOUSE_BUTTON_LEFT));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_RIGHT",JS_NewInt32(ctx,(int32_t)MOUSE_BUTTON_RIGHT));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_MIDDLE",JS_NewInt32(ctx,(int32_t)MOUSE_BUTTON_MIDDLE));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_SIDE",JS_NewInt32(ctx,(int32_t)MOUSE_BUTTON_SIDE));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_EXTRA",JS_NewInt32(ctx,(int32_t)MOUSE_BUTTON_EXTRA));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_FORWARD",JS_NewInt32(ctx,(int32_t)MOUSE_BUTTON_FORWARD));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_BACK",JS_NewInt32(ctx,(int32_t)MOUSE_BUTTON_BACK));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_LEFT_BUTTON",JS_NewInt32(ctx,(int32_t)MOUSE_LEFT_BUTTON));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_RIGHT_BUTTON",JS_NewInt32(ctx,(int32_t)MOUSE_RIGHT_BUTTON));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_MIDDLE_BUTTON",JS_NewInt32(ctx,(int32_t)MOUSE_MIDDLE_BUTTON));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_DEFAULT",JS_NewInt32(ctx,(int32_t)MOUSE_CURSOR_DEFAULT));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_ARROW",JS_NewInt32(ctx,(int32_t)MOUSE_CURSOR_ARROW));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_IBEAM",JS_NewInt32(ctx,(int32_t)MOUSE_CURSOR_IBEAM));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_CROSSHAIR",JS_NewInt32(ctx,(int32_t)MOUSE_CURSOR_CROSSHAIR));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_POINTING_HAND",JS_NewInt32(ctx,(int32_t)MOUSE_CURSOR_POINTING_HAND));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_RESIZE_EW",JS_NewInt32(ctx,(int32_t)MOUSE_CURSOR_RESIZE_EW));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_RESIZE_NS",JS_NewInt32(ctx,(int32_t)MOUSE_CURSOR_RESIZE_NS));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_RESIZE_NWSE",JS_NewInt32(ctx,(int32_t)MOUSE_CURSOR_RESIZE_NWSE));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_RESIZE_NESW",JS_NewInt32(ctx,(int32_t)MOUSE_CURSOR_RESIZE_NESW));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_RESIZE_ALL",JS_NewInt32(ctx,(int32_t)MOUSE_CURSOR_RESIZE_ALL));
		JS_SetModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_NOT_ALLOWED",JS_NewInt32(ctx,(int32_t)MOUSE_CURSOR_NOT_ALLOWED));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_UNKNOWN",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_UNKNOWN));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_FACE_UP",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_LEFT_FACE_UP));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_FACE_RIGHT",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_LEFT_FACE_RIGHT));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_FACE_DOWN",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_LEFT_FACE_DOWN));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_FACE_LEFT",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_LEFT_FACE_LEFT));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_FACE_UP",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_RIGHT_FACE_UP));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_FACE_RIGHT",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_RIGHT_FACE_RIGHT));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_FACE_DOWN",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_RIGHT_FACE_DOWN));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_FACE_LEFT",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_RIGHT_FACE_LEFT));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_TRIGGER_1",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_LEFT_TRIGGER_1));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_TRIGGER_2",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_LEFT_TRIGGER_2));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_TRIGGER_1",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_RIGHT_TRIGGER_1));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_TRIGGER_2",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_RIGHT_TRIGGER_2));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_MIDDLE_LEFT",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_MIDDLE_LEFT));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_MIDDLE",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_MIDDLE));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_MIDDLE_RIGHT",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_MIDDLE_RIGHT));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_THUMB",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_LEFT_THUMB));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_THUMB",JS_NewInt32(ctx,(int32_t)GAMEPAD_BUTTON_RIGHT_THUMB));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_AXIS_LEFT_X",JS_NewInt32(ctx,(int32_t)GAMEPAD_AXIS_LEFT_X));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_AXIS_LEFT_Y",JS_NewInt32(ctx,(int32_t)GAMEPAD_AXIS_LEFT_Y));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_AXIS_RIGHT_X",JS_NewInt32(ctx,(int32_t)GAMEPAD_AXIS_RIGHT_X));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_AXIS_RIGHT_Y",JS_NewInt32(ctx,(int32_t)GAMEPAD_AXIS_RIGHT_Y));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_AXIS_LEFT_TRIGGER",JS_NewInt32(ctx,(int32_t)GAMEPAD_AXIS_LEFT_TRIGGER));
		JS_SetModuleExport(ctx,m,(const char *)"GAMEPAD_AXIS_RIGHT_TRIGGER",JS_NewInt32(ctx,(int32_t)GAMEPAD_AXIS_RIGHT_TRIGGER));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_ALBEDO",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_ALBEDO));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_METALNESS",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_METALNESS));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_NORMAL",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_NORMAL));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_ROUGHNESS",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_ROUGHNESS));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_OCCLUSION",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_OCCLUSION));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_EMISSION",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_EMISSION));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_HEIGHT",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_HEIGHT));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_CUBEMAP",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_CUBEMAP));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_IRRADIANCE",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_IRRADIANCE));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_PREFILTER",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_PREFILTER));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_BRDF",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_BRDF));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_DIFFUSE",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_DIFFUSE));
		JS_SetModuleExport(ctx,m,(const char *)"MATERIAL_MAP_SPECULAR",JS_NewInt32(ctx,(int32_t)MATERIAL_MAP_SPECULAR));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_POSITION",JS_NewInt32(ctx,(int32_t)SHADER_LOC_VERTEX_POSITION));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_TEXCOORD01",JS_NewInt32(ctx,(int32_t)SHADER_LOC_VERTEX_TEXCOORD01));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_TEXCOORD02",JS_NewInt32(ctx,(int32_t)SHADER_LOC_VERTEX_TEXCOORD02));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_NORMAL",JS_NewInt32(ctx,(int32_t)SHADER_LOC_VERTEX_NORMAL));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_TANGENT",JS_NewInt32(ctx,(int32_t)SHADER_LOC_VERTEX_TANGENT));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_COLOR",JS_NewInt32(ctx,(int32_t)SHADER_LOC_VERTEX_COLOR));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MATRIX_MVP",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MATRIX_MVP));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MATRIX_VIEW",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MATRIX_VIEW));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MATRIX_PROJECTION",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MATRIX_PROJECTION));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MATRIX_MODEL",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MATRIX_MODEL));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MATRIX_NORMAL",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MATRIX_NORMAL));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_VECTOR_VIEW",JS_NewInt32(ctx,(int32_t)SHADER_LOC_VECTOR_VIEW));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_COLOR_DIFFUSE",JS_NewInt32(ctx,(int32_t)SHADER_LOC_COLOR_DIFFUSE));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_COLOR_SPECULAR",JS_NewInt32(ctx,(int32_t)SHADER_LOC_COLOR_SPECULAR));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_COLOR_AMBIENT",JS_NewInt32(ctx,(int32_t)SHADER_LOC_COLOR_AMBIENT));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_ALBEDO",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_ALBEDO));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_METALNESS",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_METALNESS));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_NORMAL",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_NORMAL));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_ROUGHNESS",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_ROUGHNESS));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_OCCLUSION",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_OCCLUSION));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_EMISSION",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_EMISSION));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_HEIGHT",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_HEIGHT));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_CUBEMAP",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_CUBEMAP));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_IRRADIANCE",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_IRRADIANCE));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_PREFILTER",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_PREFILTER));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_BRDF",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_BRDF));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_BONEIDS",JS_NewInt32(ctx,(int32_t)SHADER_LOC_VERTEX_BONEIDS));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_BONEWEIGHTS",JS_NewInt32(ctx,(int32_t)SHADER_LOC_VERTEX_BONEWEIGHTS));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_BONE_MATRICES",JS_NewInt32(ctx,(int32_t)SHADER_LOC_BONE_MATRICES));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_INSTANCE_TX",JS_NewInt32(ctx,(int32_t)SHADER_LOC_VERTEX_INSTANCE_TX));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_DIFFUSE",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_DIFFUSE));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_SPECULAR",JS_NewInt32(ctx,(int32_t)SHADER_LOC_MAP_SPECULAR));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_FLOAT",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_FLOAT));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_VEC2",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_VEC2));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_VEC3",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_VEC3));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_VEC4",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_VEC4));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_INT",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_INT));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_IVEC2",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_IVEC2));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_IVEC3",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_IVEC3));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_IVEC4",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_IVEC4));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_UINT",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_UINT));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_UIVEC2",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_UIVEC2));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_UIVEC3",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_UIVEC3));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_UIVEC4",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_UIVEC4));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_SAMPLER2D",JS_NewInt32(ctx,(int32_t)SHADER_UNIFORM_SAMPLER2D));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_ATTRIB_FLOAT",JS_NewInt32(ctx,(int32_t)SHADER_ATTRIB_FLOAT));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_ATTRIB_VEC2",JS_NewInt32(ctx,(int32_t)SHADER_ATTRIB_VEC2));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_ATTRIB_VEC3",JS_NewInt32(ctx,(int32_t)SHADER_ATTRIB_VEC3));
		JS_SetModuleExport(ctx,m,(const char *)"SHADER_ATTRIB_VEC4",JS_NewInt32(ctx,(int32_t)SHADER_ATTRIB_VEC4));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_GRAYSCALE",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_GRAYSCALE));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R5G6B5",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_R5G6B5));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R8G8B8",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_R8G8B8));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R5G5B5A1",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_R5G5B5A1));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R4G4B4A4",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_R4G4B4A4));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R8G8B8A8",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_R8G8B8A8));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R32",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_R32));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R32G32B32",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_R32G32B32));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R32G32B32A32",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_R32G32B32A32));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R16",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_R16));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R16G16B16",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_R16G16B16));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R16G16B16A16",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_UNCOMPRESSED_R16G16B16A16));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_DXT1_RGB",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_COMPRESSED_DXT1_RGB));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_DXT1_RGBA",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_COMPRESSED_DXT1_RGBA));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_DXT3_RGBA",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_COMPRESSED_DXT3_RGBA));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_DXT5_RGBA",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_COMPRESSED_DXT5_RGBA));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_ETC1_RGB",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_COMPRESSED_ETC1_RGB));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_ETC2_RGB",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_COMPRESSED_ETC2_RGB));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_PVRT_RGB",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_COMPRESSED_PVRT_RGB));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_PVRT_RGBA",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_COMPRESSED_PVRT_RGBA));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA));
		JS_SetModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA",JS_NewInt32(ctx,(int32_t)PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA));
		JS_SetModuleExport(ctx,m,(const char *)"TEXTURE_FILTER_POINT",JS_NewInt32(ctx,(int32_t)TEXTURE_FILTER_POINT));
		JS_SetModuleExport(ctx,m,(const char *)"TEXTURE_FILTER_BILINEAR",JS_NewInt32(ctx,(int32_t)TEXTURE_FILTER_BILINEAR));
		JS_SetModuleExport(ctx,m,(const char *)"TEXTURE_FILTER_TRILINEAR",JS_NewInt32(ctx,(int32_t)TEXTURE_FILTER_TRILINEAR));
		JS_SetModuleExport(ctx,m,(const char *)"TEXTURE_FILTER_ANISOTROPIC_4X",JS_NewInt32(ctx,(int32_t)TEXTURE_FILTER_ANISOTROPIC_4X));
		JS_SetModuleExport(ctx,m,(const char *)"TEXTURE_FILTER_ANISOTROPIC_8X",JS_NewInt32(ctx,(int32_t)TEXTURE_FILTER_ANISOTROPIC_8X));
		JS_SetModuleExport(ctx,m,(const char *)"TEXTURE_FILTER_ANISOTROPIC_16X",JS_NewInt32(ctx,(int32_t)TEXTURE_FILTER_ANISOTROPIC_16X));
		JS_SetModuleExport(ctx,m,(const char *)"TEXTURE_WRAP_REPEAT",JS_NewInt32(ctx,(int32_t)TEXTURE_WRAP_REPEAT));
		JS_SetModuleExport(ctx,m,(const char *)"TEXTURE_WRAP_CLAMP",JS_NewInt32(ctx,(int32_t)TEXTURE_WRAP_CLAMP));
		JS_SetModuleExport(ctx,m,(const char *)"TEXTURE_WRAP_MIRROR_REPEAT",JS_NewInt32(ctx,(int32_t)TEXTURE_WRAP_MIRROR_REPEAT));
		JS_SetModuleExport(ctx,m,(const char *)"TEXTURE_WRAP_MIRROR_CLAMP",JS_NewInt32(ctx,(int32_t)TEXTURE_WRAP_MIRROR_CLAMP));
		JS_SetModuleExport(ctx,m,(const char *)"CUBEMAP_LAYOUT_AUTO_DETECT",JS_NewInt32(ctx,(int32_t)CUBEMAP_LAYOUT_AUTO_DETECT));
		JS_SetModuleExport(ctx,m,(const char *)"CUBEMAP_LAYOUT_LINE_VERTICAL",JS_NewInt32(ctx,(int32_t)CUBEMAP_LAYOUT_LINE_VERTICAL));
		JS_SetModuleExport(ctx,m,(const char *)"CUBEMAP_LAYOUT_LINE_HORIZONTAL",JS_NewInt32(ctx,(int32_t)CUBEMAP_LAYOUT_LINE_HORIZONTAL));
		JS_SetModuleExport(ctx,m,(const char *)"CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR",JS_NewInt32(ctx,(int32_t)CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR));
		JS_SetModuleExport(ctx,m,(const char *)"CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE",JS_NewInt32(ctx,(int32_t)CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE));
		JS_SetModuleExport(ctx,m,(const char *)"FONT_DEFAULT",JS_NewInt32(ctx,(int32_t)FONT_DEFAULT));
		JS_SetModuleExport(ctx,m,(const char *)"FONT_BITMAP",JS_NewInt32(ctx,(int32_t)FONT_BITMAP));
		JS_SetModuleExport(ctx,m,(const char *)"FONT_SDF",JS_NewInt32(ctx,(int32_t)FONT_SDF));
		JS_SetModuleExport(ctx,m,(const char *)"BLEND_ALPHA",JS_NewInt32(ctx,(int32_t)BLEND_ALPHA));
		JS_SetModuleExport(ctx,m,(const char *)"BLEND_ADDITIVE",JS_NewInt32(ctx,(int32_t)BLEND_ADDITIVE));
		JS_SetModuleExport(ctx,m,(const char *)"BLEND_MULTIPLIED",JS_NewInt32(ctx,(int32_t)BLEND_MULTIPLIED));
		JS_SetModuleExport(ctx,m,(const char *)"BLEND_ADD_COLORS",JS_NewInt32(ctx,(int32_t)BLEND_ADD_COLORS));
		JS_SetModuleExport(ctx,m,(const char *)"BLEND_SUBTRACT_COLORS",JS_NewInt32(ctx,(int32_t)BLEND_SUBTRACT_COLORS));
		JS_SetModuleExport(ctx,m,(const char *)"BLEND_ALPHA_PREMULTIPLY",JS_NewInt32(ctx,(int32_t)BLEND_ALPHA_PREMULTIPLY));
		JS_SetModuleExport(ctx,m,(const char *)"BLEND_CUSTOM",JS_NewInt32(ctx,(int32_t)BLEND_CUSTOM));
		JS_SetModuleExport(ctx,m,(const char *)"BLEND_CUSTOM_SEPARATE",JS_NewInt32(ctx,(int32_t)BLEND_CUSTOM_SEPARATE));
		JS_SetModuleExport(ctx,m,(const char *)"GESTURE_NONE",JS_NewInt32(ctx,(int32_t)GESTURE_NONE));
		JS_SetModuleExport(ctx,m,(const char *)"GESTURE_TAP",JS_NewInt32(ctx,(int32_t)GESTURE_TAP));
		JS_SetModuleExport(ctx,m,(const char *)"GESTURE_DOUBLETAP",JS_NewInt32(ctx,(int32_t)GESTURE_DOUBLETAP));
		JS_SetModuleExport(ctx,m,(const char *)"GESTURE_HOLD",JS_NewInt32(ctx,(int32_t)GESTURE_HOLD));
		JS_SetModuleExport(ctx,m,(const char *)"GESTURE_DRAG",JS_NewInt32(ctx,(int32_t)GESTURE_DRAG));
		JS_SetModuleExport(ctx,m,(const char *)"GESTURE_SWIPE_RIGHT",JS_NewInt32(ctx,(int32_t)GESTURE_SWIPE_RIGHT));
		JS_SetModuleExport(ctx,m,(const char *)"GESTURE_SWIPE_LEFT",JS_NewInt32(ctx,(int32_t)GESTURE_SWIPE_LEFT));
		JS_SetModuleExport(ctx,m,(const char *)"GESTURE_SWIPE_UP",JS_NewInt32(ctx,(int32_t)GESTURE_SWIPE_UP));
		JS_SetModuleExport(ctx,m,(const char *)"GESTURE_SWIPE_DOWN",JS_NewInt32(ctx,(int32_t)GESTURE_SWIPE_DOWN));
		JS_SetModuleExport(ctx,m,(const char *)"GESTURE_PINCH_IN",JS_NewInt32(ctx,(int32_t)GESTURE_PINCH_IN));
		JS_SetModuleExport(ctx,m,(const char *)"GESTURE_PINCH_OUT",JS_NewInt32(ctx,(int32_t)GESTURE_PINCH_OUT));
		JS_SetModuleExport(ctx,m,(const char *)"CAMERA_CUSTOM",JS_NewInt32(ctx,(int32_t)CAMERA_CUSTOM));
		JS_SetModuleExport(ctx,m,(const char *)"CAMERA_FREE",JS_NewInt32(ctx,(int32_t)CAMERA_FREE));
		JS_SetModuleExport(ctx,m,(const char *)"CAMERA_ORBITAL",JS_NewInt32(ctx,(int32_t)CAMERA_ORBITAL));
		JS_SetModuleExport(ctx,m,(const char *)"CAMERA_FIRST_PERSON",JS_NewInt32(ctx,(int32_t)CAMERA_FIRST_PERSON));
		JS_SetModuleExport(ctx,m,(const char *)"CAMERA_THIRD_PERSON",JS_NewInt32(ctx,(int32_t)CAMERA_THIRD_PERSON));
		JS_SetModuleExport(ctx,m,(const char *)"CAMERA_PERSPECTIVE",JS_NewInt32(ctx,(int32_t)CAMERA_PERSPECTIVE));
		JS_SetModuleExport(ctx,m,(const char *)"CAMERA_ORTHOGRAPHIC",JS_NewInt32(ctx,(int32_t)CAMERA_ORTHOGRAPHIC));
		JS_SetModuleExport(ctx,m,(const char *)"NPATCH_NINE_PATCH",JS_NewInt32(ctx,(int32_t)NPATCH_NINE_PATCH));
		JS_SetModuleExport(ctx,m,(const char *)"NPATCH_THREE_PATCH_VERTICAL",JS_NewInt32(ctx,(int32_t)NPATCH_THREE_PATCH_VERTICAL));
		JS_SetModuleExport(ctx,m,(const char *)"NPATCH_THREE_PATCH_HORIZONTAL",JS_NewInt32(ctx,(int32_t)NPATCH_THREE_PATCH_HORIZONTAL));
		JS_SetModuleExport(ctx,m,(const char *)"RAYLIB_VERSION_MAJOR",JS_NewInt32(ctx,(int32_t)RAYLIB_VERSION_MAJOR));
		JS_SetModuleExport(ctx,m,(const char *)"RAYLIB_VERSION_MINOR",JS_NewInt32(ctx,(int32_t)RAYLIB_VERSION_MINOR));
		JS_SetModuleExport(ctx,m,(const char *)"RAYLIB_VERSION_PATCH",JS_NewInt32(ctx,(int32_t)RAYLIB_VERSION_PATCH));
		JS_SetModuleExport(ctx,m,(const char *)"PI",JS_NewFloat64(ctx,(double)PI));
		JS_SetModuleExport(ctx,m,(const char *)"DEG2RAD",JS_NewFloat64(ctx,(double)DEG2RAD));
		JS_SetModuleExport(ctx,m,(const char *)"RAD2DEG",JS_NewFloat64(ctx,(double)RAD2DEG));
		Color LIGHTGRAY_struct={
			200,
			200,
			200,
			255
		};
		Color * ptr_LIGHTGRAY_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_LIGHTGRAY_js[0]=LIGHTGRAY_struct;
		JSValue LIGHTGRAY_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(LIGHTGRAY_js,(void *)ptr_LIGHTGRAY_js);
		JS_SetModuleExport(ctx,m,(const char *)"LIGHTGRAY",LIGHTGRAY_js);
		Color GRAY_struct={
			130,
			130,
			130,
			255
		};
		Color * ptr_GRAY_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_GRAY_js[0]=GRAY_struct;
		JSValue GRAY_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(GRAY_js,(void *)ptr_GRAY_js);
		JS_SetModuleExport(ctx,m,(const char *)"GRAY",GRAY_js);
		Color DARKGRAY_struct={
			80,
			80,
			80,
			255
		};
		Color * ptr_DARKGRAY_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_DARKGRAY_js[0]=DARKGRAY_struct;
		JSValue DARKGRAY_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(DARKGRAY_js,(void *)ptr_DARKGRAY_js);
		JS_SetModuleExport(ctx,m,(const char *)"DARKGRAY",DARKGRAY_js);
		Color YELLOW_struct={
			253,
			249,
			0,
			255
		};
		Color * ptr_YELLOW_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_YELLOW_js[0]=YELLOW_struct;
		JSValue YELLOW_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(YELLOW_js,(void *)ptr_YELLOW_js);
		JS_SetModuleExport(ctx,m,(const char *)"YELLOW",YELLOW_js);
		Color GOLD_struct={
			255,
			203,
			0,
			255
		};
		Color * ptr_GOLD_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_GOLD_js[0]=GOLD_struct;
		JSValue GOLD_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(GOLD_js,(void *)ptr_GOLD_js);
		JS_SetModuleExport(ctx,m,(const char *)"GOLD",GOLD_js);
		Color ORANGE_struct={
			255,
			161,
			0,
			255
		};
		Color * ptr_ORANGE_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_ORANGE_js[0]=ORANGE_struct;
		JSValue ORANGE_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(ORANGE_js,(void *)ptr_ORANGE_js);
		JS_SetModuleExport(ctx,m,(const char *)"ORANGE",ORANGE_js);
		Color PINK_struct={
			255,
			109,
			194,
			255
		};
		Color * ptr_PINK_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_PINK_js[0]=PINK_struct;
		JSValue PINK_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(PINK_js,(void *)ptr_PINK_js);
		JS_SetModuleExport(ctx,m,(const char *)"PINK",PINK_js);
		Color RED_struct={
			230,
			41,
			55,
			255
		};
		Color * ptr_RED_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_RED_js[0]=RED_struct;
		JSValue RED_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(RED_js,(void *)ptr_RED_js);
		JS_SetModuleExport(ctx,m,(const char *)"RED",RED_js);
		Color MAROON_struct={
			190,
			33,
			55,
			255
		};
		Color * ptr_MAROON_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_MAROON_js[0]=MAROON_struct;
		JSValue MAROON_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(MAROON_js,(void *)ptr_MAROON_js);
		JS_SetModuleExport(ctx,m,(const char *)"MAROON",MAROON_js);
		Color GREEN_struct={
			0,
			228,
			48,
			255
		};
		Color * ptr_GREEN_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_GREEN_js[0]=GREEN_struct;
		JSValue GREEN_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(GREEN_js,(void *)ptr_GREEN_js);
		JS_SetModuleExport(ctx,m,(const char *)"GREEN",GREEN_js);
		Color LIME_struct={
			0,
			158,
			47,
			255
		};
		Color * ptr_LIME_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_LIME_js[0]=LIME_struct;
		JSValue LIME_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(LIME_js,(void *)ptr_LIME_js);
		JS_SetModuleExport(ctx,m,(const char *)"LIME",LIME_js);
		Color DARKGREEN_struct={
			0,
			117,
			44,
			255
		};
		Color * ptr_DARKGREEN_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_DARKGREEN_js[0]=DARKGREEN_struct;
		JSValue DARKGREEN_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(DARKGREEN_js,(void *)ptr_DARKGREEN_js);
		JS_SetModuleExport(ctx,m,(const char *)"DARKGREEN",DARKGREEN_js);
		Color SKYBLUE_struct={
			102,
			191,
			255,
			255
		};
		Color * ptr_SKYBLUE_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_SKYBLUE_js[0]=SKYBLUE_struct;
		JSValue SKYBLUE_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(SKYBLUE_js,(void *)ptr_SKYBLUE_js);
		JS_SetModuleExport(ctx,m,(const char *)"SKYBLUE",SKYBLUE_js);
		Color BLUE_struct={
			0,
			121,
			241,
			255
		};
		Color * ptr_BLUE_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_BLUE_js[0]=BLUE_struct;
		JSValue BLUE_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(BLUE_js,(void *)ptr_BLUE_js);
		JS_SetModuleExport(ctx,m,(const char *)"BLUE",BLUE_js);
		Color DARKBLUE_struct={
			0,
			82,
			172,
			255
		};
		Color * ptr_DARKBLUE_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_DARKBLUE_js[0]=DARKBLUE_struct;
		JSValue DARKBLUE_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(DARKBLUE_js,(void *)ptr_DARKBLUE_js);
		JS_SetModuleExport(ctx,m,(const char *)"DARKBLUE",DARKBLUE_js);
		Color PURPLE_struct={
			200,
			122,
			255,
			255
		};
		Color * ptr_PURPLE_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_PURPLE_js[0]=PURPLE_struct;
		JSValue PURPLE_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(PURPLE_js,(void *)ptr_PURPLE_js);
		JS_SetModuleExport(ctx,m,(const char *)"PURPLE",PURPLE_js);
		Color VIOLET_struct={
			135,
			60,
			190,
			255
		};
		Color * ptr_VIOLET_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_VIOLET_js[0]=VIOLET_struct;
		JSValue VIOLET_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(VIOLET_js,(void *)ptr_VIOLET_js);
		JS_SetModuleExport(ctx,m,(const char *)"VIOLET",VIOLET_js);
		Color DARKPURPLE_struct={
			112,
			31,
			126,
			255
		};
		Color * ptr_DARKPURPLE_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_DARKPURPLE_js[0]=DARKPURPLE_struct;
		JSValue DARKPURPLE_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(DARKPURPLE_js,(void *)ptr_DARKPURPLE_js);
		JS_SetModuleExport(ctx,m,(const char *)"DARKPURPLE",DARKPURPLE_js);
		Color BEIGE_struct={
			211,
			176,
			131,
			255
		};
		Color * ptr_BEIGE_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_BEIGE_js[0]=BEIGE_struct;
		JSValue BEIGE_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(BEIGE_js,(void *)ptr_BEIGE_js);
		JS_SetModuleExport(ctx,m,(const char *)"BEIGE",BEIGE_js);
		Color BROWN_struct={
			127,
			106,
			79,
			255
		};
		Color * ptr_BROWN_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_BROWN_js[0]=BROWN_struct;
		JSValue BROWN_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(BROWN_js,(void *)ptr_BROWN_js);
		JS_SetModuleExport(ctx,m,(const char *)"BROWN",BROWN_js);
		Color DARKBROWN_struct={
			76,
			63,
			47,
			255
		};
		Color * ptr_DARKBROWN_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_DARKBROWN_js[0]=DARKBROWN_struct;
		JSValue DARKBROWN_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(DARKBROWN_js,(void *)ptr_DARKBROWN_js);
		JS_SetModuleExport(ctx,m,(const char *)"DARKBROWN",DARKBROWN_js);
		Color WHITE_struct={
			255,
			255,
			255,
			255
		};
		Color * ptr_WHITE_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_WHITE_js[0]=WHITE_struct;
		JSValue WHITE_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(WHITE_js,(void *)ptr_WHITE_js);
		JS_SetModuleExport(ctx,m,(const char *)"WHITE",WHITE_js);
		Color BLACK_struct={
			0,
			0,
			0,
			255
		};
		Color * ptr_BLACK_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_BLACK_js[0]=BLACK_struct;
		JSValue BLACK_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(BLACK_js,(void *)ptr_BLACK_js);
		JS_SetModuleExport(ctx,m,(const char *)"BLACK",BLACK_js);
		Color BLANK_struct={
			0,
			0,
			0,
			0
		};
		Color * ptr_BLANK_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_BLANK_js[0]=BLANK_struct;
		JSValue BLANK_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(BLANK_js,(void *)ptr_BLANK_js);
		JS_SetModuleExport(ctx,m,(const char *)"BLANK",BLANK_js);
		Color MAGENTA_struct={
			255,
			0,
			255,
			255
		};
		Color * ptr_MAGENTA_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_MAGENTA_js[0]=MAGENTA_struct;
		JSValue MAGENTA_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(MAGENTA_js,(void *)ptr_MAGENTA_js);
		JS_SetModuleExport(ctx,m,(const char *)"MAGENTA",MAGENTA_js);
		Color RAYWHITE_struct={
			245,
			245,
			245,
			255
		};
		Color * ptr_RAYWHITE_js=(Color *)js_malloc(ctx,sizeof(Color));
		ptr_RAYWHITE_js[0]=RAYWHITE_struct;
		JSValue RAYWHITE_js=JS_NewObjectClass(ctx,(int)js_Color_class_id);
		JS_SetOpaque(RAYWHITE_js,(void *)ptr_RAYWHITE_js);
		JS_SetModuleExport(ctx,m,(const char *)"RAYWHITE",RAYWHITE_js);
		return 0;
	}
	
	JSModuleDef * js_init_module_js_raylib(JSContext * ctx,const char * module_name){
		JSModuleDef * m=JS_NewCModule(ctx,module_name,js_js_raylib_init);
		if(!m){
			return NULL;
		}
		size_t listcount=countof(jsraylib_funcs);
		JS_AddModuleExportList(ctx,m,jsraylib_funcs,(int)listcount);
		JS_AddModuleExport(ctx,m,(const char *)"Vector2");
		JS_AddModuleExport(ctx,m,(const char *)"Vector3");
		JS_AddModuleExport(ctx,m,(const char *)"Vector4");
		JS_AddModuleExport(ctx,m,(const char *)"Matrix");
		JS_AddModuleExport(ctx,m,(const char *)"Color");
		JS_AddModuleExport(ctx,m,(const char *)"Rectangle");
		JS_AddModuleExport(ctx,m,(const char *)"Image");
		JS_AddModuleExport(ctx,m,(const char *)"Texture");
		JS_AddModuleExport(ctx,m,(const char *)"RenderTexture");
		JS_AddModuleExport(ctx,m,(const char *)"NPatchInfo");
		JS_AddModuleExport(ctx,m,(const char *)"GlyphInfo");
		JS_AddModuleExport(ctx,m,(const char *)"Font");
		JS_AddModuleExport(ctx,m,(const char *)"Camera3D");
		JS_AddModuleExport(ctx,m,(const char *)"Camera2D");
		JS_AddModuleExport(ctx,m,(const char *)"Mesh");
		JS_AddModuleExport(ctx,m,(const char *)"Shader");
		JS_AddModuleExport(ctx,m,(const char *)"MaterialMap");
		JS_AddModuleExport(ctx,m,(const char *)"Material");
		JS_AddModuleExport(ctx,m,(const char *)"Transform");
		JS_AddModuleExport(ctx,m,(const char *)"BoneInfo");
		JS_AddModuleExport(ctx,m,(const char *)"Model");
		JS_AddModuleExport(ctx,m,(const char *)"ModelAnimation");
		JS_AddModuleExport(ctx,m,(const char *)"Ray");
		JS_AddModuleExport(ctx,m,(const char *)"RayCollision");
		JS_AddModuleExport(ctx,m,(const char *)"BoundingBox");
		JS_AddModuleExport(ctx,m,(const char *)"Wave");
		JS_AddModuleExport(ctx,m,(const char *)"AudioStream");
		JS_AddModuleExport(ctx,m,(const char *)"Sound");
		JS_AddModuleExport(ctx,m,(const char *)"Music");
		JS_AddModuleExport(ctx,m,(const char *)"VrDeviceInfo");
		JS_AddModuleExport(ctx,m,(const char *)"VrStereoConfig");
		JS_AddModuleExport(ctx,m,(const char *)"FilePathList");
		JS_AddModuleExport(ctx,m,(const char *)"AutomationEvent");
		JS_AddModuleExport(ctx,m,(const char *)"AutomationEventList");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_VSYNC_HINT");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_FULLSCREEN_MODE");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_WINDOW_RESIZABLE");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_WINDOW_UNDECORATED");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_WINDOW_HIDDEN");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_WINDOW_MINIMIZED");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_WINDOW_MAXIMIZED");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_WINDOW_UNFOCUSED");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_WINDOW_TOPMOST");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_WINDOW_ALWAYS_RUN");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_WINDOW_TRANSPARENT");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_WINDOW_HIGHDPI");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_WINDOW_MOUSE_PASSTHROUGH");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_BORDERLESS_WINDOWED_MODE");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_MSAA_4X_HINT");
		JS_AddModuleExport(ctx,m,(const char *)"FLAG_INTERLACED_HINT");
		JS_AddModuleExport(ctx,m,(const char *)"LOG_ALL");
		JS_AddModuleExport(ctx,m,(const char *)"LOG_TRACE");
		JS_AddModuleExport(ctx,m,(const char *)"LOG_DEBUG");
		JS_AddModuleExport(ctx,m,(const char *)"LOG_INFO");
		JS_AddModuleExport(ctx,m,(const char *)"LOG_WARNING");
		JS_AddModuleExport(ctx,m,(const char *)"LOG_ERROR");
		JS_AddModuleExport(ctx,m,(const char *)"LOG_FATAL");
		JS_AddModuleExport(ctx,m,(const char *)"LOG_NONE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_NULL");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_APOSTROPHE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_COMMA");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_MINUS");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_PERIOD");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_SLASH");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_ZERO");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_ONE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_TWO");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_THREE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_FOUR");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_FIVE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_SIX");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_SEVEN");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_EIGHT");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_NINE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_SEMICOLON");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_EQUAL");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_A");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_B");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_C");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_D");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_E");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_G");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_H");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_I");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_J");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_K");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_L");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_M");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_N");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_O");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_P");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_Q");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_R");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_S");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_T");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_U");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_V");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_W");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_X");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_Y");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_Z");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_LEFT_BRACKET");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_BACKSLASH");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_RIGHT_BRACKET");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_GRAVE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_SPACE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_ESCAPE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_ENTER");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_TAB");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_BACKSPACE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_INSERT");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_DELETE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_RIGHT");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_LEFT");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_DOWN");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_UP");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_PAGE_UP");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_PAGE_DOWN");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_HOME");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_END");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_CAPS_LOCK");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_SCROLL_LOCK");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_NUM_LOCK");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_PRINT_SCREEN");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_PAUSE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F1");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F2");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F3");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F4");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F5");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F6");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F7");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F8");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F9");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F10");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F11");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_F12");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_LEFT_SHIFT");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_LEFT_CONTROL");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_LEFT_ALT");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_LEFT_SUPER");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_RIGHT_SHIFT");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_RIGHT_CONTROL");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_RIGHT_ALT");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_RIGHT_SUPER");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KB_MENU");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_0");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_1");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_2");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_3");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_4");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_5");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_6");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_7");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_8");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_9");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_DECIMAL");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_DIVIDE");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_MULTIPLY");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_SUBTRACT");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_ADD");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_ENTER");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_KP_EQUAL");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_BACK");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_MENU");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_VOLUME_UP");
		JS_AddModuleExport(ctx,m,(const char *)"KEY_VOLUME_DOWN");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_LEFT");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_RIGHT");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_MIDDLE");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_SIDE");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_EXTRA");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_FORWARD");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_BUTTON_BACK");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_LEFT_BUTTON");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_RIGHT_BUTTON");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_MIDDLE_BUTTON");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_DEFAULT");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_ARROW");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_IBEAM");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_CROSSHAIR");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_POINTING_HAND");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_RESIZE_EW");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_RESIZE_NS");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_RESIZE_NWSE");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_RESIZE_NESW");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_RESIZE_ALL");
		JS_AddModuleExport(ctx,m,(const char *)"MOUSE_CURSOR_NOT_ALLOWED");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_UNKNOWN");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_FACE_UP");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_FACE_RIGHT");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_FACE_DOWN");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_FACE_LEFT");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_FACE_UP");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_FACE_RIGHT");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_FACE_DOWN");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_FACE_LEFT");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_TRIGGER_1");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_TRIGGER_2");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_TRIGGER_1");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_TRIGGER_2");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_MIDDLE_LEFT");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_MIDDLE");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_MIDDLE_RIGHT");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_LEFT_THUMB");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_BUTTON_RIGHT_THUMB");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_AXIS_LEFT_X");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_AXIS_LEFT_Y");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_AXIS_RIGHT_X");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_AXIS_RIGHT_Y");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_AXIS_LEFT_TRIGGER");
		JS_AddModuleExport(ctx,m,(const char *)"GAMEPAD_AXIS_RIGHT_TRIGGER");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_ALBEDO");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_METALNESS");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_NORMAL");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_ROUGHNESS");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_OCCLUSION");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_EMISSION");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_HEIGHT");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_CUBEMAP");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_IRRADIANCE");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_PREFILTER");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_BRDF");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_DIFFUSE");
		JS_AddModuleExport(ctx,m,(const char *)"MATERIAL_MAP_SPECULAR");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_POSITION");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_TEXCOORD01");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_TEXCOORD02");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_NORMAL");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_TANGENT");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_COLOR");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MATRIX_MVP");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MATRIX_VIEW");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MATRIX_PROJECTION");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MATRIX_MODEL");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MATRIX_NORMAL");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_VECTOR_VIEW");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_COLOR_DIFFUSE");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_COLOR_SPECULAR");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_COLOR_AMBIENT");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_ALBEDO");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_METALNESS");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_NORMAL");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_ROUGHNESS");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_OCCLUSION");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_EMISSION");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_HEIGHT");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_CUBEMAP");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_IRRADIANCE");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_PREFILTER");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_BRDF");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_BONEIDS");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_BONEWEIGHTS");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_BONE_MATRICES");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_VERTEX_INSTANCE_TX");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_DIFFUSE");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_LOC_MAP_SPECULAR");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_FLOAT");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_VEC2");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_VEC3");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_VEC4");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_INT");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_IVEC2");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_IVEC3");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_IVEC4");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_UINT");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_UIVEC2");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_UIVEC3");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_UIVEC4");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_UNIFORM_SAMPLER2D");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_ATTRIB_FLOAT");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_ATTRIB_VEC2");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_ATTRIB_VEC3");
		JS_AddModuleExport(ctx,m,(const char *)"SHADER_ATTRIB_VEC4");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_GRAYSCALE");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R5G6B5");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R8G8B8");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R5G5B5A1");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R4G4B4A4");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R8G8B8A8");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R32");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R32G32B32");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R32G32B32A32");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R16");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R16G16B16");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_UNCOMPRESSED_R16G16B16A16");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_DXT1_RGB");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_DXT1_RGBA");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_DXT3_RGBA");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_DXT5_RGBA");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_ETC1_RGB");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_ETC2_RGB");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_PVRT_RGB");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_PVRT_RGBA");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA");
		JS_AddModuleExport(ctx,m,(const char *)"PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA");
		JS_AddModuleExport(ctx,m,(const char *)"TEXTURE_FILTER_POINT");
		JS_AddModuleExport(ctx,m,(const char *)"TEXTURE_FILTER_BILINEAR");
		JS_AddModuleExport(ctx,m,(const char *)"TEXTURE_FILTER_TRILINEAR");
		JS_AddModuleExport(ctx,m,(const char *)"TEXTURE_FILTER_ANISOTROPIC_4X");
		JS_AddModuleExport(ctx,m,(const char *)"TEXTURE_FILTER_ANISOTROPIC_8X");
		JS_AddModuleExport(ctx,m,(const char *)"TEXTURE_FILTER_ANISOTROPIC_16X");
		JS_AddModuleExport(ctx,m,(const char *)"TEXTURE_WRAP_REPEAT");
		JS_AddModuleExport(ctx,m,(const char *)"TEXTURE_WRAP_CLAMP");
		JS_AddModuleExport(ctx,m,(const char *)"TEXTURE_WRAP_MIRROR_REPEAT");
		JS_AddModuleExport(ctx,m,(const char *)"TEXTURE_WRAP_MIRROR_CLAMP");
		JS_AddModuleExport(ctx,m,(const char *)"CUBEMAP_LAYOUT_AUTO_DETECT");
		JS_AddModuleExport(ctx,m,(const char *)"CUBEMAP_LAYOUT_LINE_VERTICAL");
		JS_AddModuleExport(ctx,m,(const char *)"CUBEMAP_LAYOUT_LINE_HORIZONTAL");
		JS_AddModuleExport(ctx,m,(const char *)"CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR");
		JS_AddModuleExport(ctx,m,(const char *)"CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE");
		JS_AddModuleExport(ctx,m,(const char *)"FONT_DEFAULT");
		JS_AddModuleExport(ctx,m,(const char *)"FONT_BITMAP");
		JS_AddModuleExport(ctx,m,(const char *)"FONT_SDF");
		JS_AddModuleExport(ctx,m,(const char *)"BLEND_ALPHA");
		JS_AddModuleExport(ctx,m,(const char *)"BLEND_ADDITIVE");
		JS_AddModuleExport(ctx,m,(const char *)"BLEND_MULTIPLIED");
		JS_AddModuleExport(ctx,m,(const char *)"BLEND_ADD_COLORS");
		JS_AddModuleExport(ctx,m,(const char *)"BLEND_SUBTRACT_COLORS");
		JS_AddModuleExport(ctx,m,(const char *)"BLEND_ALPHA_PREMULTIPLY");
		JS_AddModuleExport(ctx,m,(const char *)"BLEND_CUSTOM");
		JS_AddModuleExport(ctx,m,(const char *)"BLEND_CUSTOM_SEPARATE");
		JS_AddModuleExport(ctx,m,(const char *)"GESTURE_NONE");
		JS_AddModuleExport(ctx,m,(const char *)"GESTURE_TAP");
		JS_AddModuleExport(ctx,m,(const char *)"GESTURE_DOUBLETAP");
		JS_AddModuleExport(ctx,m,(const char *)"GESTURE_HOLD");
		JS_AddModuleExport(ctx,m,(const char *)"GESTURE_DRAG");
		JS_AddModuleExport(ctx,m,(const char *)"GESTURE_SWIPE_RIGHT");
		JS_AddModuleExport(ctx,m,(const char *)"GESTURE_SWIPE_LEFT");
		JS_AddModuleExport(ctx,m,(const char *)"GESTURE_SWIPE_UP");
		JS_AddModuleExport(ctx,m,(const char *)"GESTURE_SWIPE_DOWN");
		JS_AddModuleExport(ctx,m,(const char *)"GESTURE_PINCH_IN");
		JS_AddModuleExport(ctx,m,(const char *)"GESTURE_PINCH_OUT");
		JS_AddModuleExport(ctx,m,(const char *)"CAMERA_CUSTOM");
		JS_AddModuleExport(ctx,m,(const char *)"CAMERA_FREE");
		JS_AddModuleExport(ctx,m,(const char *)"CAMERA_ORBITAL");
		JS_AddModuleExport(ctx,m,(const char *)"CAMERA_FIRST_PERSON");
		JS_AddModuleExport(ctx,m,(const char *)"CAMERA_THIRD_PERSON");
		JS_AddModuleExport(ctx,m,(const char *)"CAMERA_PERSPECTIVE");
		JS_AddModuleExport(ctx,m,(const char *)"CAMERA_ORTHOGRAPHIC");
		JS_AddModuleExport(ctx,m,(const char *)"NPATCH_NINE_PATCH");
		JS_AddModuleExport(ctx,m,(const char *)"NPATCH_THREE_PATCH_VERTICAL");
		JS_AddModuleExport(ctx,m,(const char *)"NPATCH_THREE_PATCH_HORIZONTAL");
		JS_AddModuleExport(ctx,m,(const char *)"RAYLIB_VERSION_MAJOR");
		JS_AddModuleExport(ctx,m,(const char *)"RAYLIB_VERSION_MINOR");
		JS_AddModuleExport(ctx,m,(const char *)"RAYLIB_VERSION_PATCH");
		JS_AddModuleExport(ctx,m,(const char *)"PI");
		JS_AddModuleExport(ctx,m,(const char *)"DEG2RAD");
		JS_AddModuleExport(ctx,m,(const char *)"RAD2DEG");
		JS_AddModuleExport(ctx,m,(const char *)"LIGHTGRAY");
		JS_AddModuleExport(ctx,m,(const char *)"GRAY");
		JS_AddModuleExport(ctx,m,(const char *)"DARKGRAY");
		JS_AddModuleExport(ctx,m,(const char *)"YELLOW");
		JS_AddModuleExport(ctx,m,(const char *)"GOLD");
		JS_AddModuleExport(ctx,m,(const char *)"ORANGE");
		JS_AddModuleExport(ctx,m,(const char *)"PINK");
		JS_AddModuleExport(ctx,m,(const char *)"RED");
		JS_AddModuleExport(ctx,m,(const char *)"MAROON");
		JS_AddModuleExport(ctx,m,(const char *)"GREEN");
		JS_AddModuleExport(ctx,m,(const char *)"LIME");
		JS_AddModuleExport(ctx,m,(const char *)"DARKGREEN");
		JS_AddModuleExport(ctx,m,(const char *)"SKYBLUE");
		JS_AddModuleExport(ctx,m,(const char *)"BLUE");
		JS_AddModuleExport(ctx,m,(const char *)"DARKBLUE");
		JS_AddModuleExport(ctx,m,(const char *)"PURPLE");
		JS_AddModuleExport(ctx,m,(const char *)"VIOLET");
		JS_AddModuleExport(ctx,m,(const char *)"DARKPURPLE");
		JS_AddModuleExport(ctx,m,(const char *)"BEIGE");
		JS_AddModuleExport(ctx,m,(const char *)"BROWN");
		JS_AddModuleExport(ctx,m,(const char *)"DARKBROWN");
		JS_AddModuleExport(ctx,m,(const char *)"WHITE");
		JS_AddModuleExport(ctx,m,(const char *)"BLACK");
		JS_AddModuleExport(ctx,m,(const char *)"BLANK");
		JS_AddModuleExport(ctx,m,(const char *)"MAGENTA");
		JS_AddModuleExport(ctx,m,(const char *)"RAYWHITE");
		return m;
	}

#endif //JS_js_raylib_GUARD